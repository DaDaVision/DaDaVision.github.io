<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>剑指Offer（五十三）：表示数值的字符串</title>
      <link href="/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题还是比较简单的。表示数值的字符串遵循如下模式：</p><p>[sign]integral-digits.[fractional-digits]exponential-digits]</p><p>其中，(‘[‘和’]’之间的为可有可无的部分)。</p><p>在数值之前可能有一个表示正负的’+’或者’-‘。接下来是若干个0到9的数位表示数值的整数部分（在某些小数里可能没有数值的整数部分）。如果数值是一个小数，那么在小数后面可能会有若干个0到9的数位表示数值的小数部分。如果数值用科学记数法表示，接下来是一个’e’或者’E’，以及紧跟着的一个整数（可以有正负号）表示指数。</p><p>判断一个字符串是否符合上述模式时，首先看第一个字符是不是正负号。如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。如果是一个小数，则将遇到小数点。另外，如果是用科学记数法表示的数值，在整数或者小数的后面还有可能遇到’e’或者’E’。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，</span></span><br><span class="line">    <span class="comment">// 其中A和C都是整数（可以有正负号，也可以没有）</span></span><br><span class="line">    <span class="comment">// 而B是一个无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 非法输入处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">NULL</span> || *<span class="built_in">string</span> == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正负号判断</span></span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'+'</span> || *<span class="built_in">string</span> == <span class="string">'-'</span>)&#123;</span><br><span class="line">            ++<span class="built_in">string</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> numeric = <span class="literal">true</span>;</span><br><span class="line">        scanDigits(&amp;<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">string</span> != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 小数判断</span></span><br><span class="line">            <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'.'</span>)&#123;</span><br><span class="line">                ++<span class="built_in">string</span>;</span><br><span class="line">                scanDigits(&amp;<span class="built_in">string</span>);</span><br><span class="line">                <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'e'</span> || *<span class="built_in">string</span> == <span class="string">'E'</span>)&#123;</span><br><span class="line">                    numeric = isExponential(&amp;<span class="built_in">string</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 整数判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'e'</span> || *<span class="built_in">string</span> == <span class="string">'E'</span>)&#123;</span><br><span class="line">                numeric = isExponential(&amp;<span class="built_in">string</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                numeric = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; *<span class="built_in">string</span> == <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 扫描数字，对于合法数字，直接跳过</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scanDigits</span><span class="params">(<span class="keyword">char</span>** <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(**<span class="built_in">string</span> != <span class="string">'\0'</span> &amp;&amp; **<span class="built_in">string</span> &gt;= <span class="string">'0'</span> &amp;&amp; **<span class="built_in">string</span> &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            ++(*<span class="built_in">string</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来潘达un科学计数法表示的数值的结尾部分是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isExponential</span><span class="params">(<span class="keyword">char</span>** <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">        ++(*<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span>(**<span class="built_in">string</span> == <span class="string">'+'</span> || **<span class="built_in">string</span> == <span class="string">'-'</span>)&#123;</span><br><span class="line">            ++(*<span class="built_in">string</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(**<span class="built_in">string</span> == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scanDigits(<span class="built_in">string</span>);</span><br><span class="line">        <span class="comment">// 判断是否结尾，如果没有结尾，说明还有其他非法字符串</span></span><br><span class="line">        <span class="keyword">return</span> (**<span class="built_in">string</span> == <span class="string">'\0'</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（五十二）：正则表达式匹配</title>
      <link href="/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>请实现一个函数用来匹配包括’.’和’*’的正则表达式。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题有些绕，需要好好思考下。</p><p>我们先来分析下如何匹配一个字符，现在只考虑字符’.’，不考虑’*’看一下：</p><p>如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。</p><p>接下来，把字符’*’考虑进去，它可以匹配任意次的字符，当然出现0次也可以。</p><p>我们分两种情况来看：</p><ul><li>模式串的下一个字符不是’*’，也就是上面说的只有字符’.’的情况。</li></ul><p>如果字符串中的第一个字符和模式串中的第一个字符相匹配，那么字符串的模式串都向后移动一个字符，然后匹配剩余的字符串和模式串。如果字符串中的第一个字符和模式中的第一个字符不相匹配，则直接返回false。</p><ul><li>模式串的下一个字符是’*’，此时就要复杂一些。</li></ul><p>因为可能有多种不同的匹配方式。</p><p>选择一：无论字符串和模式串当前字符相不相等，我们都将模式串后移两个字符，相当于把模式串中的当前字符和’<em>‘忽略掉，因为’</em>‘可以匹配任意次的字符，所以出现0次也可以。</p><p>选择二：如果字符串和模式串当前字符相等，则字符串向后移动一个字符。而模式串此时有两个选择：</p><p>1、我们可以在模式串向后移动两个字符，继续匹配；</p><p>2、也可以保持模式串不变，这样相当于用字符’<em>‘继续匹配字符串，也就是模式串中的字符’</em>‘匹配字符串中的字符多个的情况。</p><p>用一张图表示如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-af5633fd28965d63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如上图所示，当匹配进入状态2，并且字符串中的字符是’a’时，我们有两个选择：可以进入状态3（在模式串向后移动两个字符），也可以回到状态2（模式串保持不变）。</p><p>除此之外，还要注意对空指针的处理。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 指针为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 字符串和模式串都运行到了结尾，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符串没有到结尾，模式串到了，则返回false</span></span><br><span class="line">        <span class="comment">// 模式串没有到结尾，字符串到了，则根据后续判断进行，需要对'*'做处理</span></span><br><span class="line">        <span class="keyword">if</span>((*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果模式串的下一个字符是'*'，则进入状态机的匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果字符串和模式串相等，或者模式串是'.'，并且字符串没有到结尾，则继续匹配</span></span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))&#123;</span><br><span class="line">                <span class="comment">// 进入下一个状态，就是匹配到了一个</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>) ||</span><br><span class="line">                    <span class="comment">// 保持当前状态，就是继续那这个'*'去匹配</span></span><br><span class="line">                    matchCore(str + <span class="number">1</span>, pattern) ||</span><br><span class="line">                    <span class="comment">// 跳过这个'*'</span></span><br><span class="line">                    matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果字符串和模式串不相等，则跳过当前模式串的字符和'*'，进入新一轮的匹配</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 跳过这个'*'</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果字符串和模式串相等，或者模式串是'.'，并且字符串没有到结尾，则继续匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（四十九）：把字符串转换成整数</title>
      <link href="/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
      <url>/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><a id="more"></a><p><strong>输入描述：</strong></p><p>输入一个字符串,包括数字字母符号,可以为空</p><p><strong>输出描述：</strong></p><p>如果是合法的数值表达则返回该数字，否则返回0</p><p>示例1</p><p>输入</p><blockquote><p>+2147483647</p><p>1a33</p></blockquote><p>输出</p><blockquote><p>2147483647</p><p>0</p></blockquote><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题要考虑全面，对异常值要做出处理。</p><p>对于这个题目，需要注意的要点有：</p><ul><li>指针是否为空指针以及字符串是否为空字符串；</li><li>字符串对于正负号的处理；</li><li>输入值是否为合法值，即小于等于’9’，大于等于’0’；</li><li>int为32位，需要判断是否溢出；</li><li>使用错误标志，区分合法值0和非法值0。</li></ul><p>代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，minus标志位用来表示是否为负数。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status&#123;kValid = <span class="number">0</span>, kInValid&#125;;</span><br><span class="line">    <span class="keyword">int</span> g_nStatus = kValid;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        g_nStatus = kInValid;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line">        <span class="comment">// 判断是否为指针和是否为空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(cstr != <span class="literal">NULL</span> &amp;&amp; *cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 正负号标志位，默认是加号</span></span><br><span class="line">            <span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(*cstr == <span class="string">'+'</span>)&#123;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*cstr == <span class="string">'-'</span>)&#123;</span><br><span class="line">                minus = <span class="literal">true</span>;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(*cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">                num = StrToIntCore(cstr, minus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr, <span class="keyword">bool</span> minus)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断是否是非法值</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr &gt;= <span class="string">'0'</span> &amp;&amp; *cstr &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + flag * (*cstr - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">// 判断是否溢出,32位</span></span><br><span class="line">                <span class="keyword">if</span>((!minus &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))&#123;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否正常结束</span></span><br><span class="line">        <span class="keyword">if</span>(*cstr == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            g_nStatus = kValid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minus = <span class="keyword">False</span></span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                minus = <span class="keyword">True</span></span><br><span class="line">            begin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                begin = <span class="number">1</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            minus = <span class="number">-1</span> <span class="keyword">if</span> minus <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> each <span class="keyword">in</span> s[begin:]:</span><br><span class="line">                <span class="keyword">if</span> each &gt;= <span class="string">'0'</span> <span class="keyword">and</span> each &lt;= <span class="string">'9'</span>:</span><br><span class="line">                    num = num * <span class="number">10</span> + minus * (ord(each) - ord(<span class="string">'0'</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（四十四）：翻转单词顺序序列</title>
      <link href="/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
      <url>/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>翻转单词顺序序列，将“student. a am I”翻转成正确的“I am a student.”</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>观察字符串变化规律，你会发现这道题很简单。只需要对每个单词做翻转，然后再整体做翻转就得到了正确的结果。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = str;</span><br><span class="line">        <span class="keyword">int</span> length = result.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 追加一个空格，作为反转标志位</span></span><br><span class="line">        result += <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据空格，反转所有单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                Reverse(result, mark, i - <span class="number">1</span>);</span><br><span class="line">                mark = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉添加的空格</span></span><br><span class="line">        result = result.substr(<span class="number">0</span>, length);</span><br><span class="line">        <span class="comment">// 整体反转</span></span><br><span class="line">        Reverse(result, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//注意是string &amp;str，不是string str(最普通的参数传递方式，不可以直接改变传递进来的对象。)</span></span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">            swap(str[begin++], str[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s_list = s.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s_list[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（四十三）：左旋转字符串</title>
      <link href="/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！😁<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>例如：输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”;</p><p>第一步：翻转字符串“ab”，得到”ba”；</p><p>第二步：翻转字符串”cdefg”，得到”gfedc”；</p><p>第三步：翻转字符串”bagfedc”，得到”cdefgab”；</p><p>或者：</p><p>第一步：翻转整个字符串”abcdefg”,得到”gfedcba”</p><p>第二步：翻转字符串“gfedc”，得到”cdefg”</p><p>第三步：翻转字符串”ba”,得到”ab”</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = str;</span><br><span class="line">        <span class="keyword">int</span> length = result.size();</span><br><span class="line">        <span class="keyword">if</span>(length &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &lt;= n &lt;= length)&#123;</span><br><span class="line">            <span class="keyword">int</span> pFirstBegin = <span class="number">0</span>, pFirstEnd = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pSecondBegin = n, pSecondEnd = length - <span class="number">1</span>;</span><br><span class="line">            ReverseString(result, pFirstBegin, pFirstEnd);</span><br><span class="line">            ReverseString(result, pSecondBegin, pSecondEnd);</span><br><span class="line">            ReverseString(result, pFirstBegin, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">            swap(str[begin++], str[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">if</span> n &gt; length:</span><br><span class="line">            n = n % length</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（三十四）：第一个只出现一次的字符</title>
      <link href="/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>在一个字符串中找到第一个只出现一次的字符,并返回它的位置。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>建立一个哈希表，第一次扫描的时候，统计每个字符的出现次数。第二次扫描的时候，如果该字符出现的次数为1，则返回这个字符的位置。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = str.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; item;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            item[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item[str[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> str[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        item = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> item.keys():</span><br><span class="line">                item[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item[s[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> item[s[i]] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（二十七）：字符串的排列</title>
      <link href="/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><a id="more"></a></p><p><strong>输入描述：</strong></p><p>输入一个字符串,长度不超过9(可能有字符重复)，字符只包括大小写字母。</p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4980988863882df8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。</p><p>这个思路，是典型的递归思路。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="comment">//判断输入</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        PermutationCore(str, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//对结果进行排序</span></span><br><span class="line">        sort(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归结束的条件：第一位和最后一位交换完成</span></span><br><span class="line">        <span class="keyword">if</span>(begin == str.length())&#123;</span><br><span class="line">            result.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//如果字符串相同，则不交换</span></span><br><span class="line">            <span class="keyword">if</span>(i != begin &amp;&amp; str[i] == str[begin])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置交换</span></span><br><span class="line">            swap(str[begin], str[i]);</span><br><span class="line">            <span class="comment">//递归调用，前面begin+1的位置不变，后面的字符串全排列</span></span><br><span class="line">            PermutationCore(str, begin + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(ss) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.PermutationCore(ss, <span class="number">0</span>)</span><br><span class="line">        sorted(self.result)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PermutationCore</span><span class="params">(self, str_, begin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> begin == len(str_):</span><br><span class="line">            self.result.append(str_)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, len(str_)):</span><br><span class="line">            <span class="keyword">if</span> i != begin <span class="keyword">and</span> str_[i] == str_[begin]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            str_list = list(str_)</span><br><span class="line">            str_list[i], str_list[begin] = str_list[begin], str_list[i]</span><br><span class="line">            str_ = <span class="string">''</span>.join(str_list)</span><br><span class="line">            self.PermutationCore(str_, begin+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(ss) &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = list()</span><br><span class="line">        self.perm(ss,res,<span class="string">''</span>)</span><br><span class="line">        uniq = list(set(res))</span><br><span class="line">        <span class="keyword">return</span> sorted(uniq)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perm</span><span class="params">(self,ss,res,path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ss==<span class="string">''</span>:</span><br><span class="line">            res.append(path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                self.perm(ss[:i]+ss[i+<span class="number">1</span>:],res,path+ss[i])</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习笔试面试总结</title>
      <link href="/2018/09/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习笔试面试总结</title>
      <link href="/2018/09/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><strong>Q1. 下列说法正确的是？（多选）</strong></p><p>A. AdaGrad 使用的是一阶导数</p><p>B. L-BFGS 使用的是二阶导数</p><p>C. AdaGrad 使用的是二阶导数<br><a id="more"></a></p><p>D. L-BFGS 使用的是一阶导数</p><p><strong>答案</strong>：AB</p><p><strong>解析</strong>：AdaGrad 是基于梯度下降算法的，AdaGrad算法能够在训练中自动的对学习速率 α 进行调整，对于出现频率较低参数采用较大的 α 更新；相反，对于出现频率较高的参数采用较小的 α 更新。Adagrad非常适合处理稀疏数据。很明显，AdaGrad 算法利用的是一阶导数。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-72719e5327ac8b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>L-BFGS 是基于牛顿优化算法的，牛顿优化算法使用的是二阶导数。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-83efe7aa07c70bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q2. “增加卷积核的尺寸，一定能提高卷积神经网络的性能。” 这句话是否正确？</strong></p><p>A. 正确</p><p>B. 错误</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：卷积核的尺寸是超参数，不一定增加其尺寸就一定增加神经网络的性能，需要验证选择最佳尺寸。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f6f31ede1eaafc51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q3. 假设你在卷积神经网络的第一层中有 5 个卷积核，每个卷积核尺寸为 7×7，具有零填充且步幅为 1。该层的输入图片的维度是 224×224×3。那么该层输出的维度是多少？</strong></p><p>A. 217 x 217 x 3</p><p>B. 217 x 217 x 8</p><p>C. 218 x 218 x 5</p><p>D. 220 x 220 x 7</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：一般地，如果原始图片尺寸为 nxn，filter 尺寸为 fxf，则卷积后的图片尺寸为 (n-f+1)x(n-f+1)，注意 f 一般为奇数。</p><p>若考虑存在填充和步幅，用 s 表示 stride 长度，p 表示 padding 长度，如果原始图片尺寸为 nxn，filter 尺寸为 fxf，则卷积后的图片尺寸为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f6f31ede1eaafc51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上式中，⌊⋯⌋ 表示向下取整。</p><p>此例中， n=224，p=0，f=7，s=1，因此，该层输出的尺寸为 218x218。</p><p>输出的第三个维度由滤波器的个数决定，即为 5。</p><p><strong>Q4. 假如现在有个神经网络，激活函数是 ReLU，若使用线性激活函数代替 ReLU，那么该神经网络还能表征 XNOR 函数吗？</strong></p><p>A. 可以</p><p>B. 不可以</p><p><strong>答案</strong>：B</p><p>解析：异或（XNOR）关系是非线性的，线性激活函数只能解决线性问题，不能解决非线性问题。如果用线性激活代替 ReLU，则神经网络失去逼近非线性函数的能力。</p><p><strong>Q5. 机器学习训练时，Mini-Batch 的大小优选为2个的幂，如 256 或 512。它背后的原因是什么？</strong></p><p>A. Mini-Batch 为偶数的时候，梯度下降算法训练的更快</p><p>B. Mini-Batch 设为 2 的 幂，是为了符合 CPU、GPU 的内存要求，利于并行化处理</p><p>C. 不使用偶数时，损失函数是不稳定的</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：B</p><p><strong>Q6. 下列哪种方法可以用来减小过拟合？（多选）</strong></p><p>A. 更多的训练数据</p><p>B. L1 正则化</p><p>C. L2 正则化</p><p>D. 减小模型的复杂度</p><p><strong>答案</strong>：ABCD</p><p><strong>解析</strong>：增加训练样本、L1正则化、L2 正则化、减小模型复杂度都能有效避免发生过拟合。</p><p><strong>Q7. 下列说法错误的是？</strong></p><p>A. 当目标函数是凸函数时，梯度下降算法的解一般就是全局最优解</p><p>B. 进行 PCA 降维时，需要计算协方差矩阵</p><p>C. 沿负梯度的方向一定是最优的方向</p><p>D. 利用拉格朗日函数能解带约束的优化问题</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：沿负梯度的方向是函数值减少最快的方向但不一定就是最优方向。</p><p><strong>Q8. K-Means 算法无法聚以下哪种形状的样本？</strong></p><p>A. 圆形分布</p><p>B. 螺旋分布</p><p>C. 带状分布</p><p>D. 凸多边形分布</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：K-Means 算法是基于距离测量的，无法聚非凸形状的样本。</p><p><strong>Q9. 向量 X=[1,2,3,4,-9,0] 的 L1 范数为？</strong></p><p>A. 1</p><p>B. 19</p><p>C. 6</p><p>D. √111</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：L0 范数表示向量中所有非零元素的个数；L1 范数指的是向量中各元素的绝对值之和，又称“稀疏矩阵算子”；L2 范数指的是向量中各元素的平方和再求平方根。</p><p>本例中，L0 范数为 5，L1 范数为 19，L2 范数为 √111。</p><p><strong>Q10. 关于 L1、L2 正则化下列说法正确的是？</strong></p><p>A. L2 正则化能防止过拟合，提升模型的泛化能力，但 L1 做不到这点</p><p>B. L2 正则化技术又称为 Lasso Regularization</p><p>C. L1 正则化得到的解更加稀疏</p><p>D. L2 正则化得到的解更加稀疏</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：L1、L2 正则化都能防止过拟合，提升模型的泛化能力。L1 正则化技术又称为 Lasso Regularization。L1 正则化得到的解更加稀疏，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-48a462e1fe29342c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以二维情况讨论，上图左边是 L2 正则化，右边是 L1 正则化。从另一个方面来看，满足正则化条件，实际上是求解蓝色区域与黄色区域的交点，即同时满足限定条件和 Ein 最小化。对于 L2 来说，限定区域是圆，这样，得到的解 w1 或 w2 为 0 的概率很小，很大概率是非零的。</p><p>对于 L1 来说，限定区域是正方形，方形与蓝色区域相交的交点是顶点的概率很大，这从视觉和常识上来看是很容易理解的。也就是说，方形的凸点会更接近 Ein 最优解对应的 wlin 位置，而凸点处必有 w1 或 w2 为 0。这样，得到的解 w1 或 w2 为零的概率就很大了。所以，L1 正则化的解具有稀疏性。</p><p>扩展到高维，同样的道理，L2 的限定区域是平滑的，与中心点等距；而 L1 的限定区域是包含凸点的，尖锐的。这些凸点更接近 Ein 的最优解位置，而在这些凸点上，很多 wj 为 0。</p><p><strong>Q11. 有 N 个样本，一般用于训练，一般用于测试。若增大 N 值，则训练误差和测试误差之间的差距会如何变化？</strong></p><p>A. 增大</p><p>B. 减小</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：增加数据，能够有效减小过拟合，减小训练样本误差和测试样本误差之间的差距。</p><p><strong>Q12. 假定你在神经网络中的隐藏层中使用激活函数 X。在特定神经元给定任意输入，你会得到输出 -0.01。X 可能是以下哪一个激活函数？</strong></p><p>A. ReLU</p><p>B. tanh </p><p>C. Sigmoid</p><p>D. 以上都有可能</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：ReLU 的输出范围是 [0,+∞)，tanh 的输出范围是 (-1,+1)，Sigmoid 的输出范围是 (0,+1)。</p><p><strong>Q13. k-NN 最近邻方法在什么情况下效果较好？</strong></p><p>A. 样本较多但典型性不好 </p><p>B. 样本较少但典型性好 </p><p>C. 样本呈团状分布 </p><p>D. 样本呈链状分布 </p><p><strong>答案</strong>：B </p><p><strong>解析</strong>：K 近邻算法主要依靠的是周围的点，因此如果样本过多，则难以区分，典型性好的容易区分。</p><p>样本呈团状或链状都具有迷惑性，这样 kNN 就发挥不出其求近邻的优势了，整体样本应该具有典型性好，样本较少，比较适宜。</p><p><strong>Q14. 下列方法中，可以用于特征降维的方法包括？（多选）</strong></p><p>A. 主成分分析 PCA </p><p>B. 线性判别分析 LDA </p><p>C. AutoEncoder </p><p>D. 矩阵奇异值分解 SVD </p><p>E. 最小二乘法 LeastSquares </p><p><strong>答案</strong>：ABCD </p><p><strong>解析</strong>：主成分分析 PCA 、线性判别分析 LDA 、AutoEncoder、矩阵奇异值分解 SVD 都是用于特征降维的方法。最小二乘法是解决线性回归问题的算法，但是并没有进行降维。</p><p><strong>Q15. 以下哪些方法不可以直接来对文本分类？</strong></p><p>A. K-Means</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. kNN</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：K-Means 是无监督算法，它之所以不能称为分类是因为它之前并没有类别标签，因此只能聚类。</p><p><strong>Q16. 在回归模型中，下列哪一项在权衡欠拟合（under-fitting）和过拟合（over-fitting）中影响最大？</strong></p><p>A. 多项式阶数</p><p>B. 更新权重 w 时，使用的是矩阵求逆还是梯度下降</p><p>C. 使用常数项</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：选择合适的多项式阶数非常重要。如果阶数过大，模型就会更加复杂，容易发生过拟合；如果阶数较小，模型就会过于简单，容易发生欠拟合。如果有对过拟合和欠拟合概念不清楚的，见下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5b857076a6456a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q17. 假设你有以下数据：输入和输出都只有一个变量。使用线性回归模型（y=wx+b）来拟合数据。那么使用留一法（Leave-One Out）交叉验证得到的均方误差是多少？</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-e1ce73a05c75fce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 10/27</p><p>B. 39/27</p><p>C. 49/27</p><p>D. 55/27</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：留一法，简单来说就是假设有 N 个样本，将每一个样本作为测试样本，其它 N-1 个样本作为训练样本。这样得到 N 个分类器，N 个测试结果。用这 N个结果的平均值来衡量模型的性能。</p><p>对于该题，我们先画出 3 个样本点的坐标：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5946f97fb1555707.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用两个点进行线性拟合，分成三种情况，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-64c71d87b2a23885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第一种情况下，回归模型是 y = 2，误差 E1 = 1。</p><p>第二种情况下，回归模型是 y = -x + 4，误差 E2 = 2。</p><p>第三种情况下，回归模型是 y = -1/3x + 2,误差 E3 = 2/3。</p><p>则总的均方误差为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e407dc44d5888d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q18. 下列关于极大似然估计（Maximum Likelihood Estimate，MLE），说法正确的是（多选）？</strong></p><p>A. MLE 可能并不存在</p><p>B. MLE 总是存在</p><p>C. 如果 MLE 存在，那么它的解可能不是唯一的</p><p>D. 如果 MLE 存在，那么它的解一定是唯一的</p><p><strong>答案</strong>：AC</p><p><strong>解析</strong>：如果极大似然函数 L(θ) 在极大值处不连续，一阶导数不存在，则 MLE 不存在，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6b21ad91933d034e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>另一种情况是 MLE 并不唯一，极大值对应两个 θ。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c469c4fe5e9dc986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q19. 如果我们说“线性回归”模型完美地拟合了训练样本（训练样本误差为零），则下面哪个说法是正确的？</strong></p><p>A. 测试样本误差始终为零</p><p>B. 测试样本误差不可能为零</p><p>C. 以上答案都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：根据训练样本误差为零，无法推断测试样本误差是否为零。值得一提是，如果测试样本样本很大，则很可能发生过拟合，模型不具备很好的泛化能力！</p><p><strong>Q20. 在一个线性回归问题中，我们使用 R 平方（R-Squared）来判断拟合度。此时，如果增加一个特征，模型不变，则下面说法正确的是？</strong></p><p>A. 如果 R-Squared 增加，则这个特征有意义</p><p>B. 如果R-Squared 减小，则这个特征没有意义</p><p>C. 仅看 R-Squared 单一变量，无法确定这个特征是否有意义。</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。其表达式如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fc03e7e893d7eb39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上式中，分子部分表示真实值与预测值的平方差之和，类似于均方差 MSE；分母部分表示真实值与均值的平方差之和，类似于方差 Var。根据 R-Squared 的取值，来判断模型的好坏：如果结果是 0，说明模型拟合效果很差；如果结果是 1，说明模型无错误。一般来说，R-Squared 越大，表示模型拟合效果越好。R-Squared 反映的是大概有多准，因为，随着样本数量的增加，R-Square必然增加，无法真正定量说明准确程度，只能大概定量。</p><p>对于本题来说，单独看 R-Squared，并不能推断出增加的特征是否有意义。通常来说，增加一个特征，R-Squared 可能变大也可能保持不变，两者不一定呈正相关。</p><p>如果使用校正决定系数（Adjusted R-Square）：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0c0deca260a65c33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，n 是样本数量，p 是特征数量。Adjusted R-Square 抵消样本数量对 R-Square的影响，做到了真正的 0~1，越大越好。</p><p><strong>Q21. 下列关于线性回归分析中的残差（Residuals）说法正确的是？</strong></p><p>A. 残差均值总是为零</p><p>B. 残差均值总是小于零</p><p>C. 残差均值总是大于零</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：线性回归分析中，目标是残差最小化。残差平方和是关于参数的函数，为了求残差极小值，令残差关于参数的偏导数为零，会得到残差和为零，即残差均值为零。</p><p><strong>Q22. 下列关于异方差（Heteroskedasticity）说法正确的是？</strong></p><p>A. 线性回归具有不同的误差项</p><p>B. 线性回归具有相同的误差项</p><p>C. 线性回归误差项为零</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：异方差性是相对于同方差（Homoskedasticity）而言的。所谓同方差，是为了保证回归参数估计量具有良好的统计性质，经典线性回归模型的一个重要假定：总体回归函数中的随机误差项满足同方差性，即它们都有相同的方差。如果这一假定不满足，即：随机误差项具有不同的方差，则称线性回归模型存在异方差性。</p><p>通常来说，奇异值的出现会导致异方差性增大。</p><p><strong>Q23. 下列哪一项能反映出 X 和 Y 之间的强相关性？</strong></p><p>A. 相关系数为 0.9</p><p>B. 对于无效假设 β=0 的 p 值为 0.0001</p><p>C. 对于无效假设 β=0 的 t 值为 30</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：相关系数的概念我们很熟悉，它反映了不同变量之间线性相关程度，一般用 r 表示。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e5efceb45b6dab94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，Cov(X,Y) 为 X 与 Y 的协方差，Var[X] 为 X 的方差，Var[Y] 为 Y 的方差。r 取值范围在 [-1,1] 之间，r 越大表示相关程度越高。A 选项中，r=0.9 表示 X 和 Y 之间有较强的相关性。</p><p>而 p 和 t 的数值大小没有统计意义，只是将其与某一个阈值进行比对,以得到二选一的结论。例如，有两个假设：</p><ul><li>无效假设（null hypothesis）H0：两参量间不存在“线性”相关。</li><li>备择假设（alternative hypothesis）H1：两参量间存在“线性”相关。</li></ul><p>如果阈值是 0.05，计算出的 p 值很小，比如为 0.001，则可以说“有非常显著的证据拒绝 H0 假设,相信 H1 假设。即两参量间存在“线性”相关。p 值只用于二值化判断，因此不能说 p=0.06 一定比 p=0.07 更好。</p><p><strong>Q24. 下列哪些假设是我们推导线性回归参数时遵循的（多选）？</strong></p><p>A. X 与 Y 有线性关系（多项式关系）</p><p>B. 模型误差在统计学上是独立的</p><p>C. 误差一般服从 0 均值和固定标准差的正态分布</p><p>D. X 是非随机且测量没有误差的</p><p><strong>答案</strong>：ABCD</p><p><strong>解析</strong>：在进行线性回归推导和分析时，我们已经默认上述四个条件是成立的。</p><p><strong>Q25. 为了观察测试 Y 与 X 之间的线性关系，X 是连续变量，使用下列哪种图形比较适合？</strong></p><p>A. 散点图</p><p>B. 柱形图</p><p>C. 直方图</p><p>D. 以上都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：散点图反映了两个变量之间的相互关系，在测试 Y 与 X 之间的线性关系时，使用散点图最为直观。</p><p><strong>Q26. 一般来说，下列哪种方法常用来预测连续独立变量？</strong></p><p>A. 线性回归</p><p>B. 逻辑回顾</p><p>C. 线性回归和逻辑回归都行</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：线性回归一般用于实数预测，逻辑回归一般用于分类问题。</p><p><strong>Q27. 个人健康和年龄的相关系数是 -1.09。根据这个你可以告诉医生哪个结论？</strong></p><p>A. 年龄是健康程度很好的预测器</p><p>B. 年龄是健康程度很糟的预测器</p><p>C. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：因为相关系数的范围是 [-1,1] 之间，所以，-1.09 不可能存在。</p><p><strong>Q28. 下列哪一种偏移，是我们在最小二乘直线拟合的情况下使用的？图中横坐标是输入 X，纵坐标是输出 Y。</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-32f0dd9b646c9298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 垂直偏移（vertical offsets）</p><p>B. 垂向偏移（perpendicular offsets）</p><p>C. 两种偏移都可以</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：线性回归模型计算损失函数，例如均方差损失函数时，使用的都是 vertical offsets。perpendicular offsets 一般用于主成分分析（PCA）中。</p><p><strong>Q29. 假如我们利用 Y 是 X 的 3 阶多项式产生一些数据（3 阶多项式能很好地拟合数据）。那么，下列说法正确的是（多选）？</strong></p><p>A. 简单的线性回归容易造成高偏差（bias）、低方差（variance）</p><p>B. 简单的线性回归容易造成低偏差（bias）、高方差（variance）</p><p>C. 3 阶多项式拟合会造成低偏差（bias）、高方差（variance）</p><p>D. 3 阶多项式拟合具备低偏差（bias）、低方差（variance）</p><p><strong>答案</strong>：AD</p><p><strong>解析</strong>：偏差和方差是两个相对的概念，就像欠拟合和过拟合一样。如果模型过于简单，通常会造成欠拟合，伴随着高偏差、低方差；如果模型过于复杂，通常会造成过拟合，伴随着低偏差、高方差。</p><p>用一张图来形象地表示偏差与方差的关系：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dde5b5280cc26c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>偏差（bias）可以看成模型预测与真实样本的差距，想要得到 low bias，就得复杂化模型，但是容易造成过拟合。方差（variance）可以看成模型在测试集上的表现，想要得到 low variance，就得简化模型，但是容易造成欠拟合。实际应用中，偏差和方差是需要权衡的。若模型在训练样本和测试集上都表现的不错，偏差和方差都会比较小，这也是模型比较理想的情况。</p><p><strong>Q30. 假如你在训练一个线性回归模型，有下面两句话：</strong></p><pre><code>**1. 如果数据量较少，容易发生过拟合。****2. 如果假设空间较小，容易发生过拟合。**</code></pre><p><strong>关于这两句话，下列说法正确的是？</strong></p><p>A. 1 和 2 都错误</p><p>B. 1 正确，2 错误</p><p>C. 1 错误，2 正确</p><p>D. 1 和 2 都正确</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：先来看第 1 句话，如果数据量较少，容易在假设空间找到一个模型对训练样本的拟合度很好，容易造成过拟合，该模型不具备良好的泛化能力。</p><p>再来看第 2 句话，如果假设空间较小，包含的可能的模型就比较少，也就不太可能找到一个模型能够对样本拟合得很好，容易造成高偏差、低方差，即欠拟合。</p><p><strong>Q31. 假如我们使用 Lasso 回归来拟合数据集，该数据集输入特征有 100 个（X1，X2，…，X100）。现在，我们把其中一个特征值扩大 10 倍（例如是特征 X1），然后用相同的正则化参数对 Lasso 回归进行修正。</strong></p><p><strong>那么，下列说法正确的是？</strong></p><p>A. 特征 X1 很可能被排除在模型之外</p><p>B. 特征 X1 很可能还包含在模型之中</p><p>C. 无法确定特征 X1 是否被舍弃</p><p>D. 以上说法都不对</p><p><strong>答案</strong>： B</p><p><strong>解析</strong>：Lasso 回归类似于线性回归，只不过它在线性回归的基础上，增加了一个对所有参数的数值大小约束，如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f824a5250cab98b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，t 为正则化参数。Lasso 回归其实就是在普通线性回归的损失函数的基础上增加了个 β 的约束。那么 β 的约束为什么要使用这种形式，而不使用 β 的平方约束呢？原因就在于第一范数的约束下，一部分回归系数刚好可以被约束为 0。这样的话，就达到了特征选择的效果。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0fd152a1d71f7c9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>左边是第二范式，右边是第一范式。第一范数约束下，β 更有可能被约束成 0。这点非常类似于 L1 和 L2 正则化的区别。</p><p>因此，Lasso 回归适用于样本数量较少，特征维度较大的情形，便于从较多特征中进行特征选择。例如 DNA 数据，特征维度很大，我们只希望通过 Lasso 回归找出与某些疾病有关的 DNA 片段。</p><p>本题中，将特征 X1 数值扩大 10 倍，他对应的回归系数将相应会减小，但不为 0，以此来保证仍然满足 β 的正则化约束。</p><p><strong>Q32. 关于特征选择，下列对 Ridge 回归和 Lasso 回归说法正确的是？</strong></p><p>A. Ridge 回归适用于特征选择</p><p>B. Lasso 回归适用于特征选择</p><p>C. 两个都适用于特征选择</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：上一题我们已经介绍过，Lasso 回归会让一部分回归系数刚好可以被约束为 0，起到特征选择的效果。</p><p>Ridge 回归又称岭回归，它是普通线性回归加上 L2 正则项，用来防止训练过程中出现的过拟合。L2 正则化效果类似上一题左图，限定区域是圆，这样，得到的回归系数为 0 的概率很小，很大概率是非零的。因此，比较来说，Lasso 回归更容易得到稀疏的回归系数，有利于舍弃冗余或无用特征，适用于特征选择。</p><p><strong>Q33. 如果在线性回归模型中增加一个特征变量，下列可能发生的是（多选）？</strong></p><p>A. R-squared 增大，Adjust R-squared 增大</p><p>B. R-squared 增大，Adjust R-squared 减小</p><p>C. R-squared 减小，Adjust R-squared 减小</p><p>D. R-squared 减小，Adjust R-squared 增大</p><p><strong>答案</strong>：AB</p><p><strong>解析</strong>：线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。其表达式如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1c12567aef4f9b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上式中，分子部分表示真实值与预测值的平方差之和，类似于均方差 MSE；分母部分表示真实值与均值的平方差之和，类似于方差 Var。一般来说，R-Squared 越大，表示模型拟合效果越好。R-Squared 反映的是大概有多准，因为，随着样本数量的增加，R-Squared 必然增加，无法真正定量说明准确程度，只能大概定量。</p><p>单独看 R-Squared，并不能推断出增加的特征是否有意义。通常来说，增加一个特征特征，R-Squared 可能变大也可能保持不变，两者不一定呈正相关。</p><p>如果使用校正决定系数（Adjusted R-Squared）：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-93556aa2d3107428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，n 是样本数量，p 是特征数量。Adjusted R-Squared 抵消样本数量对 R-Squared 的影响，做到了真正的 0~1，越大越好。</p><p>增加一个特征变量，如果这个特征有意义，Adjusted R-Square 就会增大，若这个特征是冗余特征，Adjusted R-Squared 就会减小。</p><p><strong>Q34. 下面三张图展示了对同一训练样本，使用不同的模型拟合的效果（蓝色曲线）。那么，我们可以得出哪些结论（多选）？</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-61e845f7b298f9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 第 1 个模型的训练误差大于第 2 个、第 3 个模型</p><p>B. 最好的模型是第 3 个，因为它的训练误差最小</p><p>C. 第 2 个模型最为“健壮”，因为它对未知样本的拟合效果最好</p><p>D. 第 3 个模型发生了过拟合</p><p>E. 所有模型的表现都一样，因为我们并没有看到测试数据</p><p><strong>答案</strong>：ACD</p><p><strong>解析</strong>：1、2、3 模型分别对应的多项式阶数由小到大，即模型由简单到复杂。模型越简单，容易发生欠拟合；模型越复杂，容易发生过拟合。第 1 个模型过于简单，出现欠拟合；第 3 个模型过于复杂，对训练样本拟合得很好，但在测试样本上效果会很差，即过拟合；第 2 个模型最为“健壮”，在训练样本和测试样本上拟合效果都不错！</p><p><strong>Q35. 下列哪些指标可以用来评估线性回归模型（多选）？</strong></p><p>A. R-Squared</p><p>B. Adjusted R-Squared</p><p>C. F Statistics</p><p>D. RMSE / MSE / MAE</p><p><strong>答案</strong>：ABCD</p><p><strong>解析</strong>：R-Squared 和 Adjusted R-Squared 的概念，我们在 Q3 有过介绍，它们都可以用来评估线性回归模型。F Statistics 是指在零假设成立的情况下，符合F分布的统计量，多用于计量统计学中。</p><p>RMSE 指的是均方根误差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3066338bd93bb507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>MSE 指的是均方误差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-ac45f3e8cfb10e2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>MAE 指的是评价绝对误差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-bc1ee5c524fbd792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上指标都可以用来评估线性回归模型。</p><p><strong>Q36. 线性回归中，我们可以使用正规方程（Normal Equation）来求解系数。下列关于正规方程说法正确的是？</strong></p><p>A. 不需要选择学习因子</p><p>B. 当特征数目很多的时候，运算速度会很慢</p><p>C. 不需要迭代训练</p><p><strong>答案</strong>：ABC</p><p><strong>解析</strong>：求解线性回归系数，我们一般最常用的方法是梯度下降，利用迭代优化的方式。除此之外，还有一种方法是使用正规方程，原理是基于最小二乘法。下面对正规方程做简要的推导。</p><p>已知线性回归模型的损失函数 Ein 为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fd966d40c0a2848c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对 Ein 计算导数，令 ∇Ein=0：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-d48a982d7ae724c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后就能计算出 W：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a5484827933b999f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上就是使用正规方程求解系数 W 的过程。可以看到，正规方程求解过程不需要学习因子，也没有迭代训练过程。当特征数目很多的时候，XTX 矩阵求逆会很慢，这时梯度下降算法更好一些。</p><p>如果 XTX 矩阵不可逆，是奇异矩阵怎么办呢？其实，大部分的计算逆矩阵的软件程序，都可以处理这个问题，也会计算出一个逆矩阵。所以，一般伪逆矩阵是可解的。</p><p><strong>Q37. 如果 Y 是 X（X1，X2，…，Xn）的线性函数：</strong></p><p><strong>Y = β0 + β1X1 + β2X2 + ··· + βnXn</strong></p><p><strong>则下列说法正确的是（多选）？</strong></p><p>A. 如果变量 Xi 改变一个微小变量 ΔXi，其它变量不变。那么 Y 会相应改变 βiΔXi。</p><p>B. βi 是固定的，不管 Xi 如何变化</p><p>C. Xi 对 Y 的影响是相互独立的，且 X 对 Y 的总的影响为各自分量 Xi 之和</p><p><strong>答案</strong>：ABC</p><p><strong>解析</strong>：这题非常简单，Y 与 X（X1，X2，…，Xn）是线性关系，故能得出 ABC 结论。</p><p><strong>Q38. 构建一个最简单的线性回归模型需要几个系数（只有一个特征）？</strong></p><p>A. 1 个</p><p>B. 2 个</p><p>C. 3 个</p><p>D. 4 个</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：最简单的线性回归模型，只有一个特征，即 Y = aX + b，包含 a 和 b 两个系数。</p><p><strong>Q39. 下面两张图展示了两个拟合回归线（A 和 B），原始数据是随机产生的。现在，我想要计算 A 和 B 各自的残差之和。注意：两种图中的坐标尺度一样。</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-9efa7b49191ac4ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>关于 A 和 B 各自的残差之和，下列说法正确的是？</strong></p><p>A. A 比 B 高</p><p>B. A 比 B 小</p><p>C. A 与 B 相同</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：A 和 B 中各自的残差之和应该是相同的。线性回归模型的损失函数为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1aaeddbdb1f9da6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对损失函数求导，并令 ∇J=0，即可得到 XW-Y=0，即残差之和始终为零。</p><p><strong>Q40. 如果两个变量相关，那么它们一定是线性关系吗？</strong></p><p>A. 是</p><p>B. 不是</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：相关不一定是线性关系，也有可能是非线性相关。</p><p><strong>Q41. 两个变量相关，它们的相关系数 r 可能为 0。这句话是否正确？</strong></p><p>A. 正确</p><p>B. 错误</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：一般来说，相关系数 r=0 是两变量相互独立的必要不充分条件。也就是说，如果两个变量相互独立，那么相关系数 r 一定为 0，如果相关系数 r=0，则不一定相互独立。相关系数 r=0 只能说明两个变量之间不存在线性关系，仍然可能存在非线性关系。</p><p>那么，若两个变量相关，存在非线性关系，那么它们的相关系数 r 就为 0。</p><p><strong>Q42. 加入使用逻辑回归对样本进行分类，得到训练样本的准确率和测试样本的准确率。现在，在数据中增加一个新的特征，其它特征保持不变。然后重新训练测试。则下列说法正确的是？</strong></p><p>A. 训练样本准确率一定会降低</p><p>B. 训练样本准确率一定增加或保持不变</p><p>C. 测试样本准确率一定会降低</p><p>D. 测试样本准确率一定增加或保持不变</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：在模型中增加更多特征一般会增加训练样本的准确率，减小 bias。但是测试样本准确率不一定增加，除非增加的特征是有效特征。</p><p>这题对应的知识点也包括了增加模型复杂度，虽然会减小训练样本误差，但是容易发生过拟合。</p><p><strong>Q43. 下面这张图是一个简单的线性回归模型,图中标注了每个样本点预测值与真实值的残差。计算 SSE 为多少？</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-4dd8f7be18e93aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 3.02</p><p>B. 0.75</p><p>C. 1.01</p><p>D. 0.604</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：SSE 是平方误差之和（Sum of Squared Error），SSE = (-0.2)^2 + (0.4)^2 + (-0.8)^2 + (1.3)^2 + (-0.7)^2 = 3.02</p><p><strong>Q44. 假设变量 Var1 和 Var2 是正相关的，那么下面那张图是正确的？图中，横坐标是 Var1，纵坐标是 Var2，且对 Var1 和 Var2 都做了标准化处理。</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-f6de97674698194d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. Plot 1</p><p>B. Plot 2</p><p><strong>答案</strong>：B</p><p>解析：显然，Plot 2 显示出 Var2 与 Var1 是正相关的，例如 Var2 = Var1。Plot 1 显示出 Var2 与 Var1 是负相关的，例如 Var2 = -Var1。</p><p><strong>Q45. 假设一个公司的薪资水平中位数是 $35,000，排名第 25% 和 75% 的薪资分别是 $21,000 和 $ 53,000。如果某人的薪水是 $1，那么它可以被看成是异常值（Outlier）吗？</strong></p><p>A. 可以</p><p>B. 不可以</p><p>C. 需要更多的信息才能判断</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：异常值（Outlier）指样本中的个别值，其数值明显偏离它（或他们）所属样本的其余观测值，也称异常数据，离群值。目前人们对异常值的判别与剔除主要采用物理判别法和统计判别法两种方法。</p><p>所谓物理判别法就是根据人们对客观事物已有的认识，判别由于外界干扰、人为误差等原因造成实测数据值偏离正常结果，在实验过程中随时判断，随时剔除。</p><p>统计判别法是给定一个置信概率，并确定一个置信限，凡超过此限的误差，就认为它不属于随机误差范围，将其视为异常值剔除。当物理识别不易判断时，一般采用统计识别法。</p><p>该题中，所给的信息量过少，无法肯定一定是异常值。</p><p><strong>Q46. 关于“回归（Regression）”和“相关（Correlation）”，下列说法正确的是？注意：x 是自变量，y 是因变量。</strong></p><p>A. 回归和相关在 x 和 y 之间都是互为对称的</p><p>B. 回归和相关在 x 和 y 之间都是非对称的</p><p>C. 回归在 x 和 y 之间是非对称的，相关在 x 和 y 之间是互为对称的</p><p>D. 回归在 x 和 y 之间是对称的，相关在 x 和 y 之间是非对称的</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：相关（Correlation）是计算两个变量的线性相关程度，是对称的。也就是说，x 与 y 的相关系数和 y 与 x 的相关系数是一样的，没有差别。</p><p>回归（Regression）一般是利用 特征 x 预测输出 y，是单向的、非对称的。</p><p><strong>Q47. 仅仅知道变量的均值（Mean）和中值（Median），能计算的到变量的偏斜度（Skewness）吗？</strong></p><p>A. 可以</p><p>B. 不可以</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：偏斜度是对统计数据分布偏斜方向及程度的度量。偏斜度是利用 3 阶矩定义的，其计算公式如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5755183c130bc9de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（十一）：二进制中1的个数</title>
      <link href="/2018/09/02/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2018/09/02/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现<strong>减1的结果是把最右边的一个1开始的所有位都取反了</strong>。这个时候如果我们再把原来的整数和减去1之后的结果做<strong>与运算</strong>，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count = 0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             ++count;</span><br><span class="line">             n = (n - 1) &amp; n;</span><br><span class="line">         &#125;</span><br><span class="line">         return count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在Python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机是以补码存在的，往右移，符号位不变，符号位1往右移，最终可能会出现全1的情况，导致死循环。与0xffffffff相与，就可以消除负数的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        count = 0</span><br><span class="line">        if n&lt;0:</span><br><span class="line">            n = n &amp; 0xffffffff</span><br><span class="line">        while n:</span><br><span class="line">            count += 1</span><br><span class="line">            n = n &amp; (n-1)</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure></p><p>或者可以使用一个更直观的方法，直接位移即可，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        return sum([(n &gt;&gt; i &amp; 1) for i in range(0,32)])</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（十）：矩形覆盖</title>
      <link href="/2018/09/02/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
      <url>/2018/09/02/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>以2x8的矩形为例。示意图如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-186ab26d39d6ccaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角也横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是<strong>斐波那契数列</strong>。</p><p>注：这里用循环就好，用递归的话，时间复杂度比较高。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">if(number &lt;= 2)&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 1, second = 2, third = 0;</span><br><span class="line">        for(int i = 3; i &lt;= number; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        return third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def rectCover(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;= 2:</span><br><span class="line">            return number</span><br><span class="line">        first, second, third = 1, 2, 0</span><br><span class="line">        for i in range(3, number+1):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        return third</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（九）：变态跳台阶</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我想说，这青蛙真变态，真能跳。</p><ul><li>当n=1时，结果为1；</li><li>当n=2时，结果为2；</li><li>当n=3时，结果为4；</li></ul><p>以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">if(number == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int total = 1;</span><br><span class="line">        for(int i = 1; i &lt; number; i++)&#123;</span><br><span class="line">            total *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def jumpFloorII(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;= 2:</span><br><span class="line">            return number</span><br><span class="line">        total = 1</span><br><span class="line">        for _ in range(1, number):</span><br><span class="line">            total *= 2</span><br><span class="line">        return total</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（八）：跳台阶</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。</p><p>接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数<strong>f(n)=f(n-1)+f(n-2)</strong>。分析到这里，我们不难看出这实际上就是<strong>斐波那契数列</strong>了。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number &lt;= 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(number &lt; 3)&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 1, second = 2, third = 0;</span><br><span class="line">        for(int i = 3; i &lt;= number; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        return third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt; 3:</span><br><span class="line">            return number</span><br><span class="line">        first, second, third = 1, 2, 0</span><br><span class="line">        for i in range(3, number+1):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        return third</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（七）：裴波那契数列</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A3%B4%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A3%B4%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）</p><a id="more"></a><p>斐波那契数列公式为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8953edbbc9043289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题递归很好写，但是存在<strong>很严重的效率问题。</strong>我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8a743d1342848c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们不难发现在这棵树中有<strong>很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大</strong>。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。</p><p>所以，使用简单的循环方法来实现。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>Ｃ++:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        first, second, third = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        <span class="keyword">return</span> third</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（六）：旋转数组的最小数字</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为<strong>数组的旋转</strong>。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾</strong>，我们称之为<strong>数组的旋转</strong>。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我们注意到旋转之后的数组实际上可以划分为<strong>两个排序的子数组</strong>，而且前面的子数组的元素大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。在排序的数组中可以用二分查找实现O(logn)的查找。本题给出的数组在一定程度上是排序的，因此我们可以试着用二分查找法的思路来寻找这个最小的元素。</p><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</li><li>接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。</li><li>同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。</li><li>第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。</li></ul><p>示意图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-704dff113e4514da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>特殊情况：</p><ul><li><p>如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。</p></li><li><p>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-2dc939898031e973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int size = rotateArray.size();//数组长度</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;//左指针</span><br><span class="line">        int right = size - 1;//右指针</span><br><span class="line">        int mid = 0;//中间指针</span><br><span class="line">        while(rotateArray[left] &gt;= rotateArray[right])&#123;//确保旋转</span><br><span class="line">            if(right - left == 1)&#123;//左右指针相邻</span><br><span class="line">                mid = right;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / 2;//计算中间指针位置</span><br><span class="line">            //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找</span><br><span class="line">            if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123;</span><br><span class="line">                return MinInOrder(rotateArray, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面</span><br><span class="line">            if(rotateArray[mid] &gt;= rotateArray[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span><br><span class="line">            else&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //顺序寻找最小值</span><br><span class="line">    int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123;</span><br><span class="line">        int result = num[left];</span><br><span class="line">        for(int i = left + 1; i &lt; right; i++)&#123;</span><br><span class="line">            if(num[i] &lt; result)&#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(rotateArray) == 0:</span><br><span class="line">            return 0</span><br><span class="line">        left = 0</span><br><span class="line">        right = len(rotateArray) - 1</span><br><span class="line">        mid = 0</span><br><span class="line">        while rotateArray[left] &gt;= rotateArray[right]:</span><br><span class="line">            if right - left == 1:</span><br><span class="line">                mid = right</span><br><span class="line">                break</span><br><span class="line">            mid = left + (right - left) // 2</span><br><span class="line">            if rotateArray[left] == rotateArray[mid] and rotateArray[mid] == rotateArray[right]:</span><br><span class="line">                return self.minInorder(rotateArray, left, right)</span><br><span class="line">            if rotateArray[mid] &gt;= rotateArray[left]:</span><br><span class="line">                left = mid</span><br><span class="line">            else:</span><br><span class="line">                right = mid</span><br><span class="line">        return rotateArray[mid]</span><br><span class="line">    </span><br><span class="line">    def minInorder(self, array, left, right):</span><br><span class="line">        result = array[left]</span><br><span class="line">        for i in range(left+1, right+1):</span><br><span class="line">            if array[i] &lt; result:</span><br><span class="line">                result = array[i]</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（五）：用两个栈实现队列</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>用<strong>两个栈来实现一个队列，完成队列的Push和Pop操作</strong>。 队列中的元素为int类型。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>创建两个栈stack1和stack2，<strong>使用两个“先进后出”的栈实现一个“先进先出”的队列</strong>。</p><p>我们通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。</p><p>这个时候我们试着从队列中删除一个元素。按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。注意stack2我们一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。</p><p>因此我们的思路是：<strong>当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压倒stack1的栈底，经过弹出和压入之后就处于stack2的栈顶，有可以直接弹出。如果有新元素d插入，我们直接把它压入stack1即可。</strong></p><p>流程示意图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-2e93b8b8d543dcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(stack1.size() &gt; 0)&#123;</span><br><span class="line">                int data = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int pop_element = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return pop_element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong></p><p>对于python来讲，栈就是用list实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    def push(self, node):</span><br><span class="line">        # write code here</span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    def pop(self):</span><br><span class="line">        # return xx</span><br><span class="line">        if len(self.stack2) == 0:</span><br><span class="line">            while self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        return self.stack2.pop()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（四）：重建二叉树</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>输入某二叉树的<strong>前序遍历</strong>和<strong>中序遍历</strong>的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><a id="more"></a><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a95a5f2e70bca737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>通常树有如下几种遍历方式：</p><ul><li>前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。<strong>根左右</strong></li><li>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。<strong>左根右</strong></li><li>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。<strong>左右根</strong></li></ul><p>本题为前序遍历和中序遍历，<strong>最少需要两种遍历方式，才能重建二叉树。</strong></p><p>前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以<strong>递归</strong>来实现，具体如图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e417b447c5ba0b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">if(pre.size() == 0)&#123;//如果为空，返回NULL</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次是前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树</span><br><span class="line">        vector&lt;int&gt; left_pre, right_pre, left_vin, right_vin;</span><br><span class="line">        //中序遍历第一个节点一定为根节点</span><br><span class="line">        TreeNode* head = new TreeNode(pre[0]);</span><br><span class="line">        //找到中序遍历的根节点</span><br><span class="line">        int root = 0;</span><br><span class="line">        //遍历找到中序遍历根节点索引值</span><br><span class="line">        for(int i = 0; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            if(pre[0] == vin[i])&#123;</span><br><span class="line">                root = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       //利用中序遍历的根节点，对二叉树节点进行归并</span><br><span class="line">        for(int i = 0; i &lt; root; i++)&#123;</span><br><span class="line">            left_vin.push_back(vin[i]);</span><br><span class="line">            left_pre.push_back(pre[i + 1]);//前序遍历第一个为根节点</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = root + 1; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            right_vin.push_back(vin[i]);</span><br><span class="line">            right_pre.push_back(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br><span class="line">        head-&gt;left = reConstructBinaryTree(left_pre, left_vin);</span><br><span class="line">        head-&gt;right = reConstructBinaryTree(right_pre, right_vin);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(pre) == 0:</span><br><span class="line">            return None</span><br><span class="line">        elif len(pre) == 1:</span><br><span class="line">            return TreeNode(pre[0])</span><br><span class="line">        else:</span><br><span class="line">            root = TreeNode(pre[0])</span><br><span class="line">            pos = tin.index(pre[0])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（三）：从尾到头打印链表</title>
      <link href="/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>摘要</p><p>输入一个链表，返回一个反序的链表。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个链表，返回一个反序的链表。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>通常，这种情况下，我们<strong>不希望修改原链表的结构</strong>。返回一个反序的链表，这就是经典的<strong>“后进先出”</strong>，我们可以使用<strong>栈</strong>实现这种顺序。<strong>每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，给一个新的链表结构，这样链表就实现了反转。</strong></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong></p><p>对于python来讲，不用如此麻烦，我们可以直接使用<strong>列表</strong>的插入方法，<strong>每次插入数据，只插入在首位</strong>s。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            result.insert(<span class="number">0</span>, listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>topK问题</title>
      <link href="/2018/09/01/topK%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/01/topK%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>问题描述：有 N (N&gt;1000000)个数,求出其中的前K个最小的数（又被称作topK问题）。</p><p>针对topK类问题，通常比较好的方案是<strong>【分治+trie树/hash+小顶堆】</strong>，即先将数据集按照hash算法分解成多个小数据集，然后使用<strong>trie</strong>树或者hash表统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。<br><a id="more"></a></p><p>实际上，最优的解决方案应该是最符合实际设计需求的方案，在实际应用中，可能有足够大的内存，那么直接将数据扔到内存中一次性处理即可，也可能机器有多个核，这样可以采用多线程处理整个数据集。</p><p>第一种方法将数据<strong>全部排序</strong> ，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为<strong>O（nlogn）</strong>，如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</p><p>第二种方法为<strong>局部淘汰法</strong>，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。</p><p> 第三种方法是<strong>分治法</strong>，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100<em>10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6</em>4=4MB，一共需要101次这样的比较。</p><p>第四种方法是<strong>Hash法</strong>。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。</p><p>第五种方法采用<strong>最小堆</strong>。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。</p><p>还有没有更简单的算法呢？答案是肯定的。 </p><p>第六种方法<strong>利用快速排序的分划函数找到分划位置K，则其前面的内容即为所求。</strong>该算法是一种非常有效的处理方式，时间复杂度是<strong>O(N)</strong>（证明可以参考算法导论书籍）。对于能一次加载到内存中的数组，该策略非常优秀。如果能完整写出代码，那么相信面试官会对你刮目相看的。</p><p>下面，给出第六种方法的Python代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(L, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将L[left:right]进行一次快速排序的partition，返回分割点</span></span><br><span class="line"><span class="string">   :param L: 数据List</span></span><br><span class="line"><span class="string">    :param left: 排序起始位置</span></span><br><span class="line"><span class="string">   :param right: 排序终止位置</span></span><br><span class="line"><span class="string">   :return: 分割点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        <span class="keyword">print</span> left</span><br><span class="line">        key = L[left]</span><br><span class="line">        low = left</span><br><span class="line">        high = right</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> L[high] &gt;= key:</span><br><span class="line">                high = high - <span class="number">1</span></span><br><span class="line">            L[low] = L[high]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> L[low] &lt;= key:</span><br><span class="line">                low = low + <span class="number">1</span></span><br><span class="line">            L[high] = L[low]</span><br><span class="line">        L[low] = key</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topK</span><span class="params">(L, K)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求L中的前K个最小值</span></span><br><span class="line"><span class="string">   :param L: 数据List</span></span><br><span class="line"><span class="string">    :param K: 最小值的数目</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(L) &lt; K:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(L) - <span class="number">1</span></span><br><span class="line">    j = partition(L, low, high)</span><br><span class="line">    <span class="keyword">while</span> j != K: <span class="comment"># 划分位置不是K则继续处理</span></span><br><span class="line">      <span class="keyword">if</span> K &gt; j: <span class="comment">#k在分划点后面部分</span></span><br><span class="line">         low = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = j  <span class="comment"># K在分划点前面部分</span></span><br><span class="line">      j = partition(L, low, high)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 海量数据 </tag>
            
            <tag> topK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>判别式模型和生成式模型</title>
      <link href="/2018/08/26/%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/26/%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="判别式模型-与-生成式模型"><a href="#判别式模型-与-生成式模型" class="headerlink" title="判别式模型 与 生成式模型"></a>判别式模型 与 生成式模型</h1><p>生成式模型(Generative Model)与判别式模型(Discrimitive Model)是分类器常遇到的概念，它们的区别在于：</p><p>对于输入x，类别标签y：</p><ul><li><strong>判别式模型</strong>估计<strong>条件概率分布$P(y|x)$</strong>（y在x下的概率 ），直接对条件概率$p(y|x;θ)$建模 。</li></ul><p><strong>举例：要确定一个羊是山羊还是绵羊，用判别模型的方法是从历史数据中学习到模型，然后通过提取这只羊的特征来预测出这只羊是山羊的概率，是绵羊的概率。</strong></p><ul><li><strong>生成式模型</strong>估计它们的<strong>联合概率分布$P(x,y)$</strong>。会对x和y的联合分布$p(x,y)$建模，然后通过贝叶斯公式来求得$p(y_{i}|x)$，然后选取使得$p(y_{i}|x)$最大的$y_{i}$，即： </li></ul><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe1eb0dcb7a6c930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>举例：利用生成模型是根据山羊的特征首先学习出一个山羊的模型，然后根据绵羊的特征学习出一个绵羊的模型，然后从这只羊中提取特征，放到山羊模型中看概率是多少，在放到绵羊模型中看概率是多少，哪个大就是哪个。</strong> </p><p><strong>生成式模型可以根据贝叶斯公式得到判别式模型，但反过来不行</strong>。</p><h2 id="判别式模型常见的主要有："><a href="#判别式模型常见的主要有：" class="headerlink" title="判别式模型常见的主要有："></a><strong>判别式模型常见的主要有：</strong></h2><ul><li>线性回归(Linear Regression)</li><li>逻辑回归(Logistic Regression)</li><li>决策树</li><li>神经网络(NN)</li><li>支持向量机(SVM)</li><li>高斯过程(Gaussian Process)</li><li>条件随机场(CRF)</li><li>CART(Classification and Regression Tree)</li><li>Boosting</li><li>最大熵模型</li></ul><h2 id="生成式模型常见的主要有："><a href="#生成式模型常见的主要有：" class="headerlink" title="生成式模型常见的主要有："></a><strong>生成式模型常见的主要有：</strong></h2><ul><li>朴素贝叶斯</li><li>K近邻(KNN)</li><li>混合高斯模型</li><li>隐马尔科夫模型(HMM)</li><li>贝叶斯网络</li><li>Sigmoid Belief Networks</li><li>马尔科夫随机场(Markov Random Fields)</li><li>深度信念网络(DBN)</li><li>LDA</li><li>pLSA</li></ul><pre><code>假设你现在有一个分类问题，x是特征，y是类标记。用生成模型学习一个联合概率分布$P（x，y）$，而用判别模型学习一个条件概率分布$P（y|x）$。用一个简单的例子来说明这个这个问题。假设x就是两个（1或2），y有两类（0或1），有如下如下样本（1，0）、（1，0）、（2，0）、（2，1）</code></pre><p>则学习到的<strong>联合概率分布$P（x，y）$</strong>（生成模型）如下：</p><table><thead><tr><th></th><th>y=0</th><th>y=1</th></tr></thead><tbody><tr><td>x=1</td><td>1/2</td><td>0</td></tr><tr><td>x=2</td><td>1/4</td><td>1/4</td></tr></tbody></table><p>而学习到的<strong>条件概率分布</strong>$P（y|x）$（判别模型）如下： </p><table><thead><tr><th></th><th>y=0</th><th>y=1</th></tr></thead><tbody><tr><td>x=1</td><td>1</td><td>0</td></tr><tr><td>x=2</td><td>1/2</td><td>1/2</td></tr></tbody></table><pre><code>在实际分类问题中，**判别模型可以直接用来判断特征的类别情况**，而**生成模型，需要加上贝叶斯法则**，然后应用到分类中。但是，生成模型的概率分布可以还有其他应用，就是说生成模型更一般更普适。不过判别模型更直接，更简单。 </code></pre><h1 id="两个模型的对比"><a href="#两个模型的对比" class="headerlink" title="两个模型的对比"></a>两个模型的对比</h1><p><img src="https://upload-images.jianshu.io/upload_images/12654931-8a5d642f888471b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 判别式模型 </tag>
            
            <tag> 生成式模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（二）：替换空格</title>
      <link href="/2018/08/25/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2018/08/25/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      <content type="html"><![CDATA[<h1 id="剑指Offer-二-：替换空格"><a href="#剑指Offer-二-：替换空格" class="headerlink" title="剑指Offer(二)：替换空格"></a>剑指Offer(二)：替换空格</h1><p>摘要</p><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：[牛客网]</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>请实现一个函数，将一个[字符串]中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>最简单的方法就是从头到尾遍历，但是时间复杂度为O(n^2)。</p><p>本文采用一种时间复杂度为O(n)的方法。</p><p>我们可以先遍历一次字符串，这样就可以统计出字符串空格的总数，并可以由此计算出替换之后的字符串的总长度。<strong>每替换一个空格，长度增加2</strong>，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。</p><p>我们从字符串的尾部开始复制和替换。首先准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串”%20”。由于”%20”的长度为3，同时也要把P2向前移动3格。</p><p>移动示意图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8645629703febdaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、编程实现"><a href="#2、编程实现" class="headerlink" title="2、编程实现"></a>2、编程实现</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*original_length为字符串str的实际长度*/</span></span><br><span class="line">        <span class="keyword">int</span> original_length = <span class="number">0</span>;<span class="comment">//原始长度</span></span><br><span class="line">        <span class="keyword">int</span> number_blank = <span class="number">0</span>;<span class="comment">//空格数</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span>(str[i++] != <span class="string">'\0'</span>)&#123;<span class="comment">//遍历字符串</span></span><br><span class="line">            ++original_length;<span class="comment">//长度+1</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                ++number_blank;<span class="comment">//遇到空格+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*new_length为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> new_length = original_length + <span class="number">2</span> * number_blank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index_original = original_length;<span class="comment">//原始字符串末尾索引值</span></span><br><span class="line">        <span class="keyword">int</span> index_new = new_length;<span class="comment">//计算长度后的字符串末尾索引值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*index_original指针开始向前移动，如果遇到空格，替换成'%20'，否则进行复制操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(index_original &gt;= <span class="number">0</span> &amp;&amp; index_new &gt; index_original)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[index_original] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[index_new--] = <span class="string">'0'</span>;</span><br><span class="line">                str[index_new--] = <span class="string">'2'</span>;</span><br><span class="line">                str[index_new--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[index_new--] = str[index_original];</span><br><span class="line">            &#125;</span><br><span class="line">            --index_original;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么梯度的负方向是梯度下降最快的方向</title>
      <link href="/2018/08/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A2%AF%E5%BA%A6%E7%9A%84%E8%B4%9F%E6%96%B9%E5%90%91%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%B9%E5%90%91/"/>
      <url>/2018/08/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A2%AF%E5%BA%A6%E7%9A%84%E8%B4%9F%E6%96%B9%E5%90%91%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%B9%E5%90%91/</url>
      <content type="html"><![CDATA[<h2 id="什么是梯度？"><a href="#什么是梯度？" class="headerlink" title="什么是梯度？"></a>什么是梯度？</h2><p>​    对于梯度下降算法（Gradient Descent Algorithm），我们都已经很熟悉了。无论是在线性回归（Linear Regression）、逻辑回归（Logistic Regression）还是神经网络（Neural Network）等等，都会用到梯度下降算法。我们先来看一下梯度下降算法的直观解释：</p><p>​    假设我们位于山的某个山腰处，山势连绵不绝，不知道怎么下山。于是决定走一步算一步，也就是每次沿着当前位置最陡峭最易下山的方向前进一小步，然后继续沿下一个位置最陡方向前进一小步。这样一步一步走下去，一直走到觉得我们已经到了山脚。这里的<strong>下山最陡的方向就是梯度的负方向</strong>。    </p><p>​    首先理解什么是<strong>梯度</strong>？通俗来说，<strong>梯度就是表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在当前位置的导数</strong>。</p><p>$∇=\frac{df(\theta)}{d\theta}$</p><a id="more"></a><p>上式中，$\theta$是自变量，$f(\theta)$是关于$\theta$的函数，$\theta$表示梯度。</p><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>​    如果函数$f(\theta)$是凸函数，那么就可以使用梯度下降算法进行优化。梯度下降算法的公式我们已经很熟悉了：</p><p>$\theta=\theta_{0}−η⋅∇f(\theta_{0})$</p><p>​    其中，$\theta_{0}$是自变量参数，即下山位置坐标，$η$是学习因子，即下山每次前进的一小步（步进长度），$\theta$是更新后的$\theta_{0}$，即下山移动一小步之后的位置。</p><p>​    梯度下降算法的公式非常简单！但是”沿着梯度的反方向（坡度最陡）“是我们日常经验得到的，其本质的原因到底是什么呢？为什么局部下降最快的方向就是梯度的负方向呢？也许很多朋友还不太清楚。没关系，接下来我将以通俗的语言来详细解释梯度下降算法公式的数学推导过程。</p><h2 id="一阶泰勒展开式"><a href="#一阶泰勒展开式" class="headerlink" title="一阶泰勒展开式"></a>一阶泰勒展开式</h2><p>​    这里需要一点数学基础，对泰勒展开式有些了解。简单地来说，泰勒展开式利用的就是函数的局部线性近似这个概念。我们以一阶泰勒展开式为例：</p><p>$f(\theta)\approx f(\theta_{0})+(\theta-\theta_{0})\cdot\bigtriangledown f(\theta_{0})$</p><p>不懂上面的公式？没有关系。用下面这张图来解释。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-d3059cfb700bba95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>凸函数$f(\theta)​$的某一小段$[\theta_{0},\theta]​$由上图黑色曲线表示，可以利用线性近似的思想求出$f(\theta)​$的值，如上图红色直线。该直线的斜率等于$f(\theta)​$在$\theta_{0}​$处的导数。则根据直线方程，很容易得到$f(\theta)​$的近似表达式为：</p><p>$f(\theta)\approx f(\theta_{0})+(\theta-\theta_{0})\cdot\bigtriangledown f(\theta_{0})$</p><p>这就是一阶泰勒展开式的推导过程，主要利用的数学思想就是曲线函数的线性拟合近似。</p><h2 id="梯度下降数学原理"><a href="#梯度下降数学原理" class="headerlink" title="梯度下降数学原理"></a>梯度下降数学原理</h2><p>知道了一阶泰勒展开式之后，接下来就是重点了！我们来看一下梯度下降算法是如何推导的。</p><p>先写出一阶泰勒展开式的表达式：</p><p>$f(\theta)≈f(\theta_{0})+(\theta−\theta_{0})⋅∇f(\theta_{0})$</p><p>其中，$\theta−\theta_{0}$是微小矢量，它的大小就是我们之前讲的步进长度η，类比于下山过程中每次前进的一小步，η为标量，而$\theta−\theta_{0}$的单位向量用$v$表示。则$\theta−\theta_{0}$可表示为：</p><p>$\theta−\theta_{0}=ηv$</p><p>特别需要注意的是，$\theta−\theta_{0}$不能太大，因为太大的话，线性近似就不够准确，一阶泰勒近似也不成立了。替换之后，$f(\theta)$的表达式为：</p><p>$f(\theta)≈f(\theta_{0})+ηv⋅∇f(\theta_{0})$</p><p>重点来了，局部下降的目的是希望每次$\theta$更新，都能让函数值$f(\theta)$变小。也就是说，上式中，我们希望$f(\theta)&lt;f(\theta_{0})$。则有：</p><p>$f(\theta)−f(\theta_{0})≈ηv⋅∇f(\theta_{0})&lt;0$</p><p>因为$η$为标量，且一般设定为正值，所以可以忽略，不等式变成了：</p><p>$v⋅∇f(\theta_{0})&lt;0$</p><p>上面这个不等式非常重要！$v$和$∇f(\theta_{0})$都是向量，$∇f(\theta_{0})$是当前位置的梯度方向，$v$表示下一步前进的单位向量，是需要我们求解的，有了它，就能根据$\theta−\theta_{0}=ηv$确定$\theta$值了。</p><p>想要两个向量的乘积小于零，我们先来看一下两个向量乘积包含哪几种情况：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f7f779a9600abcb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A和B均为向量，$α$为两个向量之间的夹角。A和B的乘积为：</p><p>$A⋅B=||A||⋅||B||⋅cos(α)$</p><p>$||A||$和$||B||$均为标量，在$||A||$和$||B||$确定的情况下，只要$cos(α)=−1$，即A和B完全反向，就能让A和B的向量乘积最小（负最大值）。</p><p>顾名思义，当$v$与$∇f(\theta_{0})$互为反向，即$v$为当前梯度方向的负方向的时候，能让$v⋅∇f(\theta_{0})$最大程度地小，也就保证了$v$的方向是局部下降最快的方向。</p><p>知道$v$是$∇f(\theta_{0})$的反方向后，可直接得到：</p><p>$v=−\frac{∇f(\theta_{0})}{||∇f(\theta_{0})||}$</p><p>之所以要除以$∇f(\theta_{0})$的模$||∇f(\theta_{0})||$，是因为$v$是单位向量。</p><p>求出最优解$v$之后，带入到$\theta−\theta_{0}=ηv$中，得：</p><p>$v=\theta_{0}−η\frac{∇f(\theta_{0})}{||∇f(\theta_{0})||}$</p><p>一般地，因为$||∇f(\theta_{0})||$是标量，可以并入到步进因子$η$中，即简化为：</p><p>$\theta=\theta_{0}−η∇f(\theta_{0})$</p><p>这样，我们就推导得到了梯度下降算法中$\theta$的更新表达式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一阶泰勒展开式，利用线性近似和向量相乘最小化的思想搞懂了梯度下降算法的数学原理。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>协方差与相关系数</title>
      <link href="/2018/08/25/%E5%8D%8F%E6%96%B9%E5%B7%AE%E4%B8%8E%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
      <url>/2018/08/25/%E5%8D%8F%E6%96%B9%E5%B7%AE%E4%B8%8E%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>什么是协方差（Covariance）？</p><blockquote><p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。</p></blockquote><p>以上是某百科的解释。</p><p><strong>1、协方差是怎么来的？</strong></p><a id="more"></a><p>​    简单地来说，<strong>协方差</strong>就是反映两个变量 X 和 Y 的相互关系。这种相互关系大致分为三种：<strong>正相关</strong>、<strong>负相关</strong>、<strong>不相关</strong>。</p><p>​    什么是正相关呢？例如房屋面积（X）越大，房屋总价（Y）越高，则房屋面积与房屋总价是正相关的；</p><p>​    什么是负相关呢？例如一个学生打游戏的时间（X）越多，学习成绩（Y）越差，则打游戏时间与学习成绩是负相关的；</p><p>​    什么是不相关呢？例如一个人皮肤的黑白程度（X）与他的身体健康程度（Y）并无明显关系，所以是不相关的。</p><p>我们先来看第一种情况，令变量 X 和变量 Y 分别为：</p><p>X = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y = [12 15 17 21 22 21 18 23 26 25 22 28 24 28 30 33 28 34 36 35]</p><p>在坐标上描绘出 X 和 Y 的联合分布：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c7b704496e93a645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，Y 在整体趋势上是随着 X 的增加而增加的，即 Y 与 X 的变化是同向的。这种情况，我们就称 X 与 Y 是<strong>正相关</strong>的。</p><p>我们再来看第二种情况，令变量 X 和变量 Y 分别为：</p><p>X = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y = [35 35 29 29 28 28 27 26 26 23 21 22 25 19 16 19 20 16 15 16]</p><p>在坐标上描绘出 X 和 Y 的联合分布：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-449b98898b06e5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，Y 在整体趋势上是随着 X 的增加而减少的，即 Y 与 X 的变化是反向的。这种情况，我们就称 X 与 Y 是<strong>负相关</strong>的。</p><p>我们再来看第三种情况，令变量 X 和变量 Y 分别为：</p><p>X = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y = [16 16 28 17 20 26 20 17 21 15 12 29 24 25 16 15 21 13 17 25]</p><p>在坐标上描绘出 X 和 Y 的联合分布：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-783fd5ff0bdbf5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，Y 在整体趋势上与 X 的并无正相关或者负相关的关系。这种情况，我们就称 X 与 Y 是<strong>不相关</strong>的。</p><p>回过头来，我们来看 X 与 Y 正相关的情况，令 EX、EY 分别是 X 和 Y 的<strong>期望</strong>值。什么是期望呢？在这里我们可以把它看成是<strong>平均值</strong>，即 EX 是变量 X 的平均值，EY 是变量 Y 的平均值。把 EX 和 EY 在图中表示出来得到下面的图形：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5af683128993d898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中，整个区域被 EX 和 EY 分割成 I、II、III、IV 四个区域，且 X 和 Y 大部分分布在 I、III 区域内，只有少部分分布在 II、IV 区域内。</p><p>在区域 I 中，满足 X&gt;EX，Y&gt;EY，则有 (X-EX)(Y-EY)&gt;0；</p><p>在区域 II 中，满足 X&lt;EX，Y&gt;EY，则有 (X-EX)(Y-EY)&lt;0；</p><p>在区域 III 中，满足 X&lt;EX，Y&lt;EY，则有 (X-EX)(Y-EY)&gt;0；</p><p>在区域 IV 中，满足 X&gt;EX，Y&lt;EY，则有 (X-EX)(Y-EY)&lt;0。</p><p>显然，在区域 I、III 中，(X-EX)(Y-EY)&gt;0；在区域 II、IV 中，(X-EX)(Y-EY)&lt;0。而 X 和 Y 正相关时，数据大部分是分布在 I、III 区域内，只有少部分分布在 II、IV 区域。因此，从平均角度来看，正相关满足：</p><p>$E(X-EX)(Y-EY)&gt;0$</p><p>上式表示的是 (X-EX)(Y-EY) 的期望大于零，即 (X-EX)(Y-EY) 的平均值大于零。</p><p>然后，再来看 X 和 Y 负相关的情况：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-85f9087cf9fbcd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中，X 和 Y 大部分分布在 II、IV 区域内，只有少部分分布在 I、III 区域内。</p><p>同样，在区域 I、III 中，(X-EX)(Y-EY)&gt;0；在区域 II、IV 中，(X-EX)(Y-EY)&lt;0。而 X 和 Y 负相关时，数据大部分是分布在 II、IV 区域内，只有少部分分布在 I、III 区域。因此，从平均角度来看，负相关满足：</p><p>$E(X-EX)(Y-EY)&lt;0$</p><p>上式表示的是 (X-EX)(Y-EY) 的期望小于零，即 (X-EX)(Y-EY) 的平均值小于零。</p><p>最后，再来看 X 和 Y 不相关的情况：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-783fd5ff0bdbf5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中，X 和 Y 在 I、II、III、IV 区域内近似均匀分布。</p><p>同样，在区域 I、III 中，(X-EX)(Y-EY)&gt;0；在区域 II、IV 中，(X-EX)(Y-EY)&lt;0。而 X 和 Y 不相关时，数据在各区域内均匀分布，从平均角度来看，不相关满足：</p><p>$E(X-EX)(Y-EY)=0$</p><p>上式表示的是 (X-EX)(Y-EY) 的期望等于零，即 (X-EX)(Y-EY) 的平均值等于零。</p><p>综上所述，我们得到以下结论：</p><ul><li>当 X 和 Y 正相关时：$E(X-EX)(Y-EY)&gt;0$</li><li>当 X 和 Y 负相关时： $E(X-EX)(Y-EY)&lt;0$</li><li>当 X 和 Y 不相关时： $E(X-EX)(Y-EY)=0$</li></ul><p>因此，我们就引出了<strong>协方差</strong>的概念，它是表示 X 和 Y 之间相互关系的数字特征。我们定义协方差为： </p><p>$Cov(X,Y)=E(X-EX)(Y-EY)$</p><p>根据之前讨论的结果，</p><ul><li><strong>当 Cov(X,Y) &gt; 0 时，X 与 Y 正相关；</strong></li><li><strong>当 Cov(X,Y) &lt; 0 时，X 与 Y 负相关；</strong></li><li><strong>当 Cov(X,Y) = 0 时，X 与 Y 不相关。</strong></li></ul><p>值得一提的是，<strong>E</strong> 代表求期望值。也可以用平均值来计算协方差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e5737a0988684364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里，<strong>之所以除以 N-1 而不是 N 的原因是对总体样本期望的无偏估计</strong>(抽取的部分样本不能代表整体的情况，抽样越多越接近真实情况  ，在多次重复下，它们的平均数接近所估计的参数真值。 )。顺便提一下，如果令 Y = X，则协方差表示的正是 X 的方差。</p><p>下面，我们根据协方差的公式，分别计算上面三种情况下 X 与 Y 的协方差。</p><p>X 与 Y 正相关时，Cov(X,Y) = 37.3684；</p><p>X 与 Y 负相关时，Cov(X,Y) = -34.0789；</p><p>X 与 Y 不相关时，Cov(X,Y) = -1.0263。</p><p><strong>2、相关系数与协方差有什么关系？</strong></p><p>我们已经知道了什么是协方差以及协方差公式是怎么来的，如果知道两个变量 X 与 Y 的协方差与零的关系，我们就能推断出 X 与 Y 是正相关、负相关还是不相关。那么有一个问题：协方差数值大小是否代表了相关程度呢？也就是说如果协方差为 100 是否一定比协方差为 10 的正相关性强呢？</p><p>请看下面这个例子！</p><p>变量 X1 与 Y1 分别为：</p><p>X1 = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y1 = [12 12 13 15 16 16 17 19 21 22 22 23 23 26 25 28 29 29 31 32]</p><p>变量 X2 和 Y2 分别为：</p><p>X2 = [110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300]</p><p>Y2 = [113 172 202 206 180 184 242 180 256 209 288 255 240 278 319 322 345 289 333 372]</p><p>X1、Y1 和 X2、Y2 分别联合分布图，如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-20451d31c197597e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，从图中可以看出，X1、Y1 和 X2、Y2 都呈正相关，而且 X1 与 Y1 正相关的程度明显比 X2 与 Y2 更大一些。接下来，我们计算两幅图的协方差看看是不是这样。</p><p>Cov(X1,Y1) = 37.5526</p><p>Cov(X2,Y2) = 3730.26</p><p>意外！X2 与 Y2 的协方差竟然比 X1 与 Y1 的协方差还大 100 倍。看来并不是协方差越大，正相关程度越高。这到底是为什么呢？</p><p>其实，出现这种情况的原因是<strong>两种情况数值变化的幅值不同（或者量纲不同）</strong>。计算协方差的时候我们并没有把不同变量幅值差异性考虑进来，在比较协方差的时候也就<strong>没有一个统一的量纲标准</strong>。</p><p>所以，为了消除这一影响，为了准确得到变量之间的相似程度，我们需要把协方差除以各自变量的标准差。这样就得到了<strong>相关系数</strong>的表达式：</p><p> $\rho=\frac{Cov(X,Y)}{\sigma X\sigma Y}$</p><p>可见，相关系数就是在协方差的基础上除以变量 X 和 Y 的标准差。其中标准差的计算公式为： </p><p>$\sigma X = \sqrt{\frac{1}{N-1}\sum^{N}<em>{i=1}(X</em>{i}-\overline{X_{i}})}$</p><p>$\sigma Y = \sqrt{\frac{1}{N-1}\sum^{N}<em>{i=1}(Y</em>{i}-\overline{Y_{i}})}$</p><p>​    为什么除以各自变量的标准差就能消除幅值影响呢？这是因为<strong>标准差本身反映了变量的幅值变化程度</strong>，<strong>除以标准差正好能起到抵消的作用，让协方差标准化</strong>。这样，相关系数的范围就被归一化到 [-1,1] 之间了。</p><p>下面，我们就来分别计算上面这个例子中 X1、Y1 和 X2、Y2 的相关系数。</p><p>ρ(X1,Y1) = 0.9939</p><p>ρ(X2,Y2) = 0.9180</p><p>好了，我们得到 X1 与 Y1 的相关系数大于 X2 与 Y2 的相关系数。这符合实际情况。也就是说，根据相关系数，我们就能判定两个变量的相关程度，得到以下结论：</p><ul><li><strong>相关系数大于零，则表示两个变量正相关，且相关系数越大，正相关性越高；</strong></li><li><strong>相关系数小于零，则表示两个变量负相关，且相关系数越小，负相关性越高；</strong></li><li><strong>相关系数等于零，则表示两个变量不相关。</strong></li></ul><p>​    回过头来看一下协方差与相关系数的关系，其实，<strong>相关系数是协方差的标准化、归一化形式，消除了量纲、幅值变化不一的影响</strong>。实际应用中，在比较不同变量之间相关性时，使用相关系数更为科学和准确。但是协方差在机器学习的很多领域都有应用，而且非常重要！</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 协方差 </tag>
            
            <tag> 相关系数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DeepIOT神经网络压缩</title>
      <link href="/2018/08/24/DeepIOT%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%8B%E7%BC%A9/"/>
      <url>/2018/08/24/DeepIOT%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<!-- DeepIoT: Compressing Deep Neural Network Structures for Sensing Systems with a Compressor-Critic FrameworkShuochao YaoUniversity of Illinois Urbana ChampaignYiran ZhaoUniversity of Illinois Urbana ChampaignAston ZhangUniversity of Illinois Urbana ChampaignLu SuState University of New York at BualoTarek AbdelzaherUniversity of Illinois Urbana Champaign --><p>​    物联网在我们的日常感知场景中越来越受欢迎，有很多应用，比如智能家居/城市，在我们的日常生活中有大量的嵌入式/移动设备，下一个自然的步骤是构建能够集体学习的智能感知系统 。另一方面，DL最近在复杂的传感和识别任务上取得了很大进展 。</p><p>​    然而,挑战仍然存在,当我们部署先进的dl模型在低端很多设备参考这个数字从一篇分析先进的图像识别cnn模型,这些模型通常需要大约10 Giga-operations和100 mb的大小会导致记忆的问题,时间,能量消耗物联网设备上部署这些模型时。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/12654931-1133a30c19324047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    深度学习的最新进展激发了在传感应用中使用深度中立网络的动力，但是在<strong>受限的嵌入式设备</strong>上的<strong>过度的资源需求</strong>仍然是一个重要的障碍。最近探索的解决方案空间是在设备使用前，以某种方式<strong>压缩(近似或简化)深层神经网络</strong>。一种新的<strong>压缩解决方案</strong>，叫做<strong>DeepIoT</strong>，它在这个空间中做出了两个关键的贡献。</p><ul><li><p>首先，与目前针对压缩特殊性型神经网络的解决方案不同的是，DeepIoT提出了一种统一普适的方法，它<strong>压缩了所有常用的用于传感应用的深度学习结构</strong>，包括完<strong>全连接的、卷积的和递归的神经网络</strong>，<strong>以及它们的组合</strong>。</p></li><li><p>其次，与<strong>稀疏加权矩阵</strong>或<strong>假定加权矩阵内的线性结构</strong>的解决方案不同，DeepIoT通过<strong>寻找最少数量的非冗余隐藏元素（例如每层所需的滤波器和维度</strong>）<strong>将神经网络结构压缩为更小的密集矩阵</strong>，<strong>同时保留传感应用的性能相同</strong>。即不降低准确率。重要的是，它使用一种方法来<strong>获得参数冗余的全局视图</strong>，该方法被证明可以产生更好的压缩。</p></li></ul><p>由DeepIoT生成的压缩模型可以直接使用现有的深度学习库，这些库在嵌入式和移动系统上运行，无需进一步的修改。结果表明了<strong>深度神经网络在资源受限的嵌入式设备上的开发潜力</strong>。</p><p><strong>一、已有方法介绍</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-4eb2b88e8d6697fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    <strong>1、大密度参数矩阵——&gt;稀疏矩阵</strong></p><p>​    有研究试图解决这个问题，现有的最先进的压缩算法是一种基于量级的修剪方法如上所示，该算法查看权重矩阵，并迭代地删除小于3列的实体。最终，它将把这个大而密集的矩阵转换成一个大而稀疏的矩阵。通常这种方法只能将参数的数量减少到10个。</p><ul><li><strong>基于幅值</strong></li></ul><p>1、<strong>基于幅度的fine-tuning压缩方法</strong>。</p><p>​    该方法是<strong>迭代地去除低幅度的重量连接</strong>;然而，它<strong>需要更多的资源消耗实现稀疏矩阵</strong>。</p><p>2、<strong>剪枝</strong></p><p>​    积极的修剪方法增加了不可挽回的网络损害的潜在风险。虽然有一种连接拼接的压缩算法，为一定的阈值提供了恢复的机会然而，该算法仍然侧重于权重水平而不是结构水平。</p><ul><li><strong>基于因子分解</strong></li></ul><p>  除了基于幅度的方法之外，另一系列作品着重于基于因子分解的方法，其通过<strong>利用参数中的低秩结构来降低神经网络的复杂性</strong>。 </p><p>3、利用各种<strong>矩阵分解</strong>方法和fine-tunning近似卷积运算，以减少神经网络的执行时间。 </p><p>4、应用<strong>稀疏编码</strong>和基于矩阵分解的方法分别降低全连接层和卷积层的复杂度。</p><p>​    主要原因是稀疏矩阵实现效率低。一方面，<strong>稀疏矩阵需要记录</strong>，这导致了2倍的内存消耗。另一方面，<strong>稀疏矩阵相乘很难优化</strong> 。</p><p>​    然而，基于分解的方法与基于量值的方法相比通常获得较低的压缩比，并且低等级假设可能损害最终网络性能。 </p><p>5、应用<strong>频域信息</strong>进行模型压缩。然而，需要额外的实现来加速频域表示，并且该方法不适用于具有小卷积滤波器大小的现代CNN。 </p><p>6、Hinton等人提出了一个<strong>teacher-student框架</strong>，将整个模型中的知识提炼成一个模型。然而，框架更侧重于将模型集合压缩为单一模型而不是结构压缩。</p><p><strong>二、系统介绍</strong></p><p>​    DeepIoT通过<strong>决定每层中最小元素的数量来压缩常用的深度神经网络结构以用于传感应用</strong>。 先前关于神经网络压缩的照明研究使疏密密集将参数矩阵转换为大型稀疏矩阵。 相比之下，<strong>DeepIoT最大限度地减少了每层中的元素数量，从而将参数转化为一组小密集矩阵</strong>。<strong>小密集矩阵不需要为元素索引额外存储</strong>，并且对处理进行了有效优化。</p><p>​    DeepIoT借用了广泛使用的被称为<strong>Dropout</strong>的<strong>深度学习正则化方法隐藏元素</strong>的想法。 <strong>Dropout操作给每个隐藏元素一个Dropout概率</strong>。 在<strong>dropout过程</strong>中，<strong>隐藏元素可根据其dropout概率进行修剪</strong>。 可以生成“<strong>细化</strong>”的网络结构。 但是，这些dropout概率通常设置为预定义值，例如0.5。 这种预定义的值不是最优的概率，从而导致对解空间的有效探索较少。如果我们能够<strong>获得每个隐藏元素的最优dropout概率</strong>，那么我们就有可能<strong>生成 最优的薄网络结构，在保留了传感应用的精度，同时最大限度地降低了传感系统的资源消耗</strong>。DeepIoT的一个重要目的是<strong>为神经网络中的每个隐藏元素找到最优的dropout概率</strong>。</p><p>​    注意，Dropout可以很容易地应用于所有常用的神经网络结构。</p><p>​    1、在<strong>全连接的神经网络</strong>中，神经元在每一<strong>层</strong>都被丢弃;</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-b911647b450f5464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>直接删除隐藏的元素/神经元，而不是权重</strong>。最后，我们将一个大的稠密权矩阵转化为一个细网络结构的小密度权矩阵。因此，我们可以绕过稀疏矩阵的表示 .</p><p><strong>一开始没有最优压缩决策，所以前期是计算梯度变化，抑制dropout概率，并逐渐压缩，而不是直接删除。</strong></p><p>​    2、在<strong>卷积神经网络</strong>中，<strong>卷积核</strong>被丢弃在每一层;<br><img src="https://upload-images.jianshu.io/upload_images/12654931-20ce37c77a5f48ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    对于CNN的每一层，都有一组卷积核来学习输入图像的特征。DeepIoT尝试删除冗余卷积核，以减少CNN层的卷积核数量。 </p><p>​    3、并且在<strong>递归神经网络</strong>中，减小每层的<strong>维度</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0bed97057f74ccdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于RNN层，DeepIoT直接降低了RNN的维度，用于模型压缩。 </p><p>​    意味着<strong>DeepIoT可以应用于所有常用的神经网络结构及其组合</strong>。</p><p>​    DeepIoT的贡献在于<strong>利用新颖的压缩器神经网络将每个层的模型参数作为输入，学习参数冗余，并相应地生成Dropout概率</strong>。<strong>由于不同层之间存在参数互联，因此我们设计压缩神经网络作为递归神经网络，能够全局共享冗余信息并逐层生成dropout概率</strong>。</p><p><strong>压缩机神经网络</strong>与原神经网络<strong>协同优化</strong>，通过<strong>compressor-critic框架</strong>进行压缩，<strong>尽量减小原始传感应用程序的损失功能</strong>。actor-critic框架模拟了著名的基于增强学习的actor-critic算法的思想，以<strong>迭代的方式</strong>优化了两个网络。</p><p>评估实验。</p><p>1、首先由三个任务组成，这三个任务使嵌入式系统能够以基本模式（包括<strong>手写文本</strong>，<strong>视觉</strong>和<strong>语音</strong>）与人类进行交互，与其他类似尺寸的神经网络相比，我们生成的神经网络具有更高的准确性。</p><p>2、第二组提供了两个应用压缩神经网络来解决<strong>以人为中心的情境感知任务</strong>的例子;即资源受限情景中的<strong>人类活动识别</strong>和<strong>用户识别</strong>。</p><p>DeepIOT特性：</p><ul><li>由于压缩过程是迭代进行的，<strong>必须具有恢复能力</strong>以提高最终性能。</li><li>以前的方法主要依赖于一些特定的压缩度量，我们希望DeepIoT<strong>基于参数冗余进行压缩</strong>。</li><li>深度神经网络是一种深层结构，因此深度神经网络应该具有<strong>全局性</strong>，<strong>必须了解全局冗余度</strong>。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12654931-30483f2f5494237f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图我们使用一个压缩3层全连接神经网络结构的例子来说明DeepIoT的整个流程。 （绿色方框表示原始神经网络的参数。橙色代表dropout操作）所示。使用DeepIoT压缩传感应用的神经网络结构的基本步骤可概括如下：</p><p>（1）   <strong>插入操作</strong>。将概率$p^{(l)}$随机置零的隐藏元素(图1中的红色方框)插入到原始神经网络的内部层中。  </p><p>（2）   <strong>构建压缩神经网络</strong>。它将图层中的<strong>原始神经网络权重矩阵$W^{l}​$ </strong>（图1中的绿框）<strong>作为输入进行压缩</strong>，<strong>在不同层之间学习和共享参数冗余，并生成最优dropout概率$p^{(l)}​$</strong>，<strong>然后送回到原始神经网络中的dropout操作</strong>。</p><p>（3）  用<strong>compressor-critic框架对压缩神经网络和原始神经网络进行</strong>迭代优化<strong>。 </strong>对压缩神经网络进行迭代优化，使其产生更好的退出概率，从而为原神经网络生成更有效的网络结构。 </p><p>​    </p><p>​    <strong><em>学习参数冗余 </em></strong>（橙色）<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3a5db6cbaa29bc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    基于参数冗余的DeepIOT。在理想的情况下，DeepIoT可以学习一个带参数的最优压缩机$\mu$，函数从神经网络中获取权重矩阵W。学习参数冗余，并生成可用于压缩的隐藏神经元的最优Dropout概率 。</p><p>​    <strong><em>参数冗余的全局视图</em></strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-59f84a197fb5b9a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    但我们如何设计这个最优压缩函数与参数冗余的全局视图。我们知道深神经网络本身就是完美函数逼近器。只要有足够的容量，它就可以逼近所有已有的连续函数。因此，我们将<strong>压缩函数设计成一种递归神经网络。</strong>它<strong>从原始神经网络中逐层提取权重矩阵，了解全局冗余信息，生成压缩dropout概率</strong>。这里我们称压缩函数、压缩器和要压缩的原始神经网络为“critic”，因为critic向压缩器提供反馈，让它知道根据“监督”得出的dropout概率是好是坏 。</p><p><strong>Compressor-Critic Framework</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-53bd25e684eb5f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    DeepIoT的目标函数是根据compressor学习到的损失概率来学习压缩模型的期望损失。我们反复训练，这意味着当训练compressor时，我们把所有的东西都固定在critic，反之亦然 。</p><p>​    对原神经网络和压缩神经网络进行迭代优化，使压缩神经网络以<strong>软删除</strong>的方式逐渐压缩原神经网络。 </p><p>​    我们把最初的神经网络称为$F_{W}(x|z)$，我们称之为Critic。它将x作为输入，并基于二进制dropout 记为Z和模型参数w生成预测，这些参数w指的是一组权重$W=w^{(l)}$。 。我们假设$F_{W}(x|z)$是一个预先训练好的模型。$z~\mu_{\phi}(W)$表示压缩神经网络。它将Critic的权重作为输入，并根据其自身参数生成mask向量Z的概率分布。为了优化压缩器，使其在Critic中去掉隐藏元素，DeepIoT遵循了上图的目标函数。</p><p>​    其中$l$是Critic的目标函数。目标函数可以解释为原始神经网络的期望损失乘以压缩机产生的dropout概率。</p><p>​    DeeploT以迭代的方式优化Compressor和Critic。通过对Compressor采用梯度下降法，迭代求解，降低了目标函数中定义的期望损失。如何去做？由于存在<strong>离散采样操作</strong>，在计算图中，反向传播不直接适用。因此，我们使用<strong>无偏似然比估计量</strong>来计算。</p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 神经网络压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HAN</title>
      <link href="/2018/08/24/HAN/"/>
      <url>/2018/08/24/HAN/</url>
      <content type="html"><![CDATA[<p><strong>论文：</strong>Hierarchical Attention Networks for Document Classification</p><p><strong>发表会议：*</strong>NAACL2016*</p><p><strong>前言：</strong>本文针对文本分类任务提出了一个层次化attention机制模型(<strong>HAN</strong>)，有两个显著的特点：(1)采用“词-句子-文章”的层次化结构来表示一篇文本。(2)该模型有两个层次的attention机制，分别存在于词层次(word level)和句子层次(sentence level)。从而使该模型具有对文本中重要性不同的句子和词的能力给予不同“注意力”的能力。作者在6个数据集合上进行了测试，并且相较以往的模型效果提升显著。最后，通过可视化说明该模型可以选择出含有丰富信息的词语和句子。 </p><a id="more"></a><p><strong>一 、写作动机</strong></p><p>​    文本分类是一项基础的NLP任务，在主题分类，情感分析，垃圾邮件检测等应用上有广泛地应用。其目标是给每篇文本分配一个类别标签。本文中模型的直觉是，不同的词和句子对文本信息的表达有不同的影响，词和句子的重要性是严重依赖于上下文的，即使是相同的词和句子，在不同的上下文中重要性也不一样。就像人在阅读一篇文本时，对文本不同的内容是有着不同的注意度的。而本文在attention机制的基础上，联想到文本是一个层次化的结构，提出用词向量来表示句子向量，再由句子向量表示文档向量，并且在词层次和句子层次分别引入attention操作的模型。</p><p>​    分层构建只不过加上了两个Attention层，用于分别对句子和文档中的单词、句子的重要性进行建模。其主要思想是，首先考虑文档的分层结构：单词构成句子，句子构成文档，所以建模时也分这两部分进行。其次，不同的单词和句子具有不同的信息量，不能单纯的统一对待所以引入Attention机制。而且引入Attention机制除了提高模型的精确度之外还可以进行单词、句子重要性的分析和可视化，让我们对文本分类的内部有一定了解。模型主要可以分为下面四个部分，如下图所示：</p><ol><li>a word sequence encoder,</li><li>a word-level attention layer,</li><li>a sentence encoder</li><li>a sentence-level attention layer.<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4eff2296d8389ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p>这里对Attention机制进行一个补充介绍，可以参考论文“FEED-FORWARD NETWORKS WITH ATTENTION CAN SOLVE SOME LONG -TERM MEMORY PROBLEMS”里面的插图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0feab3f9a475bb34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>1. 基于GRU的词序列编码器</strong></p><p>GRU是RNN的一个变种，使用门机制来记录序列当前的状态。隐藏层有两个门(gate)，重置门(reset gate)rt和更新门(update gate)!zt。这两个门一起来控制当前状态有多少信息要更新。在时刻t，隐藏层状态的计算公式：</p><p> $h_{t} =(1-z_{t})\odot h_{t-1} +z_{t}\odot  \tilde{h_t }$</p><p>更新门(update gate)zt是用来决定有多少过去的信息被保留，以及有多少新信息被加进来：</p><p> $z_{t} =\sigma (W_{z}x_{t} +U_{z}h_{t-1} +b_{z}  )$</p><p>这里xt是在时刻t输入的单词的词向量，候选状态ht~的计算方法和普通的RNN相似： </p><p>$\tilde{h_{t} }=tanh(W_{h}x_{t}+r_{t}\odot (U_{h}h_{t-1}  ) +b_{h}   ) $</p><p>重置门rt决定有多少过去的信息作用于候选状态，如果rt是0，即忘记之前的所有状态： </p><p>$r_{t}=\sigma(W_{r}x_{t}+U_{r}h_{t-1}+b_{r} )$</p><p><strong>2 层次化attention</strong></p><p><strong>2.1 词编码器（Word Encoder）</strong></p><p>由词序列组成$w_{it}$,$t\in [0,T]$组成的句子,首先把词转化成词向量，$x_{it}=W_{e}w_{it}$,然后用双向的GRU网络,可以将正向和反向的上下文信息结合起来，获得隐藏层输出。</p><p>$x_{it}=W_{e}w_{it},t\in[1,T]$</p><p> $\overrightarrow{h_{it}}=\overrightarrow{GRU}({x_{it}})$</p><p>$\overleftarrow{h_{it}}=\overleftarrow{GRU}({x_{it}})$</p><p>对于一个给定的词语$w_{it}$,经过GRU网络后，我们获得了一种新的表示：$h_{it}=[\overrightarrow{h_{it}},\overleftarrow{h_{it}}]$</p><p>$h_{it}$包含了$w_{it}$周围两个方向的信息。</p><p><strong>2.2 词级别的attention机制</strong></p><p>attention机制的目的是要把一个句子中，对句子的含义最重要，贡献最大的词语找出来。我们通过将$h_{it}$输入到一个单层的感知机(MLP)中得到的结果$u_{it}$作为$h_{it}$的隐含表示。</p><p> $u_{it}=tanh(W_{w}h_{it}+b_{w})$</p><p>为了衡量单词的重要性,我们用$u_{it}$和一个随机初始化的上下文向量$u_{w}$的相似度来表示，然后经过softmax操作获得了一个归一化的attention权重矩阵$\alpha _{it}$，代表句子i中第t个词的权重。</p><p> $\alpha_{i}=\frac{exp\left( u_{i}^\top u_{s} \right) }{\sum_{t}^{}{exp\left( u_{t}^\top u_{s} \right) } } $</p><p>有了attention权重矩阵以后，我们可以将句子向量$s_{i}$看作组成这些句子的词向量的加权求和。这里的上下文向量$u_{w}$是在训练网络的过程中学习获得的。我们可以把$u_{w}$当作一种询问的高级表示，比如“哪些词含有比较重要的信息？”</p><p>$s_{i}=\sum_{t}{\alpha_{it}h_{it}} $</p><p><strong>2.3 语句编码器(Sentence Encoder)</strong></p><p>得到了句子向量表示$s_{i}$以后，我们用类似的办法获得文档向量：</p><p>  $\overrightarrow{h_{i}}=\overrightarrow{GRU}(s_{i}),i\in[1,L]$</p><p> $\overleftarrow{h_{i}}=\overleftarrow{GRU}(s_{i}),i\in[L,1]$</p><p>对于给定的句子$s_{i}$我们得到了相应的句子表示$h_{i}=[\overrightarrow{h_{i}},\overleftarrow{h_{i}}]$。这样获得的表示可以包含两个方向的上下文信息。</p><p><strong>2.4 句子级别的attention</strong></p><p>和词级别的attention类似，我们也提出了一个句子级别的上下文向量$u_{s}$,来衡量一个句子在整篇文本的重要性。</p><p>$u_{i}=tanh(W_{s}h_{i}+b_{s})$</p><p> $\alpha_{i}=\frac{exp\left( u_{i}^\top u_{s} \right) }{\sum_{t}^{}{exp\left( u_{t}^\top u_{s} \right) } } $</p><p> $v=\sum_{i}{\alpha_{i}h_{i}}$</p><p>我们获得了整篇文章的向量表示v,最后可以使用全链接的softmax层进行分类。 </p><p><strong>总结</strong></p><p>​    本文提出了一种基于层次化attention的文本分类模型，可以利用attention机制识别出一句话中比较重要的词语，利用重要的词语形成句子的表示，同样识别出重要的句子，利用重要句子表示来形成整篇文本的表示。实验证明，该模型确实比基准模型获得了更好的效果，可视化分析也表明，该模型能很好地识别出重要的句子和词语。</p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Attention </tag>
            
            <tag> Hierarchical Attention Networks </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习中Attention注意力机制</title>
      <link href="/2018/08/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADAttention%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/08/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADAttention%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>​    最近两年，注意力模型（Attention Model）被广泛使用在<strong>自然语言处理</strong>、<strong>图像识别</strong>及<strong>语音识别</strong>等各种不同类型的深度学习任务中，是深度学习技术中最值得关注与深入了解的核心技术之一。</p><p>​    本文以机器翻译为例，深入浅出地介绍了深度学习中注意力机制的原理及关键计算机制，同时也抽象出其本质思想，并介绍了注意力模型在图像及语音等领域的典型应用场景。</p><p>​    注意力模型最近几年在深度学习各个领域被广泛使用，无论是图像处理、语音识别还是自然语言处理的各种不同类型的任务中，都很容易遇到注意力模型的身影。所以，了解注意力机制的工作原理对于关注深度学习技术发展的技术人员来说有很大的必要。</p><a id="more"></a><p><strong>人类的视觉注意力</strong></p><p>​    从注意力模型的命名方式看，很明显其借鉴了人类的注意力机制，因此，我们首先简单介绍人类视觉的选择性注意力机制。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fb4da1bea0bf6c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图1 人类的视觉注意力 </p><p>​    视觉注意力机制是人类视觉所特有的大脑信号处理机制。人类视觉通过快速扫描全局图像，获得需要重点关注的目标区域，也就是一般所说的注意力焦点，而后对这一区域投入更多注意力资源，以获取更多所需要关注目标的细节信息，而抑制其他无用信息。</p><p>​    这是人类利用有限的注意力资源从大量信息中快速筛选出高价值信息的手段，是人类在长期进化中形成的一种生存机制，人类视觉注意力机制极大地提高了视觉信息处理的效率与准确性。</p><p>​    图1形象化展示了人类在看到一副图像时是如何高效分配有限的注意力资源的，其中红色区域表明视觉系统更关注的目标，很明显对于图1所示的场景，人们会把注意力更多投入到人的脸部，文本的标题以及文章首句等位置。</p><p>​    深度学习中的注意力机制从本质上讲和人类的选择性视觉注意力机制类似，核心目标也是从众多信息中选择出对当前任务目标更关键的信息。</p><p><strong>Encoder-Decoder框架</strong></p><p>​    要了解深度学习中的注意力模型，就不得不先谈Encoder-Decoder框架，因为目前大多数注意力模型附着在Encoder-Decoder框架下，当然，其实注意力模型可以看作一种通用的思想，本身并不依赖于特定框架，这点需要注意。</p><p>​    Encoder-Decoder框架可以看作是一种深度学习领域的研究模式，应用场景异常广泛。图2是文本处理领域里常用的Encoder-Decoder框架最抽象的一种表示。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-673d1e3c89384f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图2 抽象的文本处理领域的Encoder-Decoder框架</p><p>​    文本处理领域的Encoder-Decoder框架可以这么直观地去理解：可以把它看作适合处理由一个句子（或篇章）生成另外一个句子（或篇章）的通用处理模型。对于句子对&lt;Source,Target&gt;，我们的目标是给定输入句子Source，期待通过Encoder-Decoder框架来生成目标句子Target。Source和Target可以是同一种语言，也可以是两种不同的语言。而Source和Target分别由各自的单词序列构成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-b81ce17f917e41ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Encoder顾名思义就是对输入句子Source进行编码，将输入句子通过非线性变换转化为中间语义表示C： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-18ac98f85ce18c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于解码器Decoder来说，其任务是根据句子Source的中间语义表示C和之前已经生成的历史信息y1,y2,……,y i-1!来生成i时刻要生成的单词yi：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-07e7143d8889b113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    每个yi都依次这么产生，那么看起来就是整个系统根据输入句子Source生成了目标句子Target。如果Source是中文句子，Target是英文句子，那么这就是解决机器翻译问题的Encoder-Decoder框架；如果Source是一篇文章，Target是概括性的几句描述语句，那么这是文本摘要的Encoder-Decoder框架；如果Source是一句问句，Target是一句回答，那么这是问答系统或者对话机器人的Encoder-Decoder框架。由此可见，在文本处理领域，Encoder-Decoder的应用领域相当广泛。</p><p>​    Encoder-Decoder框架不仅仅在文本领域广泛使用，在语音识别、图像处理等领域也经常使用。比如对于语音识别来说，图2所示的框架完全适用，区别无非是Encoder部分的输入是语音流，输出是对应的文本信息；而对于“图像描述”任务来说，Encoder部分的输入是一副图片，Decoder的输出是能够描述图片语义内容的一句描述语。一般而言，文本处理和语音识别的Encoder部分通常采用RNN模型，图像处理的Encoder一般采用CNN模型。</p><p><strong>Attention模型</strong></p><p>​    本节先以机器翻译作为例子讲解最常见的Soft Attention模型的基本原理，之后抛离Encoder-Decoder框架抽象出了注意力机制的本质思想，然后简单介绍最近广为使用的Self Attention的基本思路。</p><p><strong>Soft Attention模型</strong></p><p>​    图2中展示的Encoder-Decoder框架是没有体现出“注意力模型”的，所以可以把它看作是注意力不集中的分心模型。为什么说它注意力不集中呢？请观察下目标句子Target中每个单词的生成过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4a14bb2ebaae352b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中f是Decoder的非线性变换函数。从这里可以看出，在生成目标句子的单词时，不论生成哪个单词，它们使用的输入句子Source的语义编码C都是一样的，没有任何区别。</p><p>​    而语义编码C是由句子Source的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词y1,y2还是y3，其实句子Source中任意单词对生成某个目标单词yi来说影响力都是相同的，这是为何说这个模型没有体现出注意力的缘由。这类似于人类看到眼前的画面，但是眼中却没有注意焦点一样。</p><p>​    如果拿机器翻译来解释这个分心模型的Encoder-Decoder框架更好理解，比如输入的是英文句子：Tom chase Jerry，Encoder-Decoder框架逐步生成中文单词：“汤姆”，“追逐”，“杰瑞”。</p><p>​    在翻译“杰瑞”这个中文单词的时候，分心模型里面的每个英文单词对于翻译目标单词“杰瑞”贡献是相同的，很明显这里不太合理，显然“Jerry”对于翻译成“杰瑞”更重要，但是分心模型是无法体现这一点的，这就是为何说它没有引入注意力的原因。</p><p>​    没有引入注意力的模型在输入句子比较短的时候问题不大，但是如果输入句子比较长，此时所有语义完全通过一个中间语义向量来表示，单词自身的信息已经消失，可想而知会丢失很多细节信息，这也是为何要引入注意力模型的重要原因。</p><p>​    上面的例子中，如果引入Attention模型的话，应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：</p><p>（Tom,0.3）(Chase,0.2) (Jerry,0.5)</p><p>​    每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。</p><p>​    同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词yi的时候，原先都是相同的中间语义表示C会被替换成根据当前生成单词而不断变化的Ci。理解Attention模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的Ci。增加了注意力模型的Encoder-Decoder框架理解起来如图3所示。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-87bc6ecb6c37d755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图3 引入注意力模型的Encoder-Decoder框架</p><p>即生成目标句子单词的过程成了下面的形式：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-758accd42659461c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    而每个Ci可能对应着不同的源语句子单词的注意力分配概率分布，比如对于上面的英汉翻译来说，其对应的信息可能如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-22d97a1a2eb5c5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中，f2函数代表Encoder对输入英文单词的某种变换函数，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入Xi后隐层节点的状态值；g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般的做法中，g函数就是对构成元素加权求和，即下列公式： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-07cda8310b043204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中，Lx代表输入句子Source的长度，aij代表在Target输出第i个单词时Source输入句子中第j个单词的注意力分配系数，而hj则是Source输入句子中第j个单词的语义编码。假设Ci下标i就是上面例子所说的“ 汤姆” ，那么Lx就是3，h1=f(“Tom”)，h2=f(“Chase”),h3=f(“Jerry”)分别是输入句子每个单词的语义编码，对应的注意力模型权值则分别是0.6,0.2,0.2，所以g函数本质上就是个加权求和函数。如果形象表示的话，翻译中文单词“汤姆”的时候，数学公式对应的中间语义表示Ci的形成过程类似图4。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b7b36d1a95dd63e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    这里还有一个问题：生成目标句子某个单词，比如“汤姆”的时候，如何知道Attention模型所需要的输入句子单词注意力分配概率分布值呢？就是说“汤姆”对应的输入句子Source中各个单词的概率分布：(Tom,0.6)(Chase,0.2) (Jerry,0.2) 是如何得到的呢？</p><p>​    为了便于说明，我们假设对图2的非Attention模型的Encoder-Decoder框架进行细化，Encoder采用RNN模型，Decoder也采用RNN模型，这是比较常见的一种模型配置，则图2的框架转换为图5。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-9dad02d0e28ad036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图5 RNN作为具体模型的Encoder-Decoder框架</p><p>那么用图6可以较为便捷地说明注意力分配概率分布值的通用计算过程。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-443c9b6cca038058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    图6 注意力分配概率计算</p><p>​    对于采用RNN的Decoder来说，在时刻i，如果要生成yi单词，我们是可以知道Target在生成yi之前的时刻i-1时，隐层节点i-1时刻的输出值Hi-1的，而我们的目的是要计算生成yj时输入句子中的单词“Tom”、“Chase”、“Jerry”对yi来说的注意力分配概率分布，那么可以用Target输出句子i-1时刻的隐层节点状态Hi-1去一一和输入句子Source中每个单词对应的RNN隐层节点状态hj进行对比，即通过函数F(hj,Hi-1)来获得目标单词yi和每个输入单词对应的对齐可能性，这个F函数在不同论文里可能会采取不同的方法，然后函数F的输出经过Softmax进行归一化就得到了符合概率分布取值区间的注意力分配概率分布数值。</p><p>​    绝大多数Attention模型都是采取上述的计算框架来计算注意力分配概率分布信息，区别只是在F的定义上可能有所不同。图7可视化地展示了在英语-德语翻译系统中加入Attention机制后，Source和Target两个句子每个单词对应的注意力分配概率分布。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-9f0d5e50c90d7165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图7 英语-德语翻译的注意力概率分布</p><p>上述内容就是经典的Soft Attention模型的基本思想，那么怎么理解Attention模型的物理含义呢？一般在自然语言处理应用里会把Attention模型看作是输出Target句子中某个单词和输入Source句子每个单词的对齐模型，这是非常有道理的。</p><p>​    目标句子生成的每个单词对应输入句子单词的概率分布可以理解为输入句子单词和这个目标生成单词的对齐概率，这在机器翻译语境下是非常直观的：传统的统计机器翻译一般在做的过程中会专门有一个短语对齐的</p><p>步骤，而注意力模型其实起的是相同的作用。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-181c0ac7d346c4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图8 Google 神经网络机器翻译系统结构图</p><p>​    图8所示即为Google于2016年部署到线上的基于神经网络的机器翻译系统，相对传统模型翻译效果有大幅提升，翻译错误率降低了60%，其架构就是上文所述的加上Attention机制的Encoder-Decoder框架，主要区别无非是其Encoder和Decoder使用了8层叠加的LSTM模型。</p><p><strong>Attention机制的本质思想</strong></p><p>​    如果把Attention机制从上文讲述例子中的Encoder-Decoder框架中剥离，并进一步做抽象，可以更容易看懂Attention机制的本质思想。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-59f1d669793d5f88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图9 Attention机制的本质思想</p><p>​    我们可以这样来看待Attention机制（参考图9）：将Source中的构成元素想象成是由一系列的&lt;Key,Value&gt;数据对构成，此时给定Target中的某个元素Query，通过计算Query和各个Key的相似性或者相关性，得到每个Key对应Value的权重系数，然后对Value进行加权求和，即得到了最终的Attention数值。所以本质上Attention机制是对Source中元素的Value值进行加权求和，而Query和Key用来计算对应Value的权重系数。即可以将其本质思想改写为如下公式：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-665dfe15e5428ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中，Lx=||Source||代表Source的长度，公式含义即如上所述。上文所举的机器翻译的例子里，因为在计算Attention的过程中，Source中的Key和Value合二为一，指向的是同一个东西，也即输入句子中每个单词对应的语义编码，所以可能不容易看出这种能够体现本质思想的结构。</p><p>​    当然，从概念上理解，把Attention仍然理解为从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略大多不重要的信息，这种思路仍然成立。聚焦的过程体现在权重系数的计算上，权重越大越聚焦于其对应的Value值上，即权重代表了信息的重要性，而Value是其对应的信息。</p><p>​    从图9可以引出另外一种理解，也可以将Attention机制看作一种软寻址（Soft Addressing）:Source可以看作存储器内存储的内容，元素由地址Key和值Value组成，当前有个Key=Query的查询，目的是取出存储器中对应的Value值，即Attention数值。通过Query和存储器内元素Key的地址进行相似性比较来寻址，之所以说是软寻址，指的不像一般寻址只从存储内容里面找出一条内容，而是可能从每个Key地址都会取出内容，取出内容的重要性根据Query和Key的相似性来决定，之后对Value进行加权求和，这样就可以取出最终的Value值，也即Attention值。所以不少研究人员将Attention机制看作软寻址的一种特例，这也是非常有道理的。</p><p>​    至于Attention机制的具体计算过程，如果对目前大多数方法进行抽象的话，可以将其归纳为两个过程：第一个过程是根据Query和Key计算权重系数，第二个过程根据权重系数对Value进行加权求和。而第一个过程又可以细分为两个阶段：第一个阶段根据Query和Key计算两者的相似性或者相关性；第二个阶段对第一阶段的原始分值进行归一化处理；这样，可以将Attention的计算过程抽象为如图10展示的三个阶段。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a4b0e1012e5bd916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图10 三阶段计算Attention过程</p><p>​    在第一个阶段，可以引入不同的函数和计算机制，根据Query和某个Keyi，计算两者的相似性或者相关性，最常见的方法包括：求两者的向量点积、求两者的向量Cosine相似性或者通过再引入额外的神经网络来求值，即如下方式：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c93d879ffaca8c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    第一阶段产生的分值根据具体产生的方法不同其数值取值范围也不一样，第二阶段引入类似SoftMax的计算方式对第一阶段的得分进行数值转换，一方面可以进行归一化，将原始计算分值整理成所有元素权重之和为1的概率分布；另一方面也可以通过SoftMax的内在机制更加突出重要元素的权重。即一般采用如下公式计算：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e0e5d2da5ca0ec70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    第二阶段的计算结果!ai即为Valuei对应的权重系数，然后进行加权求和即可得到Attention数值：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e99ce9f941c56f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    通过如上三个阶段的计算，即可求出针对Query的Attention数值，目前绝大多数具体的注意力机制计算方法都符合上述的三阶段抽象计算过程。 </p><p><strong>Self Attention模型</strong></p><p>​    通过上述对Attention本质思想的梳理，我们可以更容易理解本节介绍的Self Attention模型。Self Attention也经常被称为intra Attention（内部Attention），最近一年也获得了比较广泛的使用，比如Google最新的机器翻译模型内部大量采用了Self Attention模型。</p><p>​    在一般任务的Encoder-Decoder框架中，输入Source和输出Target内容是不一样的，比如对于英-中机器翻译来说，Source是英文句子，Target是对应的翻译出的中文句子，Attention机制发生在Target的元素Query和Source中的所有元素之间。而Self Attention顾名思义，指的不是Target和Source之间的Attention机制，而是Source内部元素之间或者Target内部元素之间发生的Attention机制，也可以理解为Target=Source这种特殊情况下的注意力计算机制。其具体计算过程是一样的，只是计算对象发生了变化而已，所以此处不再赘述其计算过程细节。</p><p>​    如果是常规的Target不等于Source情形下的注意力计算，其物理含义正如上文所讲，比如对于机器翻译来说，本质上是目标语单词和源语单词之间的一种单词对齐机制。那么如果是Self Attention机制，一个很自然的问题是：通过Self Attention到底学到了哪些规律或者抽取出了哪些特征呢？或者说引入Self Attention有什么增益或者好处呢？我们仍然以机器翻译中的Self Attention来说明，图11和图12是可视化地表示Self Attention在同一个英语句子内单词间产生的联系。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a3ec94c5bab0da8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图11 可视化Self Attention实例<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c06b7b882ea54e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图12 可视化Self Attention实例</p><p>​    从两张图（图11、图12）可以看出，Self Attention可以捕获同一个句子中单词之间的一些句法特征（比如图11展示的有一定距离的短语结构）或者语义特征（比如图12展示的its的指代对象Law）。</p><p>​    很明显，引入Self Attention后会更容易捕获句子中长距离的相互依赖的特征，因为如果是RNN或者LSTM，需要依次序序列计算，对于远距离的相互依赖的特征，要经过若干时间步步骤的信息累积才能将两者联系起来，而距离越远，有效捕获的可能性越小。</p><p>​    但是Self Attention在计算过程中会直接将句子中任意两个单词的联系通过一个计算步骤直接联系起来，所以远距离依赖特征之间的距离被极大缩短，有利于有效地利用这些特征。除此外，Self Attention对于增加计算的并行性也有直接帮助作用。这是为何Self Attention逐渐被广泛使用的主要原因。</p><p><strong>Attention机制的应用</strong></p><p>​    前文有述，Attention机制在深度学习的各种应用领域都有广泛的使用场景。上文在介绍过程中我们主要以<strong>自然语言处理</strong>中的<strong>机器翻译</strong>任务作为例子，下面分别再从<strong>图像处理</strong>领域和<strong>语音识别</strong>选择典型应用实例来对其应用做简单说明。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f85fefd11ac30319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图13 图片-描述任务的Encoder-Decoder框架</p><p><strong>图片描述（Image-Caption）</strong>是一种典型的图文结合的深度学习应用，输入一张图片，人工智能系统输出一句描述句子，语义等价地描述图片所示内容。很明显这种应用场景也可以使用Encoder-Decoder框架来解决任务目标，此时Encoder输入部分是一张图片，一般会用CNN来对图片进行特征抽取，Decoder部分使用RNN或者LSTM来输出自然语言句子（参考图13）。</p><p>​    此时如果加入Attention机制能够明显改善系统输出效果，Attention模型在这里起到了类似人类视觉选择性注意的机制，在输出某个实体单词的时候会将注意力焦点聚焦在图片中相应的区域上。图14给出了根据给定图片生成句子“A person is standing on a beach with a surfboard.”过程时每个单词对应图片中的注意力聚焦区域。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f037cc39c3734b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图14 图片生成句子中每个单词时的注意力聚焦区域</p><p>​    图15给出了另外四个例子形象地展示了这种过程，每个例子上方左侧是输入的原图，下方句子是人工智能系统自动产生的描述语句，上方右侧图展示了当AI系统产生语句中划横线单词的时候，对应图片中聚焦的位置区域。比如当输出单词dog的时候，AI系统会将注意力更多地分配给图片中小狗对应的位置。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-171a7bb3b3837e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图15 图像描述任务中Attention机制的聚焦作用<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f7f34eccc3a8c2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图16 语音识别中音频序列和输出字符之间的Attention</p><p>​    语音识别的任务目标是将语音流信号转换成文字，所以也是Encoder-Decoder的典型应用场景。Encoder部分的Source输入是语音流信号，Decoder部分输出语音对应的字符串流。</p><p>​    图16可视化地展示了在Encoder-Decoder框架中加入Attention机制后，当用户用语音说句子 how much would a woodchuck chuck 时，输入部分的声音特征信号和输出字符之间的注意力分配概率分布情况，颜色越深代表分配到的注意力概率越高。从图中可以看出，在这个场景下，Attention机制起到了将输出字符和输入语音信号进行对齐的功能。</p><p>​    上述内容仅仅选取了不同AI领域的几个典型Attention机制应用实例，Encoder-Decoder加Attention架构由于其卓越的实际效果，目前在深度学习领域里得到了广泛的使用，了解并熟练使用这一架构对于解决实际问题会有极大帮助。    </p><p><strong>目前主流attention主流方法</strong></p><ol><li><p>首先是Object Recognition。</p></li><li><p>然后是Image Caption。</p></li><li><p>NLP中的Machine Translation.</p></li><li><p>不使用RNN结构。在特征图上生成空间分布的权重，然后再对特征图加权求和，试图让网络学出来对不同物体区域加以不同关注度。</p></li><li><p>总结与泛化。划重点：attention机制听起来高达上，其实就是学出一个权重分布，再拿这个权重分布施加在原来的特征之上，就可以叫做attention。</p><p>简单来说：</p><p>（1）这个加权可以是保留所有分量均做加权（即soft attention）；也可以是在分布中以某种采样策略选取部分分量（即hard attention）。</p><p>（2）这个加权可以作用在原图上，也就是RAM和DRAM；也可以作用在特征图上，如后续的好多文章（例如image caption)。</p><p>（3）这个加权可以作用在空间尺度上，给不同空间区域加权；也可以作用在channel尺度上，给不同通道特征加权；甚至特征图上每个元素加权。</p><p>（4）这个加权还可以作用在不同时刻历史特征上，如Machine Translation，以及我前段时间做的视频相关的工作。</p><p>所以说，Attention是啥啊？就是一个权重分布！</p></li></ol>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Attention </tag>
            
            <tag> 注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LSTM原理与实现</title>
      <link href="/2018/08/24/LSTM%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/24/LSTM%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<ul><li>[RNN]</li><li>[LSTM网络]</li><li>[LSTM核心思想]</li><li>[逐步理解LSTM]<ul><li>[遗忘门]</li><li>[输入门]</li><li>[输出门]</li></ul></li><li>[LSTM变体]</li><li>[多层LSTM]</li><li>LSTM实现手写数字<ul><li>[设置LSTM参数]</li><li>[初始化权值参数]</li></ul></li></ul><a id="more"></a> <h2 id="Recurrent-Neural-Networks"><a href="#Recurrent-Neural-Networks" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h2><p>​    人类并不是每时每刻都从一片空白的大脑开始他们的思考。在你阅读这篇文章时候，你都是基于自己已经拥有的对先前所见词的理解来推断当前词的真实含义。我们不会将所有的东西都全部丢弃，然后用空白的大脑进行思考。我们的思想拥有持久性。<br>    传统的神经网络并不能做到这点，看起来也像是一种巨大的弊端。例如，假设你希望对电影中的每个时间点的时间类型进行分类。传统的神经网络应该很难来处理这个问题——使用电影中先前的事件推断后续的事件。<br>    RNN 解决了这个问题。RNN 是包含循环的网络，允许信息的持久化。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-db35984a77cb0f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>RNN 包含循环</em></p><p>​    在上面的示例图中，神经网络的模块，A，正在读取某个输入 x_i，并输出一个值 h_i。循环可以使得信息可以从当前步传递到下一步。<br>    这些循环使得 RNN 看起来非常神秘。然而，如果你仔细想想，这样也不比一个正常的神经网络难于理解。RNN 可以被看做是同一神经网络的多次复制，每个神经网络模块会把消息传递给下一个。所以，如果我们将这个循环展开：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5afb587b1e3aaf95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>展开的 RNN</em></p><p>​    链式的特征揭示了 RNN 本质上是与序列和列表相关的。他们是对于这类数据的最自然的神经网络架构。<br>    并且 RNN 也已经被人们应用了！在过去几年中，应用 RNN 在语音识别，语言建模，翻译，图片描述等问题上已经取得一定成功，并且这个列表还在增长。建议参考 Andrej Karpathy 的博客文章——<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks</a> 来看看更丰富有趣的 RNN 的成功应用。<br>    而这些成功应用的关键之处就是 LSTM 的使用，这是一种特别的 RNN，比标准的 RNN 在很多的任务上都表现得更好。几乎所有的令人振奋的关于 RNN 的结果都是通过 LSTM 达到的。</p><h2 id="长期依赖（Long-Term-Dependencies）问题"><a href="#长期依赖（Long-Term-Dependencies）问题" class="headerlink" title="长期依赖（Long-Term Dependencies）问题"></a>长期依赖（Long-Term Dependencies）问题</h2><p>​    RNN 的关键点之一就是他们可以用来连接先前的信息到当前的任务上，例如使用过去的视频段来推测对当前段的理解。如果 RNN 可以做到这个，他们就变得非常有用。但是真的可以么？答案是，还有很多依赖因素。<br>    有时候，我们仅仅需要知道先前的信息来执行当前的任务。例如，我们有一个语言模型用来基于先前的词来预测下一个词。如果我们试着预测 “the clouds are in the sky” 最后的词，我们并不需要任何其他的上下文 —— 因此下一个词很显然就应该是 sky。在这样的场景中，相关的信息和预测的词位置之间的间隔是非常小的，RNN 可以学会使用先前的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-bffa58cf1e08bf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​                                不太长的相关信息和位置间隔</p><p>​    但是同样会有一些更加复杂的场景。假设我们试着去预测“I grew up in France… I speak fluent French”最后的词。当前的信息建议下一个词可能是一种语言的名字，但是如果我们需要弄清楚是什么语言，我们是需要先前提到的离当前位置很远的 France 的上下文的。这说明相关信息和当前预测位置之间的间隔就肯定变得相当的大。<br>    不幸的是，在这个间隔不断增大时，RNN 会丧失学习到连接如此远的信息的能力。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-7cf6762040d5918c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>相当长的相关信息和位置间隔*</p><p>​    在理论上，RNN 绝对可以处理这样的 长期依赖 问题。人们可以仔细挑选参数来解决这类问题中的最初级形式，但在实践中，RNN 肯定不能够成功学习到这些知识。<a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf" target="_blank" rel="noopener">Bengio, et al. (1994)</a>等人对该问题进行了深入的研究，他们发现一些使训练 RNN 变得非常困难的相当根本的原因。<br>    然而，幸运的是，LSTM 并没有这个问题！</p><h2 id="LSTM-网络"><a href="#LSTM-网络" class="headerlink" title="LSTM 网络"></a>LSTM 网络</h2><p>​    Long Short Term Memory 网络—— 一般就叫做 LSTM ——是一种 RNN 特殊的类型，可以学习长期依赖信息。LSTM 由<a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber (1997)</a>提出，并在近期被<a href="https://scholar.google.com/citations?user=DaFHynwAAAAJ&amp;hl=en" target="_blank" rel="noopener">Alex Graves</a>进行了改良和推广。在很多问题，LSTM 都取得相当巨大的成功，并得到了广泛的使用。<br>    LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力！<br>    所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-13bc1a955ebc6668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>标准 RNN 中的重复模块包含单一的层</em></p><p>​    LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于 单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-421311f51e09bc2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>LSTM 中的重复模块包含四个交互的层</em></p><p>​    不必担心这里的细节。我们会一步一步地剖析 LSTM 解析图。现在，我们先来熟悉一下图中使用的各种元素的图标。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a7fd4db3a625cbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>LSTM 中的图标</em></p><p>​    在上面的图例中，每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表 pointwise 的操作，诸如向量的和，而黄色的矩阵就是学习到的神经网络层。合在一起的线表示向量的连接，分开的线表示内容被复制，然后分发到不同的位置。</p><h2 id="LSTM-的核心思想"><a href="#LSTM-的核心思想" class="headerlink" title="LSTM 的核心思想"></a>LSTM 的核心思想</h2><p>​    LSTM 的关键就是细胞状态，水平线在图上方贯穿运行。<br>    细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-cac54fa82daf1acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 sigmoid 神经网络层和一个 pointwise 乘法操作(向量或者矩阵的pointwise 乘法指按元素相乘,点乘（不改变向量长度、大小）</p><p>a = [a1 a2 a3]</p><p>b = [b1 b2 b3]</p><p>a和b的pointwise product</p><p>a • b = a1<strong><em>b1+a2\</em></strong>b2+a3*b3 )。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-faccc7bf241aa8b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    Sigmoid 层输出 0 到 1 之间的数值，描述每个部分有多少量可以通过。0 代表“不许任何量通过”，1 就指“允许任意量通过”！</p><p>​    LSTM 拥有三个门，来保护和控制细胞状态。这三个门分别输入门、遗忘门和输出门。 LSTM通过三个这样的本结构来实现信息的保护和控制。</p><h2 id="逐步理解LSTM"><a href="#逐步理解LSTM" class="headerlink" title="逐步理解LSTM"></a>逐步理解LSTM</h2><p>现在我们就开始通过三个门逐步的了解LSTM的原理</p><h3 id="遗忘门"><a href="#遗忘门" class="headerlink" title="遗忘门"></a>遗忘门</h3><p>​    在我们 LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为<strong>忘记门层</strong>完成。该门会读取<code>h_{t-1}</code>和<code>x_t</code>，输出一个在 0 到 1 之间的数值给每个在细胞状态<code>C_{t-1}</code>中的数字。1 表示“完全保留”，0 表示“完全舍弃”。 </p><p>​    让我们回到语言模型的例子中来基于已经看到的预测下一个词。在这个问题中，细胞状态可能包含当前<strong>主语</strong>的性别，因此正确的<strong>代词</strong>可以被选择出来。当我们看到新的<strong>主语</strong>，我们希望忘记旧的<strong>主语</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-06ffb4507903c13d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>决定丢弃信息</em> </p><p>其中ht−1表示的是上一个cell的输出，xt表示的是当前细胞的输入。σ表示sigmod函数。</p><h3 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h3><p>​    下一步是确定什么样的新信息被存放在细胞状态中。这里包含两个部分。第一，sigmoid 层称 “输入门层” 决定什么值我们将要更新。然后，一个 tanh 层创建一个新的候选值向量，C^t，会被加入到状态中。下一步，我们会讲这两个信息来产生对状态的更新。 在我们语言模型的例子中，我们希望增加新的主语的性别到细胞状态中，来替代旧的需要忘记的主语。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0bed48af76b88e10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>确定更新的信息</em> </p><p>​    现在是更新旧细胞状态的时间了，Ct−1更新为Ct。前面的步骤已经决定了将会做什么，我们现在就是实际去完成。</p><p>​    我们把旧状态与ft相乘，丢弃掉我们确定需要丢弃的信息。接着加上it∗C~t。这就是新的候选值，根据我们决定更新每个状态的程度进行变化。</p><p>​    在语言模型的例子中，这就是我们实际根据前面确定的目标，丢弃旧代词的性别信息并添加新的信息的地方。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e18424a8c9c39b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>更新细胞状态</em> </p><h3 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h3><p>​    最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p><p>​    在语言模型的例子中，因为他就看到了一个 <strong>代词</strong>，可能需要输出与一个 <strong>动词 </strong>相关的信息。例如，可能输出是否代词是单数还是负数，这样如果是动词的话，我们也知道动词需要进行的词形变化。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-d5f6c68ccc9245c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>输出信息</em> </p><h2 id="LSTM-的变体"><a href="#LSTM-的变体" class="headerlink" title="LSTM 的变体"></a>LSTM 的变体</h2><p>​    我们到目前为止都还在介绍正常的 LSTM。但是不是所有的 LSTM 都长成一个样子的。实际上，几乎所有包含 LSTM 的论文都采用了微小的变体。差异非常小，但是也值得拿出来讲一下。<br>    其中一个流形的 LSTM 变体，就是由 <a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf" target="_blank" rel="noopener">Gers &amp; Schmidhuber (2000)</a> 提出的，增加了 “peephole connection”。是说，我们让 门层 也会接受细胞状态的输入。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-7e38dcfe1cc7b575.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong><em>peephole 连接</em></strong></p><p>​    上面的图例中，我们增加了 peephole 到每个门上，但是许多论文会加入部分的 peephole 而非所有都加。</p><p>​    另一个变体是通过使用 coupled 忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。我们仅仅会当我们将要输入在当前位置时忘记。我们仅仅输入新的值到那些我们已经忘记旧的信息的那些状态 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6c6982add34f8466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong><em>coupled 忘记门和输入门</em></strong></p><p>​    另一个改动较大的变体是 Gated Recurrent Unit (GRU)，这是由 <a href="http://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">Cho, et al. (2014)</a> 提出。它将忘记门和输入门合成了一个单一的 更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-050d4d229257b73f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中， rt表示重置门，zt表示更新门。重置门决定是否将之前的状态忘记。(作用相当于合并了 LSTM 中的遗忘门和传入门）当rt趋于0的时候，前一个时刻的状态信息ht−1会被忘掉，隐藏状态h^t会被重置为当前输入的信息。更新门决定是否要将隐藏状态更新为新的状态h^t（作用相当于 LSTM 中的输出门） 。</p><p>​    和 LSTM 比较一下：<br>- GRU 少一个门，同时少了细胞状态Ct。<br>- 在 LSTM 中，通过遗忘门和传入门控制信息的保留和传入；GRU 则通过重置门来控制是否要保留原来隐藏状态的信息，但是不再限制当前信息的传入。<br>- 在 LSTM 中，虽然得到了新的细胞状态 Ct，但是还不能直接输出，而是需要经过一个过滤的处理:ht=ot∗tanh(Ct)；同样，在 GRU 中, 虽然我们也得到了新的隐藏状态h^t， 但是还不能直接输出，而是通过更新门来控制最后的输出：ht=(1−zt)∗ht−1+zt∗h^t。</p><h2 id="多层LSTM"><a href="#多层LSTM" class="headerlink" title="多层LSTM"></a>多层LSTM</h2><p><strong>多层LSTM是将LSTM进行叠加，其优点是能够在高层更抽象的表达特征，并且减少神经元的个数，增加识别准确率并且降低训练时间。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    LSTM 是我们在 RNN 中获得的重要成功。很自然地，我们也会考虑：哪里会有更加重大的突破呢？在研究人员间普遍的观点是：“Yes! 下一步已经有了——那就是<strong>注意力</strong>！” 这个想法是让 RNN 的每一步都从更加大的信息集中挑选信息。例如，如果你使用 RNN 来产生一个图片的描述，可能会选择图片的一个部分，根据这部分信息来产生输出的词。实际上，<a href="http://arxiv.org/pdf/1502.03044v2.pdf" target="_blank" rel="noopener">Xu, et al.(2015)</a>已经这么做了——如果你希望深入探索<strong>注意力</strong>可能这就是一个有趣的起点！还有一些使用注意力的相当振奋人心的研究成果，看起来有更多的东西亟待探索……<br>    注意力也不是 RNN 研究领域中唯一的发展方向。例如，<a href="http://arxiv.org/pdf/1507.01526v1.pdf" target="_blank" rel="noopener">Kalchbrenner, et al. (2015)</a> 提出的 Grid LSTM 看起来也是很有前途。使用生成模型的 RNN，诸如<a href="http://arxiv.org/pdf/1502.04623.pdf" target="_blank" rel="noopener">Gregor, et al. (2015)</a> <a href="http://arxiv.org/pdf/1506.02216v3.pdf" target="_blank" rel="noopener">Chung, et al. (2015)</a> 和 <a href="http://arxiv.org/pdf/1411.7610v3.pdf" target="_blank" rel="noopener">Bayer &amp; Osendorfer (2015)</a> 提出的模型同样很有趣。在过去几年中，RNN 的研究已经相当的燃，而研究成果当然也会更加丰富！</p><h2 id="LSTM实现手写数字"><a href="#LSTM实现手写数字" class="headerlink" title="LSTM实现手写数字"></a>LSTM实现手写数字</h2><p>这里我们利用的数据集是tensorflow提供的一个手写数字数据集。该数据集是一个包含n张28*28的数据集。</p><h3 id="设置LSTM参数"><a href="#设置LSTM参数" class="headerlink" title="设置LSTM参数"></a>设置LSTM参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.contrib <span class="keyword">import</span> rnn</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration</span></span><br><span class="line"><span class="comment">#                        O * W + b -&gt; 10 labels for each image, O[? 28], W[28 10], B[10]</span></span><br><span class="line"><span class="comment">#                       ^ (O: output 28 vec from 28 vec input)</span></span><br><span class="line"><span class="comment">#                       |</span></span><br><span class="line"><span class="comment">#      +-+  +-+       +--+</span></span><br><span class="line"><span class="comment">#      |1|-&gt;|2|-&gt; ... |28| time_step_size = 28</span></span><br><span class="line"><span class="comment">#      +-+  +-+       +--+</span></span><br><span class="line"><span class="comment">#       ^    ^    ...  ^</span></span><br><span class="line"><span class="comment">#       |    |         |</span></span><br><span class="line"><span class="comment"># img1:[28] [28]  ... [28]</span></span><br><span class="line"><span class="comment"># img2:[28] [28]  ... [28]</span></span><br><span class="line"><span class="comment"># img3:[28] [28]  ... [28]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># img128 or img256 (batch_size or test_size 256)</span></span><br><span class="line"><span class="comment">#      each input size = input_vec_size=lstm_size=28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration variables</span></span><br><span class="line">input_vec_size = lstm_size = <span class="number">28</span> <span class="comment"># 输入向量的维度</span></span><br><span class="line">time_step_size = <span class="number">28</span> <span class="comment"># 循环层长度</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">test_size = <span class="number">256</span></span><br></pre></td></tr></table></figure><p>这里设置将batch_size设置为128，time_step_size表示的是lstm神经元的个数，这里设置为28个，input_vec_size表示一次输入的像素数。 </p><h3 id="初始化权值参数"><a href="#初始化权值参数" class="headerlink" title="初始化权值参数"></a>初始化权值参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.Variable(tf.random_normal(shape, stddev=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X, W, B, lstm_size)</span>:</span></span><br><span class="line">    <span class="comment"># X, input shape: (batch_size, time_step_size, input_vec_size)</span></span><br><span class="line">    <span class="comment"># XT shape: (time_step_size, batch_size, input_vec_size)</span></span><br><span class="line">    <span class="comment">#对这一步操作还不是太理解，为什么需要将第一行和第二行置换</span></span><br><span class="line">    XT = tf.transpose(X, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])  <span class="comment"># permute time_step_size and batch_size,[28, 128, 28]</span></span><br><span class="line">    <span class="comment"># XR shape: (time_step_size * batch_size, input_vec_size)</span></span><br><span class="line">    XR = tf.reshape(XT, [<span class="number">-1</span>, lstm_size]) <span class="comment"># each row has input for each lstm cell (lstm_size=input_vec_size)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Each array shape: (batch_size, input_vec_size)</span></span><br><span class="line">    X_split = tf.split(XR, time_step_size, <span class="number">0</span>) <span class="comment"># split them to time_step_size (28 arrays),shape = [(128, 28),(128, 28)...]</span></span><br><span class="line">    <span class="comment"># Make lstm with lstm_size (each input vector size). num_units=lstm_size; forget_bias=1.0</span></span><br><span class="line">    lstm = rnn.BasicLSTMCell(lstm_size, forget_bias=<span class="number">1.0</span>, state_is_tuple=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get lstm cell output, time_step_size (28) arrays with lstm_size output: (batch_size, lstm_size)</span></span><br><span class="line">    <span class="comment"># rnn..static_rnn()的输出对应于每一个timestep，如果只关心最后一步的输出，取outputs[-1]即可</span></span><br><span class="line">    outputs, _states = rnn.static_rnn(lstm, X_split, dtype=tf.float32)  <span class="comment"># 时间序列上每个Cell的输出:[... shape=(128, 28)..]</span></span><br><span class="line">    <span class="comment"># tanh activation</span></span><br><span class="line">    <span class="comment"># Get the last output</span></span><br><span class="line">    <span class="keyword">return</span> tf.matmul(outputs[<span class="number">-1</span>], W) + B, lstm.state_size <span class="comment"># State size to initialize the state</span></span><br></pre></td></tr></table></figure><p>​    init_weigths函数利用正态分布随机生成参数的初始值，model的四个参数分别为：X为输入的数据，W表示的是28<em>10的权值(标签为0-9)，B表示的是偏置，维度和W一样。这里首先将一批128</em>（28*28）的图片放进神经网络。然后进行相关的操作(注释已经写得很明白了，这里就不再赘述)，然后利用WX+B求出预测结果，同时返回lstm的尺寸</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">py_x, state_size = model(X, W, B, lstm_size)</span><br><span class="line"></span><br><span class="line">cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=py_x, labels=Y))</span><br><span class="line">train_op = tf.train.RMSPropOptimizer(<span class="number">0.001</span>, <span class="number">0.9</span>).minimize(cost)</span><br></pre></td></tr></table></figure><p>然后通过交叉熵计算误差，反复训练得到最优值。 </p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> LSTM </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树表查找</title>
      <link href="/2018/08/23/%E6%A0%91%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
      <url>/2018/08/23/%E6%A0%91%E8%A1%A8%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>​    线性表的查找的顺序查找和折半查找作为查找表的组织形式，其中折半查找效率较高。但由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此当表的插入或删除操作频繁时，为维护表的有序性，需要移动表中很多记录。这种由移动记录引用的额外时间开销，就会抵消折半查找的优点。</p><p>​    所以，线性表的查找更适用于静态查找表，<strong>若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。</strong></p><a id="more"></a><p><strong>一、二叉排序树</strong> </p><p>​        <strong>二叉查找树</strong>（BinarySearch Tree，也叫二叉搜索树，或称<strong>二叉排序树Binary Sort Tree</strong>）或者是一棵空树，或者是具有下列性质的二叉树：</p><p>　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>　　3）任意节点的左、右子树也分别为二叉查找树。</p><p>　　<strong>二叉查找树性质</strong>：<strong>对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p><p>在讨论二叉排序树上的运算之前,定义其节点的类型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">​   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>        //记录类型</span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">KeyType key;            <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;          <span class="comment">//其他数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line"></span><br><span class="line">   &#125; BSTNode;</span><br></pre></td></tr></table></figure></p><p>不同形态的二叉查找树如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3e8f2ba9f32bbc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如下图，这个是普通的二叉树：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e719c23df7ce1943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在此基础上，加上节点之间的大小关系，就是二叉查找树：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b305e8bfd1851c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>1. 二叉排序树上的查找</strong></p><p>因为二叉排序树可看做是一个有序表，所以在二叉排序树上进行查找，和二分查找类似，也是一个逐步缩小查找范围的过程。</p><p>递归查找算法SearchBST()如下（在二叉排序树bt上查找关键字为k的记录,成功时返回该节点指针，否则返回NULL）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span> || bt-&gt;key==k) <span class="comment">//递归终结条件</span></span><br><span class="line">​       <span class="keyword">return</span> bt;</span><br><span class="line">​    <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line"> ​    　 <span class="keyword">return</span> SearchBST(bt-&gt;lchild,k); <span class="comment">//在左子树中递归查找</span></span><br><span class="line"> ​    <span class="keyword">else</span></span><br><span class="line">     　 <span class="keyword">return</span> SearchBST(bt-&gt;rchild,k); <span class="comment">//在右子树中递归查找</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>也可以采用如下非递归算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">SearchBST1</span><span class="params">(BSTNode *bt,KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">while</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (k==bt-&gt;key)</span><br><span class="line">          <span class="keyword">return</span> bt;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line">          bt=bt-&gt;lchild;  <span class="comment">//在左子树中查找</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          bt=bt-&gt;rchild;  <span class="comment">//在左子树中查找</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>                   <span class="comment">//没有找到返回NULL</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. 二叉排序树的插入和生成</strong></p><p>​    在二叉排序树中插入一个关键字为k的新记录，要保证插入后仍满足BST性质。</p><p>插入过程：</p><p>（1）若二叉排序树T为空，则创建一个key域为k的节点，将它作为根节点；</p><p>（2）否则将k和根节点的关键字比较，若两者相等，则说明树中已有此关键字k，无须插入，直接返回0；</p><p>（3）若k 小于T-&gt;key，则将k插入根节点的左子树中。</p><p>（4）否则将它插入右子树中。</p><p>对应的递归算法InsertBST()如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertBST</span><span class="params">(BSTNode *&amp;p,KeyType k)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在以*p为根节点的BST中插入一个关键字为k的节点。插入成功返回1,否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//原树为空, 新插入的记录为根节点</span></span><br><span class="line">   &#123;   p=(BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">       p-&gt;key=k;p-&gt;lchild=p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>  (k==p-&gt;key) <span class="comment">//存在相同关键字的节点,返回0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;p-&gt;key) </span><br><span class="line">      <span class="keyword">return</span> InsertBST(p-&gt;lchild,k);　<span class="comment">//插入到左子树中</span></span><br><span class="line">   <span class="keyword">else</span>  </span><br><span class="line">      <span class="keyword">return</span> InsertBST(p-&gt;rchild,k);  <span class="comment">//插入到右子树中</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p> 插入操作图示如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5b7b81dcdaab7ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>最大最小值</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-27f59ee44dba32d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>二叉排序树的生成</strong>，是从一个空树开始，每插入一个关键字，就调用一次插入算法将它插入到当前已生成的二叉排序树中。</p><p>从关键字数组A[0..n-1]生成二叉排序树的算法CreatBST()如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">CreatBST</span><span class="params">(KeyType A[],<span class="keyword">int</span> n)</span> <span class="comment">//返回树根指针</span></span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">BSTNode *bt=<span class="literal">NULL</span>;    <span class="comment">//初始时bt为空树</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n) </span><br><span class="line">    &#123;  </span><br><span class="line">InsertBST(bt,A[i]);  <span class="comment">//将A[i]插入二叉排序树T中</span></span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;       <span class="comment">//返回建立的二叉排序树的根指针</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>3. 二叉排序树的节点删除</strong></p><p>（1）被删除的节点是叶子节点：<strong>直接删去该节点</strong>。</p><p>（2）被删除的节点只有左子树或者只有右子树，用其<strong>左子树或者右子树代替它</strong>。</p><p>（3）被删除的节点既有左子树，也有右子树：<strong>以其前驱替代之</strong>，然后再删除该前驱节点。前驱是左子树中最大的节点。<strong>也可以用其后继替代之</strong>，然后再删除该后继节点。后继是右子树中最小的节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteBST</span><span class="params">(BSTNode *&amp;bt,KeyType k)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在bt中删除关键字为k的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">if</span> (bt==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树删除失败</span></span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">   &#123; <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> DeleteBST(bt-&gt;lchild,k); <span class="comment">//递归在左子树中删除为k的节点</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;bt-&gt;key)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> DeleteBST(bt-&gt;rchild,k); <span class="comment">//递归在右子树中删除为k的节点</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">     &#123;</span><br><span class="line"> Delete(bt);    <span class="comment">//调用Delete(bt)函数删除*bt节点</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BSTNode *&amp;p)</span>    <span class="comment">//从二叉排序树中删除*p节点</span></span></span><br><span class="line"><span class="function"></span>&#123;  BSTNode *q;</span><br><span class="line">   <span class="keyword">if</span> (p-&gt;rchild==<span class="literal">NULL</span>)      <span class="comment">//*p节点没有右子树的情况</span></span><br><span class="line">   &#123;   q=p; p=p-&gt;lchild;</span><br><span class="line">            <span class="comment">//其右子树的根节点放在被删节点的位置上</span></span><br><span class="line">       <span class="built_in">free</span>(q);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>)    <span class="comment">//*p节点没有左子树</span></span><br><span class="line">   &#123;   q=p; p=p-&gt;rchild;</span><br><span class="line">            <span class="comment">//将*p节点的右子树作为双亲节点的相应子树/</span></span><br><span class="line">       <span class="built_in">free</span>(q);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> Delete1(p,p-&gt;lchild);</span><br><span class="line">           <span class="comment">//*p节点既没有左子树又没有右子树的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除二叉排序树节点的算法DeleteBST()如下（指针变量p指向待删除的节点，指针变量q指向待删除节点*p的双亲节点）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete1</span><span class="params">(BSTNode *p,BSTNode *&amp;r)</span></span></span><br><span class="line"><span class="function">  <span class="comment">//当被删*p节点有左右子树时的删除过程</span></span></span><br><span class="line"><span class="function">  </span>&#123;  BSTNode *q;</span><br><span class="line">     <span class="keyword">if</span> (r-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">   Delete1(p,r-&gt;rchild);<span class="comment">//递归找最右下节点</span></span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//找到了最右下节点*r</span></span><br><span class="line">     &#123;   p-&gt;key=r-&gt;key;            <span class="comment">//将*r的关键字值赋给*p</span></span><br><span class="line">   q=r; r=r-&gt;lchild;</span><br><span class="line">           <span class="comment">//将左子树的根节点放在被删节点的位置上</span></span><br><span class="line">   <span class="built_in">free</span>(q); <span class="comment">//释放原*r的空间</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>  当删除的节点有2个子节点时，问题就变复杂了。</p><p>​    假设我们删除的节点t具有两个子节点。因为t具有右子节点，所以我们需要找到其右子节点中的最小节点，替换t节点的位置。这里有四个步骤：</p><ol><li>保存带删除的节点到临时变量t</li><li>将t的右节点的最小节点min(t.right)保存到临时节点x</li><li>将x的右节点设置为deleteMin(t.right)，该右节点是删除后，所有比x.key最大的节点。</li><li>将x的做节点设置为t的左节点。</li></ol><p>整个过程如下图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f43822ca7e9c93e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>分析</strong></p><p>​    二叉查找树的运行时间和树的形状有关，树的形状又和插入元素的顺序有关。在最好的情况下，节点完全平衡，从根节点到最底层叶子节点只有lgN个节点。在最差的情况下，根节点到最底层叶子节点会有N各节点。在一般情况下，树的形状和最好的情况接近。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3c78991c7658a11d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    在分析二叉查找树的时候，我们通常会假设插入的元素顺序是随机的。对BST的分析类似与快速排序中的查找。</p><p><strong>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</strong></p><p>　　下图为二叉树查找和顺序查找以及二分查找性能的对比图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dd064ab9226e60e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>二、平衡二叉树(AVL)</strong></p><p>​    若一棵二叉树中每个节点的左、右子树的高度至多相差1，则称此二叉树为平衡二叉树。</p><p>​    在算法中，通过平衡因子（balancd factor，用bf表示）来具体实现上述平衡二叉树的定义。</p><p>​    平衡因子：平衡二叉树中每个节点有一个平衡因子域，每个节点的平衡因子是该节点左子树的高度减去右子树的高度。从平衡因子的角度可以说，若一棵二叉树中所有节点的平衡因子的绝对值小于或等于1，即<strong>平衡因子取值为1、0或-1</strong>，则该二叉树称为平衡二叉树。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-613b10b01cdb4d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义AVL树的节点的类型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>     //记录类型</span></span><br><span class="line"><span class="class">&#123;</span>　KeyType key;    <span class="comment">//关键字项</span></span><br><span class="line">   <span class="keyword">int</span> bf;<span class="comment">//增加的平衡因子</span></span><br><span class="line">   InfoType data;     <span class="comment">//其他数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 树表查找，二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见查找算法总结</title>
      <link href="/2018/08/22/%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/22/%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>阅读目录</p><ol><li>顺序查找</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li><li>树表查找</li><li>分块查找</li><li>哈希查找</li></ol><a id="more"></a><p>​    查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。</p><p>　　<strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><p>　　<strong>查找算法分类：</strong></p><p>　　1）静态查找和动态查找；</p><p>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</p><p>　　2）无序查找和有序查找。</p><p>　　　　无序查找：被查找数列有序无序均可；</p><p>　　　　有序查找：被查找数列必须为有序数列。</p><p>　　<strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>　　Pi：查找表中第i个数据元素的概率。<br>　　Ci：找到第i个数据元素时已经比较过的次数。</p><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p>　　<strong>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</strong></p><p>　　<strong>基本思想：</strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p>　　<strong>复杂度分析：</strong>　</p><p>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p><p>　　所以，<strong>顺序查找的时间复杂度为O(n)。</strong></p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequence_Search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sequence_Search</span><span class="params">(nums, target)</span>:</span>   </span><br><span class="line">     <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):     </span><br><span class="line">        <span class="keyword">if</span> nums[i]==target:          </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="2-二分查找-折半查找"><a href="#2-二分查找-折半查找" class="headerlink" title="2. 二分查找/折半查找"></a>2. 二分查找/折半查找</h3><p>　　<strong>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p><p>　　<strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p>　　<strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且<strong>期望时间复杂度为O(log2n)</strong>；</p><p>　　注：<strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要</strong>频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找（折半查找），非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2） python版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----------------递归二分查找------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_Search</span><span class="params">(nums,target,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    mid=(left+right)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="keyword">return</span> binary_Search(nums, target, left, mid<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> binary_Search(nums, target, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    low=<span class="number">0</span></span><br><span class="line">    high=len(list)<span class="number">-1</span></span><br><span class="line">    result = binary_Search(list,<span class="number">444</span>,low,high)</span><br><span class="line">    print(result)</span><br><span class="line"><span class="comment">#-------------------非递归查找------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_Search</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low+high)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    result = binary_Search(list,<span class="number">444</span>)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure></p><p>​    时间复杂度分析    最坏情况下，关键词比较次数为⌊log2n⌋+1，最好情况就是1，所以二分查找的时间复杂度为O(logn)。它显然好于顺序查找的O(n)。 </p><h3 id="3-插值查找"><a href="#3-插值查找" class="headerlink" title="3. 插值查找"></a>3. 插值查找</h3><p>　　在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p><p>　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p><p>　　同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p><p>　　经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p><p>　　mid=(low+high)/2, 即mid=low+1/2*(high-low);</p><p>　　通过类比，我们可以将查找的点改进为如下：</p><p>　　mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，</p><p>　　也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p><p>　　<strong>基本思想：</strong>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p><p>　　注：<strong>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</strong></p><p>　　<strong>复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</strong></p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）python代码 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插值查找算法</span></span><br><span class="line"><span class="comment"># 时间复杂度O(log(n))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_search</span><span class="params">(lis, key)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(lis) - <span class="number">1</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        time += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">        mid = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">        print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (mid, low, high))</span><br><span class="line">        <span class="keyword">if</span> key &lt; lis[mid]:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &gt; lis[mid]:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 打印查找的次数</span></span><br><span class="line">            print(<span class="string">"times: %s"</span> % time)</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    print(<span class="string">"times: %s"</span> % time)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    result = insert_search(LIST, <span class="number">444</span>)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>​    时间复杂度分析    </p><p>​    它的时间复杂度跟二分查找的时间复杂度一样，为O(logn)。需要注意的是对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 </p><h3 id="4-斐波那契查找"><a href="#4-斐波那契查找" class="headerlink" title="4. 斐波那契查找"></a>4. 斐波那契查找</h3><p>　　在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</p><p>　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p><p>　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</p><p>　　大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b0cb1d3f2022502c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>基本思想：</strong>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p><p>　　相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1;</p><p>​    3）&lt;，high=mid-1。</p><p>　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p><p> 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1,k-=2;</p><p>　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</p><p>　　3）&lt;，high=mid-1,k-=1。</p><p>　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p><p>　　<strong>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</strong></p><p>（1）C++实现 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契查找</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> * F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> F[max_size];</span><br><span class="line">  Fibonacci(F);<span class="comment">//构造一个斐波那契数组F </span></span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">      ++k;</span><br><span class="line">  <span class="keyword">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></span><br><span class="line">  temp=<span class="keyword">new</span> <span class="keyword">int</span> [F[k]<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</span><br><span class="line">     temp[i]=a[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid<span class="number">-1</span>;</span><br><span class="line">      k-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+<span class="number">1</span>;</span><br><span class="line">     k-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(mid&lt;n)</span><br><span class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">delete</span> [] temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> index=FibonacciSearch(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),key);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">" is located at:"</span>&lt;&lt;index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#source为待查找数组，key为要查找的数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacciSearch</span><span class="params">(source,key)</span>:</span></span><br><span class="line">    <span class="comment">#生成裴波那契数列</span></span><br><span class="line">    fib = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">36</span>):</span><br><span class="line">        fib.append(fib[<span class="number">-1</span>]+fib[<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#确定待查找数组在裴波那契数列的位置</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    n = len(source)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#此处 n&gt;fib[k]-1 也是别有深意的</span></span><br><span class="line">    <span class="comment">#若n恰好是裴波那契数列上某一项，且要查找的元素正好在最后一位，此时必须将数组长度填充到数列下一项的数字</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; fib[k]<span class="number">-1</span>):</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="comment">#将待查找数组填充到指定的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n,fib[k]):</span><br><span class="line">        a.append(a[<span class="number">-1</span>])</span><br><span class="line">    low,high = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">        <span class="comment">#获取黄金分割位置元素下标</span></span><br><span class="line">        mid = low + fib[k<span class="number">-1</span>] - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span>(key &lt; a[mid]):</span><br><span class="line">            <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">            k = k <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span>(key &gt; a[mid]):</span><br><span class="line">            <span class="comment">#若key比这个元素大,则key至应该在mid+1至high之间，剩下的元素个数为F(k)-F(k-1)-1=F(k-2)-1</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">            k = k - <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; n):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 函数测试 ###</span></span><br><span class="line"><span class="comment">#生成待查找的数组</span></span><br><span class="line">a = [random.randint(<span class="number">1</span>,<span class="number">100000</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">33</span>)]</span><br><span class="line">a.append(<span class="number">673990</span>)</span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment">#待查找的数</span></span><br><span class="line">key = <span class="number">673990</span></span><br><span class="line"><span class="comment">#输出查找到的位置下标</span></span><br><span class="line">print(fibonacciSearch(a,key))</span><br></pre></td></tr></table></figure></p><p> 时间复杂度分析    </p><p>​    斐波那契查找的整体时间复杂度也为O(log(n))。但就平均性能，要优于二分查找。但是在最坏情况下，比如这里如果key为1，则始终处于左侧半区查找，此时其效率要低于二分查找。 </p><ul><li><p><strong>总结  </strong>  </p><p>​    二分查找的mid运算是加法与除法，插值查找则是复杂的四则运算，而斐波那契查找只是最简单的加减运算。在海量数据的查找中，这种细微的差别可能会影响最终的查找效率。因此，三种有序表的查找方法本质上是分割点的选择不同，各有优劣，应根据实际情况进行选择。 </p></li></ul><h3 id="5-树表查找"><a href="#5-树表查找" class="headerlink" title="5. 树表查找"></a><strong>5. 树表查找</strong></h3><h3 id="6-线性索引查找"><a href="#6-线性索引查找" class="headerlink" title="6. 线性索引查找"></a><strong>6. 线性索引查找</strong></h3><p><strong>6.1 简介</strong>    </p><p>​    前面讲的几种比较高效的查找方法是基于有序的基础之上的，而事实上，数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据都是按先后顺序存储的。    </p><p>​    对于这样的查找表，我们如何能够快速查找到需要的数据呢？常常使用的方法就是—-<strong>索引</strong>。<strong>索引是为了加快查找速度而设计的一种数据结构。</strong>它是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。    </p><p>​    索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三个线性索引：稠密索引、分块索引、和倒排索引。 </p><p><strong>6.2 稠密索引 </strong></p><p>​    稠密索引如下图所示，它是指在线性索引中，将数据集中的每个记录对应一个索引项。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b3fda93316d6cb9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    上图中，左边的图像为索引序列，它是是按照关键码有序排列的。索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高效率。比如查找上表中的18。如果不用索引表，需要6次。而用左侧的索引表，折半两次就可以找到18对应的指针。    </p><p>​    这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。  </p><p><strong>6.3 分块索引 </strong>   </p><p>​    稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引的个数，我们可以<strong>对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 </strong></p><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 　　</p><p><strong>算法思想：</strong>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 　　</p><p><strong>算法流程：</strong> 　　<br>step1 先选取各块中的最大关键字构成一个索引表； 　　<br>step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><p>​    分块有序，是把数据集的记录分成若干块，并且这些块需要满足两个条件：    </p><p>​    （1）块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间代价，因此通常我们不要求块内有序    <br>​    （2）块间有序，例如要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字….因为只有块间有序，才有可能在查找时带来效率。   <br> <br>    对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。我们定义的分块索引项由三个数据项组成，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-639d103f90fa4d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    这三个数据项分别为最大关键码（它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中最小关键字也能比这一块最大的关键字要大）、存储了块中的记录个数（以便于循环时使用）和指向块首数据元素的指针（便于开始对这一块中的记录进行遍历）。   </p><p>​    由上面的分析我们可以大概明白分块索引的步骤：    </p><p>​    （1）在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。    </p><p>​    （2） 根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查获。  </p><p><strong>6.4 倒排索引 </strong></p><p>​    不知道你对搜索引擎好奇过没，无论你查找什么样的信息，它都可以在极短的时间内给你一些结果，是什么算法技术达到这样的高效查找呢？这里介绍一种最基础的搜索技术—-倒排索引。    </p><p>​    我们来看一个例子，假设有以下两篇文章：    </p><p>​    (1) Books and friends should be few but good .    </p><p>​    (2) A good book is a good friend.    </p><p>​    假设我们忽略掉如“books”，“friends”中的复数”s”以及如“A”这样的大小写差异。我们可以整理出这样一张单词表，如下图所示，并将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中，比如“good”它在两篇文章中都有出现，而is只有在文章2中才有。  </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6a8b0164b26616ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    在这里这张单词表就是索引表，索引项的通用结构是次关键码和记录号表。 其中记录号表存储具有相同次字关键字的所有记录的记录号（可以指向记录的指针或者是该记录的主关键字）。因为这种查找方法是通过属性值来确定记录的位置，而不是通过记录来确定属性值，所以我们称其为倒排索引。 </p><p>​    </p><h3 id="7-哈希查找"><a href="#7-哈希查找" class="headerlink" title="7. 哈希查找"></a>7. 哈希查找</h3><p>　　<strong>什么是哈希表（Hash）？</strong></p><p>​    散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>    给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>    中文名  哈希表 </p><p>​    外文名  Hash table </p><p>​    别    名 散列表 </p><p>​    作    用  直接进行访问的数据结构</p><p>　　我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f71ff9ef346899db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　<strong>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</strong></p><p>　　<strong>什么是哈希函数？</strong></p><p>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p><p>　　<strong>算法思想：</strong>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><p>　　<strong>算法流程：</strong></p><p>　　1）用给定的哈希函数构造哈希表；</p><p>　　2）根据选择的冲突处理方法解决地址冲突；</p><p>　　　　常见的解决冲突的方法：拉链法和线性探测法。</p><p>　　3）在哈希表的基础上执行哈希查找。</p><p>　　<strong>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</strong></p><p>　　<strong>复杂度分析</strong>：</p><p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><p>　　<strong>使用Hash，我们付出了什么？</strong><br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV(key value) pair，经常使用Python可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？</p><p>　　Hash是一种典型<strong>以空间换时间</strong>的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p><p>　　Hash算法和其他查找算法的性能对比：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4fad334deb8aaa01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>10大经典排序算法总结</title>
      <link href="/2018/08/21/10%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/21/10%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h3><h4 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h4><p>①：十种常见排序算法可以分为两大类：</p><blockquote><p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d74f1bf29b3a2413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></blockquote><p>②：另外一种分类排序方法——我们通常所说的排序算法往往指的是<strong>内部排序算法</strong>，即数据记录在内存中进行排序。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-006deb9355dbd7e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　排序算法大体可分为两种：</p><p>　　　　一种是<strong>比较排序</strong>，时间复杂度O(nlogn) ~ O(n^2)，主要有：<strong>冒泡排序</strong>，<strong>选择排序</strong>，<strong>插入排序</strong>，<strong>归并排序</strong>，<strong>堆排序</strong>，<strong>快速排序</strong>等。</p><p>　　　　另一种是<strong>非比较排序</strong>，时间复杂度可以达到O(n)，主要有：<strong>计数排序</strong>，<strong>基数排序</strong>，<strong>桶排序</strong>等。</p><h4 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fc56705ae801148b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h4><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p><p><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p></blockquote><p>​    </p><p>​    对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p><p>　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p><p>　　其次，说一下排序算法稳定性的好处。<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</strong>基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p><h4 id="0-4-技巧"><a href="#0-4-技巧" class="headerlink" title="0.4 技巧"></a>0.4 技巧</h4><p>记忆<strong>口诀</strong>：</p><p><strong>不稳定</strong>排序算法口诀：<strong>快些选队（快希选堆）</strong><br>其余为稳定的。</p><p><strong>算法复杂度和关键字顺序无关的有：</strong></p><p>顺口溜：<strong>一堆</strong>（堆排序）<strong>海龟</strong>（归并排序）<strong>选</strong>（选择排序）<strong>基</strong>（基数排序）<strong>友</strong></p><p>快些以 nlog2 n  的速度归队</p><p>快=快速排序，些=希尔排序，归=归并排序，队=堆排序</p><p>这四种排序算法，时间都是 n log2 n 的，除了这四个之外，其他的排序算法平均时间都为 n^2</p><blockquote><p>一趟排序，保证一个元素为最终位置的有两类排序算法：<strong>交换</strong>类（冒泡和快速）排序和<strong>选择</strong>类排序（简单和堆）</p><p>元素比较次数和<strong>原始序列无关</strong>的算法：<strong>简单选择</strong>排序，<strong>折半插入</strong>排序</p><p>排序趟数和原序列有关的算法：<strong>交换类</strong>，其余类无关</p><p>借助于比较进行排序的算法，在最坏的时候，最好的时间复杂度为 n log2 n</p><p>堆排序和简单选择排序的时间复杂度和初始序列无关</p></blockquote><h4 id="0-5-总结："><a href="#0-5-总结：" class="headerlink" title="0.5 总结："></a>0.5 总结：</h4><p>（1）在比较类排序中，<strong>归并排序</strong>号称最快，其次是<strong>快速排序</strong>和<strong>堆排序</strong>，两者不相伯仲，但是有一点需要注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。</p><p>（2）<strong>线性时间非比较类排序</strong>一般要优于非线性时间比较类排序，但前者对待排序元素的要求较为严格，比如计数排序要求待排序数的最大值不能太大，桶排序要求元素按照hash分桶后桶内元素的数量要均匀。线性时间非比较类排序的典型特点是以空间换时间。</p><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-b05dac2a52600907.gif?imageMogr2/auto-orient/strip" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-ee6aeca39cd369d7.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(RecordType arr[])</span> </span>&#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    change = TRUE;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; len - <span class="number">1</span> &amp;&amp; change; i++) &#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        <span class="keyword">for</span> (var j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;<span class="comment">// 依次比较相邻的两个元素,使较大的那个向后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j].key &gt; arr[j+<span class="number">1</span>].key) &#123; <span class="comment">// 相邻元素两两对比。  如果条件改成arr[j].key &gt;= arr[j+1].key,则变为不稳定的排序算法</span></span><br><span class="line">                var temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                change = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    假如说上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序，则实现过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dfc34c06eb7f0c29.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    使用冒泡排序为一列数字进行排序的过程如右图所示:<img src="https://upload-images.jianshu.io/upload_images/12654931-561723951d8105b0.gif?imageMogr2/auto-orient/strip" alt=""></p><p>尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。</p><h3 id="1-1、冒泡排序的改进：鸡尾酒排序（定向-双向冒泡排序）"><a href="#1-1、冒泡排序的改进：鸡尾酒排序（定向-双向冒泡排序）" class="headerlink" title="1.1、冒泡排序的改进：鸡尾酒排序（定向/双向冒泡排序）"></a>1.1、冒泡排序的改进：鸡尾酒排序（定向/双向冒泡排序）</h3><p>​    鸡尾酒排序，也叫<strong>定向冒泡排序</strong>，是冒泡排序的一种改进，即排序过程中交替改变扫描方向。<br>    先从底向上冒一个最小元素，再从上向低冒一个最大元素。<br>    此算法与冒泡排序的不同处在于<strong>从低到高然后从高到低</strong>，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</p><p>　　鸡尾酒排序的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;    <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = TRUE;</span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = FLASE;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)   <span class="comment">// 前半轮,从左到右扫描，将最大元素放到最右边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i, i + <span class="number">1</span>);</span><br><span class="line">flag = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--)   <span class="comment">// 后半轮,从右到左扫描,将最小元素放到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i - <span class="number">1</span>, i);</span><br><span class="line">                flag = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;   <span class="comment">// 从小到大定向冒泡排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    CocktailSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"鸡尾酒排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用鸡尾酒排序为一列数字进行排序的过程如右图所示：　<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8f1eec1a3a56306b.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p><h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-d342a82e64a688f7.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)         <span class="comment">// i为已排序序列的末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)     <span class="comment">// 未排序序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])              <span class="comment">// 找出未排序序列中的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, min, i);    <span class="comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span> &#125;; <span class="comment">// 从小到大选择排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    SelectionSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"选择排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图:<img src="https://upload-images.jianshu.io/upload_images/12654931-5cb815f3948e9fac.gif?imageMogr2/auto-orient/strip" alt=""></p><p>使用选择排序为一列数字进行排序的宏观过程：　<img src="https://upload-images.jianshu.io/upload_images/12654931-d75968339d73d7f4.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</strong></p><p>　　比如序列：{ <strong>5</strong>, 8, <strong>5</strong>, <strong>2</strong>, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p><h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>​    插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。它的工作原理非常类似于我们抓扑克牌 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6604e5ddad02bbb9.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p><p>　　插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-50e91fd39b1ef7b8.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)         <span class="comment">// 类似抓扑克牌排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 拿在左手上的牌总是排序好的</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)    <span class="comment">// 将抓到的牌与手牌从右向左进行比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];            <span class="comment">// 如果该手牌比抓到的牌大，就将其右移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get; <span class="comment">// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;<span class="comment">// 从小到大插入排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    InsertionSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下<br><img src="https://upload-images.jianshu.io/upload_images/12654931-877826e57ce08dd3.gif?imageMogr2/auto-orient/strip" alt="">　　　　</p><p>　　使用插入排序为一列数字进行排序的宏观过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-26ffc967098b75c3.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　插入排序<strong>不适合对于数据量比较大的排序应用</strong>。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p><h3 id="3-1、插入排序的改进：二分插入排序"><a href="#3-1、插入排序的改进：二分插入排序" class="headerlink" title="3.1、插入排序的改进：二分插入排序"></a>3.1、插入排序的改进：二分插入排序</h3><p>​    对于插入排序，如果比较操作的代价比交换操作大的话，可以采用<strong>二分查找法</strong>来减少比较操作的次数，我们称为<strong>二分插入排序</strong>，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                    <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;                <span class="comment">// 手牌左右边界进行初始化</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; get)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[left] = get;                    <span class="comment">// 将抓到的牌插入手牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大二分插入排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    InsertionSortDichotomy(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二分插入排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p><h3 id="4、希尔排序（Shell-Sort）-插入排序的更高效改进"><a href="#4、希尔排序（Shell-Sort）-插入排序的更高效改进" class="headerlink" title="4、希尔排序（Shell Sort）-插入排序的更高效改进"></a>4、希尔排序（Shell Sort）-插入排序的更高效改进</h3><p>​    1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>递减增量排序</strong>。希尔排序是<strong>不稳定</strong>的排序算法。 </p><p>​    希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-447cc5d14ac11f21.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-4d822a983a919056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= n)   <span class="comment">// 生成初始增量</span></span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - h;</span><br><span class="line">            <span class="keyword">int</span> get = A[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)</span><br><span class="line">            &#123;</span><br><span class="line">                A[j + h] = A[j];</span><br><span class="line">                j = j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + h] = get;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;   <span class="comment">// 递减增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    ShellSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"希尔排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>以23, 10, 4, 1的步长序列进行希尔排序：<img src="https://upload-images.jianshu.io/upload_images/12654931-b7107d90df31827c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>希尔排序是不稳定的排序算法，</strong>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。</p><p>　　比如序列：{ 3, 5, 10, <strong>8</strong>, 7, 2, <strong>8</strong>, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, <strong>8</strong>, 20 } 和  { 5, <strong>8</strong>, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, <strong>8</strong>, 10, 20 } 和 { 1, 2, 5, 6, <strong>8</strong> } ，即 { 3, 1, 7, 2, <strong>8</strong>, 5, 10, 6, 20, <strong>8</strong> } ，两个8的相对次序发生了改变。    </p><p>​    希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><p>​    归并排序的实现分为<strong>递归实现</strong>与<strong>非递归(迭代)实现</strong>。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。</p><p>　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，<strong>归并操作</strong>步骤如下：</p><ol><li><strong>申请空间</strong>，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2a2beb4de1e6acdd.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5ab9457322e8103c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><span class="comment">// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];       <span class="comment">// 辅助空间O(n)</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left;                   <span class="comment">// 前一数组的起始元素</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;                <span class="comment">// 后一数组的起始元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++];  <span class="comment">// 带等号保证归并排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)  <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)  <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[left++] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursion</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>    <span class="comment">// 递归实现的归并排序(自顶向下)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right)    <span class="comment">// 当待排序的序列长度为1时，递归开始回溯，进行merge操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    MergeSortRecursion(A, left, mid);</span><br><span class="line">    MergeSortRecursion(A, mid + <span class="number">1</span>, right);</span><br><span class="line">    Merge(A, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span>    <span class="comment">// 非递归(迭代)实现的归并排序(自底向上)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, mid, right;<span class="comment">// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)        <span class="comment">// 子数组的大小i初始为1，每轮翻倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + i &lt; len)              <span class="comment">// 后一个子数组存在(需要归并)</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + i - <span class="number">1</span>;</span><br><span class="line">            right = mid + i &lt; len ? mid + i : len - <span class="number">1</span>;<span class="comment">// 后一个子数组大小可能不够</span></span><br><span class="line">            Merge(A, left, mid, right);</span><br><span class="line">            left = right + <span class="number">1</span>;               <span class="comment">// 前一个子数组索引向后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A1[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;      <span class="comment">// 从小到大归并排序</span></span><br><span class="line">    <span class="keyword">int</span> A2[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="keyword">sizeof</span>(A1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="keyword">sizeof</span>(A2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    MergeSortRecursion(A1, <span class="number">0</span>, n1 - <span class="number">1</span>);          <span class="comment">// 递归实现</span></span><br><span class="line">    MergeSortIteration(A2, n2);                 <span class="comment">// 非递归实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"递归实现的归并排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"非递归实现的归并排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下　<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e11598fb16f7f974.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　使用归并排序为一列数字进行排序的宏观过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-7d7eedbdc4d069fb.gif?imageMogr2/auto-orient/strip" alt="">　　　</p><p>　　归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对。</p><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>​    快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>​    选择一个基准，小于放左边，大于放右边。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-36a8debf59ae72e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    上图是每次将基准交换。</p><p>​    或者如下，最后再将基准交换。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-911998967362a076.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b636bd935bdaad63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（<strong>请自己想一想为什么</strong>）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-ce981ae61870643f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-da606f1c2f2ff958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p><p>​    6  1  2  <strong>5</strong>  9 3  4  <strong>7</strong>  10  8<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f2d90739a4b43360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3ca3d01aacd4865f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p><p>6  1  2 5  <strong>4</strong>  3  <strong>9</strong>  7 10  8</p><p>​    第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：</p><p><strong>3</strong>  1 2  5  4  <strong>6</strong>  9 7  10  8</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe14873d59f52f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-546ac3dfcf16c905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-ab5bf0dbddeb3081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。 </p><p><strong>注：最好的是设置一个临时变量，做覆盖操作而不是一直做交换操作。</strong></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------ 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       </span></span><br><span class="line"><span class="comment">// 稳定性 ---------- 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">// 划分函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[right];               <span class="comment">// 这里每次都选择最后一个元素作为基准</span></span><br><span class="line">    <span class="keyword">int</span> tail = left - <span class="number">1</span>;                <span class="comment">// tail为小于基准的子数组最后一个元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)  <span class="comment">// 遍历基准以外的其他元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= pivot)              <span class="comment">// 把小于等于基准的元素放到前一个子数组末尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, ++tail, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(A, tail + <span class="number">1</span>, right);           <span class="comment">// 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组</span></span><br><span class="line">                                        <span class="comment">// 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</span></span><br><span class="line">    <span class="keyword">return</span> tail + <span class="number">1</span>;                    <span class="comment">// 返回基准的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot_index = Partition(A, left, right); <span class="comment">// 基准的索引</span></span><br><span class="line">    QuickSort(A, left, pivot_index - <span class="number">1</span>);</span><br><span class="line">    QuickSort(A, pivot_index + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;; <span class="comment">// 从小到大快速排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"快速排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用快速排序法对一列数字进行排序的过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-865ae2a394b9cdbe.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong></p><p>　　比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p><blockquote><p>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？</p></blockquote><p>　　答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 </p><h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>​    堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-c45011903132bb45.gif?imageMogr2/auto-orient/strip" alt=""></p><p><strong>构建初始堆</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-e4276f7e11ad285d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>整体排序流程</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d926646825213d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span>  <span class="comment">// 从A[i]向下进行堆调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;         <span class="comment">// 左孩子索引</span></span><br><span class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;        <span class="comment">// 右孩子索引</span></span><br><span class="line">    <span class="keyword">int</span> max = i;                        <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max])</span><br><span class="line">        max = left_child;</span><br><span class="line">    <span class="keyword">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max])</span><br><span class="line">        max = right_child;</span><br><span class="line">    <span class="keyword">if</span> (max != i)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(A, i, max);                <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></span><br><span class="line">        Heapify(A, max, size);          <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>           <span class="comment">// 建堆，时间复杂度O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></span><br><span class="line">Heapify(A, i, heap_size);</span><br><span class="line">    <span class="keyword">return</span> heap_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);    <span class="comment">// 建立一个最大堆</span></span><br><span class="line">    <span class="keyword">while</span> (heap_size &gt; <span class="number">1</span>)    　　　　　　 <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></span><br><span class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></span><br><span class="line">        Swap(A, <span class="number">0</span>, --heap_size);</span><br><span class="line">        Heapify(A, <span class="number">0</span>, heap_size);     <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大堆排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序算法的演示：<img src="https://upload-images.jianshu.io/upload_images/12654931-181d10fdf3848485.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。</p><p>　　<strong>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</strong></p><p>　　比如序列：{ 9, <strong>5</strong>, 7, <strong>5</strong> }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { <strong>5</strong>, <strong>5</strong>, 7, 9 }，再进行堆调整得到{ 7, <strong>5</strong>, <strong>5</strong>, 9 }，重复之前的操作最后得到{ <strong>5</strong>, <strong>5</strong>, 7, 9 }从而改变了两个5的相对次序。</p><hr><p>以上为比较排序。</p><p>以下为非比较排序。</p><hr><h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>​    计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>​    通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-eca87818bb0a14c5.gif?imageMogr2/auto-orient/strip" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------ 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + k)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">100</span>;   <span class="comment">// 基数为100，排序[0,99]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];            <span class="comment">// 计数数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)   <span class="comment">// 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 使C[i]保存着等于i的元素个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)   <span class="comment">// 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">// 分配临时空间,长度为n，用来暂存中间数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        B[--C[A[i]]] = A[i];      <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                  <span class="comment">// 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 把临时空间B中的数据拷贝回A</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);    <span class="comment">// 释放临时空间 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">15</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">46</span>, <span class="number">27</span>, <span class="number">73</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">8</span> &#125;;  <span class="comment">// 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    CountingSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"计数排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此<strong>对于数据范围很大的数组，计数排序需要大量时间和内存。</strong></p><p>　　例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，<strong>将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。</strong></p><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>​    计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>​    桶排序也叫箱排序。桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。 </p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-d3e2e9d08a403961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)，每个元素占一个桶</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + bn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本程序用数组模拟桶 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bn = <span class="number">5</span>;    <span class="comment">// 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量</span></span><br><span class="line"><span class="keyword">int</span> C[bn];           <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++)  <span class="comment">// 从第二张牌开始抓，直到最后一张牌</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; A[j] &gt; get)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">10</span>;    <span class="comment">// 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)     <span class="comment">// 使C[i]保存着i号桶中元素的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[MapToBucket(A[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bn; i++)    <span class="comment">// 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = MapToBucket(A[i]);  <span class="comment">// 元素A[i]位于b号桶</span></span><br><span class="line">        B[--C[b]] = A[i];           <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                    <span class="comment">// 桶的边界被更新：C[b]为b号桶第一个元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CountingSort(A, n);          <span class="comment">// 利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++) <span class="comment">// 对每一个桶中的元素应用插入排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = C[i];         <span class="comment">// C[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (i == bn - <span class="number">1</span> ? n - <span class="number">1</span> : C[i + <span class="number">1</span>] - <span class="number">1</span>);<span class="comment">// C[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)        <span class="comment">// 对元素个数大于1的桶进行桶内插入排序</span></span><br><span class="line">InsertionSort(A, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">29</span>, <span class="number">25</span>, <span class="number">3</span>, <span class="number">49</span>, <span class="number">9</span>, <span class="number">37</span>, <span class="number">21</span>, <span class="number">43</span> &#125;;<span class="comment">// 针对桶排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    BucketSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"桶排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1e18e317393c2f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。 </p><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>​    桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>​    基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe46e1ab43534fd1.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n * dn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dn = <span class="number">3</span>;                <span class="comment">// 待排序的元素为三位数及以下</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;                <span class="comment">// 基数为10，每一位的数字都是[0,9]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span>          <span class="comment">// 获得元素x的第d位数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span> &#125;;<span class="comment">// 最大为三位数，所以这里只要到百位就满足了</span></span><br><span class="line">    <span class="keyword">return</span> (x / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> d)</span><span class="comment">// 依据元素的第d位数字，对A数组进行计数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[GetDigit(A[i], d)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dight = GetDigit(A[i], d);  <span class="comment">// 元素A[i]当前位数字为dight   </span></span><br><span class="line">        B[--C[dight]] = A[i];           <span class="comment">// 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">        <span class="comment">// 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LsdRadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>     <span class="comment">// 最低位优先基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; d++)     <span class="comment">// 从低位到高位</span></span><br><span class="line">    CountingSort(A, n, d);        <span class="comment">// 依据第d位数字对A进行计数排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">20</span>, <span class="number">90</span>, <span class="number">64</span>, <span class="number">289</span>, <span class="number">998</span>, <span class="number">365</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">789</span>, <span class="number">456</span> &#125;;<span class="comment">// 针对基数排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    LsdRadixSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"基数排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程<br><img src="https://upload-images.jianshu.io/upload_images/12654931-463067e0a4b82c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。</p><p>　　如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。</p><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>​    基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>​    基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer（一）：二维数组中的查找</title>
      <link href="/2018/07/12/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2018/07/12/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<h1 id="剑指Offer（一）：二维数组中的查找"><a href="#剑指Offer（一）：二维数组中的查找" class="headerlink" title="剑指Offer（一）：二维数组中的查找"></a>剑指Offer（一）：二维数组中的查找</h1><p>摘要</p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>​    首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><p>如果在一个二维数组中找到数字7，则返回true，如果没有找到，则返回false。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-e1ac5d9f3a6d3567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>查找过程如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-43cb8ecc339b728c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3、编程实现"><a href="#3、编程实现" class="headerlink" title="3、编程实现"></a>3、编程实现</h3><p><strong>C++：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* 04 二维数组中的查找*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    bool fun(vector&lt;vector&lt;int&gt;&gt; arr,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        // 特殊输入</span><br><span class="line">        if(!arr.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            // 行列个数</span><br><span class="line">            int row = arr.size();</span><br><span class="line">            int col = arr[0].size();</span><br><span class="line"> </span><br><span class="line">            // 右上角坐标</span><br><span class="line">            int a = 0;</span><br><span class="line">            int b = col-1;</span><br><span class="line"> </span><br><span class="line">            while(a&lt;row &amp;&amp; b&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                // 找到</span><br><span class="line">                if(arr[a][b] == target)</span><br><span class="line">                    return true;</span><br><span class="line"> </span><br><span class="line">                // 未找到</span><br><span class="line">                if(arr[a][b] &lt; target)</span><br><span class="line">                    ++a;</span><br><span class="line">                else</span><br><span class="line">                    --b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"> </span><br><span class="line">    // 特殊输入</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; arr1;</span><br><span class="line">    int target1 = 11;</span><br><span class="line">    cout&lt;&lt;solution.fun(arr1,target1)&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    // 正常输入</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; arr2 = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;;</span><br><span class="line">    int target2 = 11;</span><br><span class="line">    cout&lt;&lt;solution.fun(arr2,target2)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Python2.7：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> rows &gt; <span class="number">0</span> <span class="keyword">and</span> cols &gt; <span class="number">0</span>:</span><br><span class="line">            row = <span class="number">0</span></span><br><span class="line">            col = cols - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> target == array[row][col]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解朴素贝叶斯</title>
      <link href="/2018/07/06/%E7%90%86%E8%A7%A3%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
      <url>/2018/07/06/%E7%90%86%E8%A7%A3%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
      <content type="html"><![CDATA[<h1 id="理解朴素贝叶斯"><a href="#理解朴素贝叶斯" class="headerlink" title="理解朴素贝叶斯"></a>理解朴素贝叶斯</h1><h4 id="（1）先验概率、后验概率、联合概率、全概率"><a href="#（1）先验概率、后验概率、联合概率、全概率" class="headerlink" title="（1）先验概率、后验概率、联合概率、全概率"></a>（1）<strong>先验概率、后验概率、联合概率、全概率</strong></h4><p>如果我对这个西瓜<strong>没有任何了解</strong>，包括瓜的颜色、形状、瓜蒂是否脱落。按常理来说，西瓜成熟的概率大概是 60%。那么，这个概率 P(瓜熟) 就被称为<strong>先验概率</strong>。</p><p>即，<strong>先验概率</strong>是<strong>根据以往经验和分析得到的概率，先验概率无需样本数据，不受任何条件的影响。</strong>就像<strong>只根据常识而不根据西瓜状态来判断西瓜是否熟，这就是先验概率</strong>。</p><p>一个判断西瓜是否成熟的常识，就是看瓜蒂是否脱落。一般来说，瓜蒂脱落的情况下，西瓜成熟的概率大一些，大概是 75%。如果<strong>把瓜蒂脱落当作一种结果，然后去推测西瓜成熟的概率</strong>，这个概率 P(瓜熟 | 瓜蒂脱落) 就被称为<strong>后验概率</strong>。后验概率类似于<strong>条件概率</strong>。</p><p>知道了先验概率和后验概率，我们再来看看什么是联合概率。<strong>P(瓜熟，瓜蒂脱落)</strong> 称之为<strong>联合分布</strong>，它表示<strong>瓜熟了且瓜蒂脱落的概率</strong>。关于联合概率，满足下列乘法等式：</p><a id="more"></a><p><strong>P(瓜熟，瓜蒂脱落)</strong> <strong>=</strong> <strong>P(瓜熟**</strong>|<strong>瓜蒂脱落)**</strong>·<strong>P(瓜蒂脱落)</strong>=<strong>P(瓜蒂脱落</strong>|<strong>瓜熟)</strong>·<strong>P(瓜熟)</strong></p><p>其中，P(瓜熟 | 瓜蒂脱落) 就是刚刚介绍的后验概率，表示在“瓜蒂脱落”的条件下，“瓜熟”的概率。P(瓜蒂脱落 | 瓜熟) 表示在“瓜熟”的情况下，“瓜蒂脱落”的概率。</p><p>如何计算瓜蒂脱落的概率呢？实际上可以分成两种情况：一种是<strong>瓜熟状态下瓜蒂脱落的概率</strong>，<strong>另一种是瓜生状态下瓜蒂脱落的概率</strong>。瓜蒂脱落的概率就是这两种情况之和。因此，我们就推导出了<strong>全概率公式</strong>：</p><p><strong>P(瓜蒂脱落)=P(瓜蒂脱落|瓜熟)·P(瓜熟)+P(瓜蒂脱落|瓜生)·P(瓜生)</strong></p><h4 id="（2）单个特征判断瓜熟"><a href="#（2）单个特征判断瓜熟" class="headerlink" title="（2）单个特征判断瓜熟"></a><strong>（2）单个特征判断瓜熟</strong></h4><p>好了，介绍完先验概率、后验概率、联合概率、全概率后，我们来看这样一个问题：西瓜的状态分成两种：瓜熟与瓜生，概率分别为 0.6 与 0.4，且瓜熟里面瓜蒂脱落的概率是 0.8，瓜生里面瓜蒂脱落的概率是 0.4。那么，如果我现在挑到了一个瓜蒂脱落的瓜，则该瓜是好瓜的概率多大？</p><p>显然，这是一个计算后验概率的问题，根据我们上面推导的联合概率和全概率公式，可以求出：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-582ca247f1f19977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一项一项来看：</p><p>条件概率 P(瓜蒂脱落 | 瓜熟) = 0.8</p><p>先验概率 P(瓜熟) = 0.6</p><p>条件概率 P(瓜蒂脱落 | 瓜生) = 0.4</p><p>先验概率 P(瓜生) = 0.4</p><p>将以上数值带入上式，得：<img src="https://upload-images.jianshu.io/upload_images/12654931-8e483547745003f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>注意，以上这种计算后验概率的公式就是利用贝叶斯定理。</p><h4 id="（3）多个特征判断瓜熟"><a href="#（3）多个特征判断瓜熟" class="headerlink" title="（3）多个特征判断瓜熟"></a><strong>（3）多个特征判断瓜熟</strong></h4><p>判断一个瓜是否熟了，除了要看瓜蒂是否脱落，还要看瓜的形状和颜色。形状有圆和尖之分，颜色有深绿、浅绿、青色之分。我们可以使用刚刚引入的贝叶斯定理思想来尝试解决这个问题。</p><p>现在，特征由原来的 1 个，变成现在的 3 个，我们用 X 表示特征，用 Y 表示瓜的类型（瓜熟还是瓜生）。则根据贝叶斯定理，后验概率 P(Y=ck | X=x) 的表达式为：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5cb90b8151c454a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>其中，ck 表示类别，k 为类别个数。本例中，k = 1，2，c1 表示瓜熟，c2 表示瓜生。上面的公式看似有点复杂，但其实与上一节单特征（瓜蒂是否脱落）的形式是一致的。</p><p>有一点需要注意，这里的特征 X 不再是单一的，而是包含了 3 个特征。因此，<strong>条件概率 P(X=x | Y=ck) 假设各个条件相互独立</strong>，也就是说<strong>假设不同特征之间是相互独立的</strong>。这样，P(X=x | Y=ck) 就可以写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-040af2fa8ac84376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>其中，n 为特征个数，j 表示当前所属特征。针对这个例子，P(X=x | Y=ck) 可以写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-4801526d4c60a531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>这种<strong>条件独立性的假设</strong>就是朴素贝叶斯法“<strong>朴素</strong>”二字的由来。<strong>这一假设让朴素贝叶斯法变得简单，但是有时候会牺牲一定的分类准确率</strong>。</p><p>​    利用朴素贝叶斯思想，我们就可以把后验概率写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-44bce97a4ade7d80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img">    上面的公式看上去比较复杂，其实只是<strong>样本特征增加</strong>了，形式上与上一节 P(瓜熟 | 瓜蒂脱落) 是一致的。</p><p>现在，一个西瓜，观察了它的瓜蒂、形状、颜色三个特征，就能根据上面的朴素贝叶斯公式，分别计算 c1（瓜熟）和 c2（瓜生）的概率，即 P(Y=c1 | X=x) 和 P(Y=c2 | X=x)。然后再比较 P(Y=c1 | X=x) 和 P(Y=c2 | X=x) 值的大小：</p><p>若 P(Y=c1 | X=x) &gt; P(Y=c2 | X=x)，则判断瓜熟；</p><p>若 P(Y=c1 | X=x) &lt; P(Y=c2 | X=x)，则判断瓜生。</p><p>值得注意的是上式中的分母部分，对于所有的 ck 来说，都是一样的。因此，分母可以省略，不同的 ck，仅比较 P(Y=ck | X=x) 的分子即可：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-57b7db79a57f0c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="（2）朴素贝叶斯分类"><a href="#（2）朴素贝叶斯分类" class="headerlink" title="（2）朴素贝叶斯分类"></a>（2）<strong>朴素贝叶斯分类</strong></h4><p>买瓜之前，还有一件事情要做，就是搜集样本数据。通过网上资料和查阅，获得了一组包含 10 组样本的数据。这组数据是不同瓜蒂、形状、颜色对应的西瓜是生是熟。我把这组数据当成是历史经验数据，以它为标准。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-8b395ed221dac1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"> </p><p>其中，瓜蒂分为脱落和未脱，形状分为圆形和尖形，颜色分为深绿、浅绿、青色。不同特征组合对应着瓜熟或者瓜生。</p><p>现在，挑了一个西瓜，它的瓜蒂脱落、形状圆形、颜色青色。这时候，就完全可以根据<strong>样本数据</strong>和<strong>朴素贝叶斯法</strong>来计算后验概率。</p><p>首先，对于瓜熟的情况：</p><p>瓜熟的先验概率： P(瓜熟) = 6 / 10 = 0.6。</p><p>条件概率： P(脱落 | 瓜熟) = 4 / 6 = 2 / 3。</p><p>条件概率： P(圆形 | 瓜熟) = 4 / 6 = 2 / 3。</p><p>条件概率： P(青色 | 瓜熟) = 2 / 6 = 1 / 3。</p><p>计算<strong>后验概率分子部分</strong>：P(瓜熟) × P(脱落 | 瓜熟) × P(圆形 | 瓜熟) × P(青色 | 瓜熟) = 0.6 × (2 / 3) × (2 / 3) × (1 / 3) = 4 / 45。</p><p>然后，对于瓜生的情况：</p><p>瓜生的先验概率： P(瓜生) = 4 / 10 = 0.4。</p><p>条件概率： P(脱落 | 瓜生) = 1 / 4 = 0.25。</p><p>条件概率： P(圆形 | 瓜生) = 1 / 4 = 0.25。</p><p>条件概率： P(青色 | 瓜生) = 1 / 4 = 0.25。</p><p>计算<strong>后验概率分子部分</strong>：P(瓜生) × P(脱落 | 瓜生) × P(圆形 | 瓜生) × P(青色 | 瓜生) = 0.4 × 0.25 × 0.25 × 0.25 = 1 / 160。</p><p>因为 4 / 45 &gt; 1 / 160，所以预测为瓜熟。终于计算完了，很肯定这个西瓜瓜蒂脱落、形状圆形、颜色青色，应该是熟瓜。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 朴素贝叶斯 </tag>
            
            <tag> 西瓜书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>域名解析</title>
      <link href="/2018/07/03/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/07/03/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>域名有钱最好买.com的，不要买.cn的，我自己买的.cn的好多坑，.top的相对就比较便宜（low）。</p><p>此次在腾讯云买的dadavision.cn。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-7be4ec62010a4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p><p>之前.cn的一直要我备案，否则DNS解析不了，而且还证书审核失败。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5de7c90ec35f4b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3a445764853e3128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在github项目的setting里面设置域名</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6e54ef27bfdb1bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>添加域名解析</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-19d33afeda8ecd28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里注意</p><p>在添加绑定域名后需要注意以下问题（未绑定可以不用）</p><p>需要将github上CNAME里面内容在文件工程中GitBlog\source\CNAME</p><p>这里注意新建的CNAME不要有后缀名。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3eb1866b15f4f46d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2c825d1db371b855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 域名解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> next </tag>
            
            <tag> 教程 </tag>
            
            <tag> 域名 </tag>
            
            <tag> 域名解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pytorch0.4.0升级概述新手教程</title>
      <link href="/2018/06/20/Pytorch0-4-0%E5%8D%87%E7%BA%A7%E6%A6%82%E8%BF%B0%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/20/Pytorch0-4-0%E5%8D%87%E7%BA%A7%E6%A6%82%E8%BF%B0%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>pytorch0.4支持了Windows系统的开发，在<a href="https://pytorch.org/" target="_blank" rel="noopener">首页</a>即可使用pip安装pytorch和torchvision。<br> 说白了，以下文字就是来自<a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" target="_blank" rel="noopener">官方文档60分钟入门的简要翻译</a>.</p><h2 id="pytorch是啥"><a href="#pytorch是啥" class="headerlink" title="pytorch是啥"></a>pytorch是啥</h2><p>python的科学计算库，使得NumPy可用于GPU计算，并提供了一个深度学习平台使得灵活性和速度最大化</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="Tensors-张量"><a href="#Tensors-张量" class="headerlink" title="Tensors(张量)"></a>Tensors(张量)</h4><a id="more"></a><p>Tensors与NumPy的ndarrays类似，另外可以使用GPU加速计算</p><p>未初始化的5*3的矩阵:<code>x = torch.empty(5, 3)</code><br> 随机初始化的矩阵:<code>x = torch.rand(5, 3)</code><br> 全零矩阵,定义数据类型:<code>x = torch.zeros(5, 3, dtype=torch.long)</code><br> 由数据构造矩阵:<code>x = torch.tensor([5.5, 3])</code><br> 由已存在张量构造矩阵，性质与之前张量一致:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x.new_ones(5, 3, dtype=torch.double) </span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)</span><br></pre></td></tr></table></figure><p>获取维度:<code>print(x.size())</code></p><h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><p>有多种operation的格式，这里考虑加法</p><ol><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = torch.rand(5, 3)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = torch.empty(5, 3)</span><br><span class="line">torch.add(x, y, out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># adds x to y</span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>operations中需要改变张量本身的值，可以在operation后加<em>,比如`x.copy</em>(y), x.t_()`</p><p>索引:<code>print(x[:, 1])</code><br> 改变维度:<code>x.view(-1, 8)</code></p><h3 id="和Numpy的联系"><a href="#和Numpy的联系" class="headerlink" title="和Numpy的联系"></a>和Numpy的联系</h3><p>torch tensor 和 numpy array之间可以进行相互转换，他们会共享内存位置，改变一个，另一个会跟着改变。</p><h4 id="tensor-to-array"><a href="#tensor-to-array" class="headerlink" title="tensor to array"></a>tensor to array</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(5)</span><br><span class="line">b = a.numpy()</span><br><span class="line">a.add_(1)</span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure><h4 id="array-to-tensor"><a href="#array-to-tensor" class="headerlink" title="array to tensor"></a>array to tensor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.ones(5)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, 1, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h3><p>tensor可以使用<code>.to</code>方法将其移动到任何设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># let us run this cell only if CUDA is available</span><br><span class="line"># We will use ``torch.device`` objects to move tensors in and out of GPU</span><br><span class="line">if torch.cuda.is_available():</span><br><span class="line">    device = torch.device(&quot;cuda&quot;)          # a CUDA device object</span><br><span class="line">    y = torch.ones_like(x, device=device)  # directly create a tensor on GPU</span><br><span class="line">    x = x.to(device)                       # or just use strings ``.to(&quot;cuda&quot;)``</span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(&quot;cpu&quot;, torch.double))       # ``.to`` can also change dtype together!</span><br></pre></td></tr></table></figure><h2 id="Autograd-自动求导"><a href="#Autograd-自动求导" class="headerlink" title="Autograd(自动求导)"></a>Autograd(自动求导)</h2><p>pytorch神经网络的核心模块就是autograd，autograd模块对Tensors上的所有operations提供了自动求导。</p><h3 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h3><p><code>torch.Tensor</code>是模块中的核心类，如果设置属性<code>.requires_grad = True</code>,开始追踪张量上的所有节点操作，指定其是否计算梯度。使用<code>.backward()</code>方法进行所有梯度的自动求导，张量的梯度会累积到<code>.grad</code>属性中。<br> <code>.detach()</code>停止张量的追踪，从梯度计算中分离出来；另外在评估模型时一般使用代码块<code>with torch.no_grad():</code>,因为模型中通常训练的参数也会有<code>.requires_grad = True</code>,这样写可以停止全部张量的梯度更新。<br> <code>Function</code>类是autograd的变体，<code>Tensor</code>和<code>Function</code>相互交错构建成无环图，编码了完整的计算过程，每个Variable(变量)都有<code>.grad_fn</code>属性，引用一个已经创建了的Tensor的Function.<br> 如上，使用<code>.backward()</code>计算梯度。如果张量是一个标量(只有一个元素),不需要对<code>.backward()</code>指定参数；如果张量不止一个元素，需要指定<code>.backward()</code>的参数，其匹配张量的维度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">x = torch.ones(2, 2, requires_grad=True)</span><br><span class="line">print(x)</span><br><span class="line">y = x + 2</span><br><span class="line">print(y)</span><br><span class="line">print(y.grad_fn)</span><br><span class="line">z = y * y * 3</span><br><span class="line">out = z.mean()</span><br><span class="line">print(z, out)</span><br><span class="line"></span><br><span class="line">a = torch.randn(2, 2)</span><br><span class="line">a = ((a * 3) / (a - 1))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(True) # 改变a张量内在的属性</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure><h3 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h3><p>反向传播时，由于<code>out</code>是一个标量，<code>out.backward()</code>等效于<code>out.backward(torch.tensor(1))</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">out.backward()</span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line">x = torch.randn(3, requires_grad=True)</span><br><span class="line"></span><br><span class="line">y = x * 2</span><br><span class="line">while y.data.norm() &lt; 1000:</span><br><span class="line">    y = y * 2</span><br><span class="line"></span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)</span><br><span class="line">y.backward(gradients)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** 2).requires_grad)</span><br><span class="line"></span><br><span class="line">with torch.no_grad():</span><br><span class="line">    print((x ** 2).requires_grad)</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经网络可以用<code>torch.nn</code>构建。<code>nn</code>依赖于<code>autograd</code>定义模型和求导，<code>nn.Module</code>定义网络层，方法<code>forward(input)</code>返回网络输出。</p><p>举例说明，如下是对数字图片分类的卷积网络架构。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fb68bfe5f7c4d22e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br> 这是一个简单的前馈神经网络，将输入数据依次通过几层网络层后最终得到输出。<br> 神经网络典型的训练步骤如下：</p><ul><li>定义神经网络及学习的参数(权重)</li><li>迭代输入数据</li><li>将输入数据输入到网络结构中</li><li>计算代价函数</li><li>误差向后传播</li><li>更新网络权重 <code>weight = weight - learning_rate * gradient</code> </li></ul><h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Net(nn.Module):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        # 1 input image channel, 6 output channels, 5x5 square convolution</span><br><span class="line">        # kernel</span><br><span class="line">        self.conv1 = nn.Conv2d(1, 6, 5)</span><br><span class="line">        self.conv2 = nn.Conv2d(6, 16, 5)</span><br><span class="line">        # an affine operation: y = Wx + b</span><br><span class="line">        self.fc1 = nn.Linear(16 * 5 * 5, 120)</span><br><span class="line">        self.fc2 = nn.Linear(120, 84)</span><br><span class="line">        self.fc3 = nn.Linear(84, 10)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        # Max pooling over a (2, 2) window</span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))</span><br><span class="line">        # If the size is a square you can only specify a single number</span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), 2)</span><br><span class="line">        x = x.view(-1, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">    def num_flat_features(self, x):</span><br><span class="line">        size = x.size()[1:]  # all dimensions except the batch dimension</span><br><span class="line">        num_features = 1</span><br><span class="line">        for s in size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        return num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">  (fc1): Linear(in_features=400, out_features=120, bias=True)</span><br><span class="line">  (fc2): Linear(in_features=120, out_features=84, bias=True)</span><br><span class="line">  (fc3): Linear(in_features=84, out_features=10, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以仅定义<code>forward()</code>函数，当使用<code>autograd</code>时<code>backward()</code>被自动定义。可以在<code>forward()</code>函数中使用任何operation操作。<br> <code>net.parameters()</code>返回模型中的可学习参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line">print(params[0].size())  # conv1&apos;s .weight</span><br></pre></td></tr></table></figure><p>使所有参数的梯度归零然后开始计算梯度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(1, 10))</span><br></pre></td></tr></table></figure><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>代价函数将(output,target)作为输入，计算output与target之间的距离。<br> nn模块中有几种不同的代价函数选择，最简单的是<code>nn.MSELoss</code>，计算均方误差<br> eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.arange(1, 11)  # a dummy target, for example</span><br><span class="line">target = target.view(1, -1)  # make it the same shape as output</span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure><p>按照向后传播的方向传播loss，使用<code>grad_fn</code>可以查看整个流程的计算图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure><p>使用<code>loss.backward()</code>，流程中所有<code>requres_grad=True</code>的张量累积它的梯度至<code>.grad</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(loss.grad_fn)  # MSELoss</span><br><span class="line">print(loss.grad_fn.next_functions[0][0])  # Linear</span><br><span class="line">print(loss.grad_fn.next_functions[0][0].next_functions[0][0])  # ReLU</span><br></pre></td></tr></table></figure><h3 id="向后传播"><a href="#向后传播" class="headerlink" title="向后传播"></a>向后传播</h3><p><code>loss.backward()</code>传播误差，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()     # zeroes the gradient buffers of all parameters</span><br><span class="line"></span><br><span class="line">print(&apos;conv1.bias.grad before backward&apos;)</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(&apos;conv1.bias.grad after backward&apos;)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure><h3 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h3><p>误差每次传播后，需要对权重进行更新，简单的更新方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = 0.01</span><br><span class="line">for f in net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure><p><code>torch.optim</code>实现了这一过程，并有着不同的更新规则GD, Nesterov-SGD, Adam, RMSProp，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import torch.optim as optim</span><br><span class="line"></span><br><span class="line"># create your optimizer</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=0.01)</span><br><span class="line"></span><br><span class="line"># in your training loop:</span><br><span class="line">optimizer.zero_grad()   # zero the gradient buffers</span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    # Does the update</span><br></pre></td></tr></table></figure><p>note: 每次迭代时由于梯度的累积，需要手动将梯度归零<code>optimizer.zero_grad()</code></p>]]></content>
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Pytorch </tag>
            
            <tag> Pytorch0.4.0 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>唐老师研究生毕业演讲</title>
      <link href="/2018/06/20/%E5%94%90%E8%80%81%E5%B8%88%E7%A0%94%E7%A9%B6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%BC%94%E8%AE%B2/"/>
      <url>/2018/06/20/%E5%94%90%E8%80%81%E5%B8%88%E7%A0%94%E7%A9%B6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%BC%94%E8%AE%B2/</url>
      <content type="html"><![CDATA[<p>尊敬的何院士、各位嘉宾、各位老师、同学们：</p><p>大家下午好！</p><a id="more"></a><!--我是计算机科学与软件工程学院2018届硕士毕业生唐益军。此刻我站在这里，除了感到兴奋和荣幸之外，其实更多的是不解。学院的张老师让我来做毕业生代表致辞，我其实一直以为只有优秀毕业生才可以来。我是说，即使真的是只有优秀毕业生才可以来，我也会不择手段地想尽各种办法上来说几句话。可是，母校的不拘一格和张老师的英明决定让我的那些“不择手段”竟然到现在都没有用武之地，我想这可能是我在毕业之际留下的唯一遗憾。Anyway, 今天我被委以“重任”站在了这里，我希望能和大家分享一下这几年从母校、学院以及学校的各位老师那里感受到的几点体会，希望能和大家共勉。并且我一厢情愿地以为这也是你们的体会，即使不是，希望大家今天在现场配合下我，假装这些是。好，那我们开始。**1. 在校期间学习“学习”**确切地说是，**在校期间一定要好好学习学习**，即使这样做的结果是注定要单身整个大学和研究生生涯也没有关系。学习的过程就是将我们从一个傻傻分不清楚的“学生”变成一个高富帅或者是白富美型的技能满点的社会精英。从这个结果看过去，具体地说，从我目前的身体状态看过去，我的学习过程基本就是失败的。对了，插一句，我要重新定义下“学习”的概念：“**不要停止投资自己的脑子和身子**”。我知道，很多同学和我一样都曾不断疑问：我学了这么多年的文化知识，可是去校门外一看几乎和社会上的企业机构所需要的技能是脱节的，我该咋办？拿我们软件专业来说，市面上普通需要的是做后台开发，前端设计，安卓IOS开发、大数据开发，甚至是机器学习人工智能，乃至最近比较火的区块链技术。可是，学校从来不教我们这些东西，至少是从来没有直接教给我们如何用这些技术开发项目。但事实上，学校的各位老师用心良苦，很多人都没有看出来。今天就让我来揭开这个惊天大秘密吧。注意听，学校教给我们的一直都是“**如何学习**”的能力。我刚刚说“在校期间学习学习”。第一个“学习”是动词，第二个“学习”是名词，意思就是：**我们要学习“如何学习”这件事儿**。走上你未来的工作岗位后，你可能会发现：光会后台开发（我是说软件专业的同学）不够用了，公司可能有个临时项目需要你会Python，可是老师没教过，不过好在我们有“如何学习”的能力，所以做到知识的快速迁移与学习一定，注意，是一定，一定没有问题。这一点，我无比自信，甚至是坚信，相信你们也一样。我小时候看过一部电影叫《神鞭》。故事情节不重要了，只记得影片结尾有一句台词：“**鞭没了，但神还在**。”这和我们的学校教育是不是很像，最后忘记了所有具体的知识技能，但是我们的“学习能力”留下来了。我想这才是未来我们在社会上一直能够无往不利的最强能力，至少也应该是之一吧。**2. 在用中学和学中用**软件专业当然也包括其他专业，很多老师也就是我们的研究生导师给我们提供了很多研究课题项目。对于软件专业的同学来说，要求动手能力很强，也就是大家常说的代码能力要很强。我记得刚开始的时候，很多同学，至少包括我，我们都觉得自己的能力不够来做项目，于是就想着再去找一些书系统看看前面的内容，来达到现在“具备做这个课题项目的能力”，也就是我们常说的“我想先学会了再去做”。这样的后果就是，你永远“学不够”、“学不会”。后来我们的师兄师姐告诉我们过来人的经验，说这种蠢事谁年轻的时候没干过呢，其实你们应该直接做课题做项目，在做的过程中遇到不会的去查，然后回来继续做，反复折腾，反复验证，项目也就被推进着做完了。简单地说**这个过程就是“在用中学和学中用”**。可是我觉得师兄师姐没有说清楚这件事儿，尽管从结果上看让人屡试不爽。但是，今天既然在这里演讲，我觉得非常有必要稍显专业地把这件事儿再稍微说明白一点。所以后来我总结道（其实也不是我总结的，你们就姑且当是我总结的吧）：**当你需要获取某项技能或者是搞定一件事儿的时候，一定要想办法在最短时间内弄清楚这个技能或搞定这件事儿需要哪些“最少必要知识”，然后迅速掌握它**。请大家记住了，在你掌握了这些“最少必要知识”的瞬间，其实你就已经入门了，你就走上了学习这项技能的快速路径或具备了搞定这件事儿的起码素质。剩下的部分，只需要你在“用中学和学中用”。而在研究生期间我们需要攻克的那些课题项目，其实大部分所需要的“最少必要知识”我们已经具备了，除非你在本科期间光顾着谈恋爱了，虽然我觉得从某种意义上来讲，没有什么比谈恋爱更重要的事儿了，如果真的有，你就再谈一个嘛。从这个角度看过去，从掌握“最少必要知识”再到“用中学和学中用”，其实这就是我刚刚说的第一点中的“如何学习的能力”。我不得不反复强调这件事儿，因为对学生来说，即使我们今天毕业了，学习还是一件非常重要的事儿，即使和谈恋爱相比，它不能成为最重要了，我想至少也应该是之一吧。**3. 有死磕到底的精神**刚刚说到很多研究课题项目，所以研究生期间晚上12点才准备回宿舍，其实一点都不值得炫耀，尽管我和很多同学一样，都喜欢在12点或者1点准备走的时候拍一张照片发到朋友圈。我印象比较深刻的是，大概是研一下学期有天晚上大概11点多了，实验室只剩下我和一位年轻的王老师。我已经准备收拾一下就撤了。当时我们那个王老师一看我要走，一把拿住我：“你干嘛去？”那个眼神就像在说，今晚程序调不出来不许走！我当时楞了一小会，你们要知道，对于一个资深的胖子来说，正常情况下，我什么都愿意吃，就是不愿意吃苦，尤其是这么大半夜的。可是，我当时看到王老师含情脉脉地盯着我，我们四目相对，那时那刻，我们都知道彼此心里在想什么：他知道我想走，我知道他不想让我走。最终我还是从了他，只好说：“我先去上个洗手间”。但是，回头想想我十分感谢王老师。从我踏入那个实验室开始，我几乎每天都能看到他至少工作到晚上11点以后，从未间断过。早上也来得很早，我为此还非常“不合常理”地起了好几个大早。可是不管我有多早，他都已经在了。不过，我也一直都没有好意思问他为什么这么拼命？就怕王老师告诉我：知道你为什么这么胖了吧？所以如果说，**我身上有那么一点点死磕到底，有那么一点点从来都不放过自己的精神，我想都是王老师日日夜夜对我以身作则的影响**，尽管我从来没有向他表白过，但今天我想借这个机会说一句：王老师，我爱你。没想到，我人生中第一次公开场合的表白献给了一位老男人。作为毕业生代表，刚刚那句“我爱你”，我其实也是替大家说给那些我们研究生生涯中的老师们听的。实在不好意思，没有经过大家同意，就这么把很多人的“第一次”送出去了。**4. 做一名终身学习者**毕业找工作的时候，我本来的打算是去那个浦发银行。因为大家都说来钱最快的是金融投资行业，所以我也十分天真，为了钱什么都干得出来。可是，有一天我的研究生导师王江涛老师找到我，十分中肯地说：“小唐啊，你看研究生这几年，你除了体重，其他的学习能力和工作能力，其实都没有得到多大的提升。我的意思是，你要不要毕业后在我这里再学习几年？反正你还年轻，而且你估计也找不到什么好工作的吧。”我当时一听，那个心里真不是滋味，心想：王老师的为人怎么这么好？为我考虑得如此周到。尤其是，他也觉得我还需要学习，并且即使我毕业了也愿意继续教我培养我。我当时感动得一塌糊涂，鼻涕泪水全下来了，头一扬，眼含泪水对着王老师说：那太好了。我愿意啊。我是想说，我们在场的每一个人都要做一名终身学习者，即使我们今天从母校毕业了，即使我们暂时脱离了理论意义上的“学生”身份。**尤其是当你觉得自己力有不逮，心有不余的时候，通过学习新的事物，不一定是我们的专业知识，总是会有一种让我们脚能够踩在地上的厚实感，对了，这个词叫“踏实”也叫“安全感”**。所以，**我一直愿意承认和告诉别人，我过去、现在和未来都是一个学生**，即使费尽千辛万苦地勉强拿到了学位，勉强从母校毕业了。但正如乔布斯曾经说过的那样：**stay foolish, stay hungry. 永远保持谦卑的心态，永远要如饥似渴地对待那些新的事物。**正是这样的一个空杯心态才是我们可以不断进步的基本条件，也是我们作为一个终身学习者的标配。**5. 身体是革命的本钱**前不久我们团队去浙江嘉兴南湖搞团建，我们当时要做一个叫“定向越野”的项目，总共有11个定点。但是游戏规则只需要走4个点，可是带我们小队的领队是一位跑过马拉松的老师。他决定带我们跑完11个定点，我们从8点半左右开始出发，一直到中午12点半才完成任务。本来走走停停中间歇歇，即使对我这样一个胖子，跑完全程也显得相对十分轻松。可是我们这位老师毕竟是跑过马松的，全程都是在小跑。刚开始我还受得了，时间长了，我的生理防线没有丝毫犹豫直接崩溃，整个人都在打摆。一向自诩心理强大的我，在那一刻我的心理防线也几乎临近崩溃边缘。所以后半场我几乎在众人拖着的情况下走完了。好，接下来是本次演讲中最励志的部分了。大家请听好了，非常励志的部分来了。团建回来以后，我做出了一个非常慎重的决定：我要减肥！注意，我要解释一下，在胖子界有头有脸且有过多年从业经验的我来说，我从来没想过要跨界转行。但是一想到这次团建我的糟糕表现，以及我觉得我未来是要干大事儿。你们知道，干大事一定要身体特别好，因为大事干成的时间周期一般有点长，工作强度也特别特别大。所以如果身体不好，基本我要干的“大事儿”也就黄了。因此，基于这样的考虑，我觉得我要减肥了。于是，我去报了一个健身房，还请了两个私教。基本上把我身上的那点积蓄和信用卡都刷爆了。当然，这不重要。我想说的是，**身体真的是革命的本钱**。这事儿实在太重要了，即使和谈恋爱相比也很重要，如果你能懂我的意思的话。好，现在请允许我代表2018届计算机科学与软件工程学院所有硕士毕业生，向我们的母校华东师范大学、向计算机科学与软件工程学院的何院士以及其他全体老师表示衷心的感谢。没有你们的教育与培养，光靠我们自己的努力，我们根本无法茁壮成长到现在，而且长势非常喜人，甚至还有点喜人过了头，比如说我。请大家和我一起把掌声送给所有所有的老师，感谢你们这些年不辞辛劳的付出，也祝愿何院士和全体老师在以后的日子里工作顺利！身体健康！同时，借此机会我想代表学院所有硕士毕业生同学向我们的父母表示感谢，感谢他们多年来的养育之恩。尤其是在我们20多岁血气方刚、风华正茂的年龄，本该承担起一部分家庭责任的时候，居然还一直支持我们求学读书，不管是精神上还是经济上。当然，最重要的还是经济上，因为我想对你们说，你们的儿子女儿已经在精神上坚强得让你们难以想象了。并且从今天开始，我们也有经济实力，可能只有软件专业的学生才敢说这种话，我们也有经济实力给予你们更多的报答。后天就是父亲节，大家可以想想能干点什么了。最后，也是最重要的部分，**Class of 2018, Congradulations. It is your big day, so stop thinking about anything today but enjoy it !  And rock to death.** 好，谢谢大家。我也最后代表一次大家，请允许我代表全体2018届研究生感谢母校，感谢计算机科学与软件工程学院，感谢所有老师的教导，感谢今天到场的咱爸咱妈们，并且祝福你们！谢谢！谢谢！-->]]></content>
      
      <categories>
          
          <category> 毕业演讲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业演讲 </tag>
            
            <tag> 唐老师 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win10+Anaconda+tensorflow1.8+pytorch0.4.0注意事项</title>
      <link href="/2018/06/12/win10-Anaconda-tensorflow1-8-pytorch0-4-0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2018/06/12/win10-Anaconda-tensorflow1-8-pytorch0-4-0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol><li><p>Anaconda会自带python3.6，所以为了避免环境配置乱套，删除本机独立安装的python。</p></li><li><p>不要按网上配置虚拟环境，比如TensorFlow配置一个虚拟环境，pytorch配置一个虚拟环境……keras……cafee……只要一个环境即可。</p></li><li><p>win10+Anaconda3-5.2.0+tensorflow1.8+pytorch0.4.0</p></li><li><p>在windows PowerShell中确定python环境在Anaconda中</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12654931-758686cac6661ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-0ef68ed1d7f3107a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a><strong>Anaconda</strong></h2><p>注意：自动添加到环境变量<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f9601196db050179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>其它事项一路安装，普通套路。</p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a><strong>TensorFlow</strong></h2><p>1、TensorFlow或者pytorch，无论什么框架，越新越好，新的功能多bug少，这里用的TensorFlow1.8。</p><p>2、TensorFlow和pytorch最好都用conda装，但是这里conda install tensorflow只会给你比较低的版本，所以TensorFlow安装在这里使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --channel https://conda.anaconda.org/conda-forge tensorflow</span><br></pre></td></tr></table></figure></p><pre><code>可能会下载很慢，如果有部分下载未成功，重新执行命令即可，之前下载的会保留。</code></pre><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a><strong>Pytorch</strong></h2><p>同样遵循使用最新框架原则。<br>我自己电脑用的pytorch-CPU版本，所以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install conda install pytorch-cpu -c pytorch</span><br><span class="line">pip install torchvision</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0a411a96f06544e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在实验室服务器用的是cuda9.0版本<br><img src="https://upload-images.jianshu.io/upload_images/12654931-aa2b286afead2c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-win_amd64.whl </span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure></p><p>安装成功之后效果：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-91b167203217a037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-7240d3b7ee4ece2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="PyCharm注意事项"><a href="#PyCharm注意事项" class="headerlink" title="PyCharm注意事项"></a><strong>PyCharm注意事项</strong></h2><p>在不用虚拟幻境情况下，好处就是不用切换环境配置了，直接一个 Anaconda\python.exe全部搞定，如图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-402a57987fa606cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d5644c6b35f278bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>附录鄙视链：<br>caffe-pytorch-tensorflow-caffe2- caffe<br>torch-slim-tensorflow-keras</p>]]></content>
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Anaconda </tag>
            
            <tag> tensorflow </tag>
            
            <tag> pytorch </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PyTorch0.4.0重大更新</title>
      <link href="/2018/06/11/PyTorch0.4.0%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0/"/>
      <url>/2018/06/11/PyTorch0.4.0%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<p><strong>一、重大核心变化包括</strong></p><ul><li>Tensor/Variable 合并</li><li>零维张量</li><li>数据类型</li><li>迁移指南</li></ul><p><strong>二、现添加的新特征包括</strong></p><ul><li>Tensors：</li><li>全面支持高级索引</li><li>快速傅立叶变换</li><li>神经网络：</li><li>计算时的存储权衡</li><li>bottleneck-识别代码中热点（hotspots）的工具</li><li>torch.distributions</li><li>24 个基础的概率分布</li><li>增加cdf、方差、信息熵、困惑度等</li><li>分布式训练<a id="more"></a></li><li>易于使用的 Launcher utility</li><li>NCCL2 后端</li><li>C++拓展</li><li>Windows 支持</li><li>ONNX 改进</li><li>RNN 支持</li></ul><p><strong>三、性能改进</strong></p><p><strong>四、Bug 修复</strong></p><h3 id="五、torchvision的一些变化"><a href="#五、torchvision的一些变化" class="headerlink" title="五、torchvision的一些变化"></a><strong>五、torchvision的一些变化</strong></h3><p>1.torchvision.transform中函数<code>torchvision.transforms.`</code>Scale<code>(*args, **kwargs)即将被函数</code>torchvision.transforms.<code></code>Resize`(size, interpolation=2)代替。（参考官方文档：<a href="http://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.Resize" target="_blank" rel="noopener">点击打开链接</a>）</p><p>2.torchvision.transform中函数<code>torchvision.transforms.`</code>RandomSizedCrop<code>(*args, **kwargs)即将被函数</code>torchvision.transforms.<code></code>RandomResizedCrop`(size, scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333), interpolation=2)代替。（参考官方文档：<a href="http://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.RandomResizedCrop" target="_blank" rel="noopener">点击打开链接</a>）</p><h3 id="六、安装方式——Windows安装"><a href="#六、安装方式——Windows安装" class="headerlink" title="六、安装方式——Windows安装"></a><strong>六、安装方式——Windows安装</strong></h3><p>【方法一】pip直接安装。官网（<a href="http://pytorch.org/" target="_blank" rel="noopener">点击打开链接</a>）给出的安装步骤如下图所示（根据CUDA版本以及Python版本选择）。</p><p><img src="http://img0.ph.126.net/CToULoCCx_lmxB2-e1IPCg==/5717505544412384805.png" alt=""></p><p>Run this command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-win_amd64.whl </span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure><p>这里我是下载好torch-0.4.0-cp36-cp36m-win_amd64.whl文件到本地之后才安装的。<br>进入Anaconda Prompt，然后进入文件所在目录：</p><ol><li><p>打开cmd命令提示符，先利用anaconda创建一个虚拟环境，命名为pytorch4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch4 python=3.6</span><br></pre></td></tr></table></figure></li><li><p>激活刚才创建好的虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pytorch4</span><br></pre></td></tr></table></figure></li><li><p>安装pytorch0.4.0</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch-0.4.0-cp35-cp35m-win_amd64.whl</span><br></pre></td></tr></table></figure><p>注：根据自己的配置选择whl下载来链接</p><ol start="4"><li>安装torchvision<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torchvision</span><br></pre></td></tr></table></figure></li></ol><p>简单测试安装是否成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure></p><p>如果输出0.4.0，那么恭喜Windows下的PyTorch0.4.0安装成功！</p>]]></content>
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> PyTorch </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mnist手写数字识别</title>
      <link href="/2018/06/09/Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2018/06/09/Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="minist-mpl-py"><a href="#minist-mpl-py" class="headerlink" title="minist_mpl.py"></a><strong>minist_mpl.py</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Activation,Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adadelta</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> save_model</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">x_train = x_train.reshape(<span class="number">60000</span>,<span class="number">28</span>*<span class="number">28</span>).astype(<span class="string">'float32'</span>)  <span class="comment">#转换数据格式</span></span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>,<span class="number">28</span>*<span class="number">28</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">x_train /= <span class="number">255</span>   <span class="comment">#训练数据归一化</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"></span><br><span class="line">y_train = keras.utils.to_categorical(y_train,<span class="number">10</span>)    <span class="comment">#one-hot编码</span></span><br><span class="line">y_test = keras.utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(x_train.shape,y_train.shape,x_test.shape,y_test.shape)</span><br><span class="line">modle = Sequential()</span><br><span class="line"><span class="comment">#第一层隐层，64个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">256</span>,activation=<span class="string">'relu'</span>,input_dim=<span class="number">28</span>*<span class="number">28</span>))</span><br><span class="line"><span class="comment">#第二层隐层，64个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">256</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">modle.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#输出层，10个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">10</span>,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">sgd = SGD(lr=<span class="number">0.01</span>,decay=<span class="number">1e-6</span>,momentum=<span class="number">0.9</span>,nesterov=<span class="keyword">True</span>)</span><br><span class="line">modle.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adagrad'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">modle.fit(x_train,y_train,epochs=<span class="number">10</span>,batch_size=<span class="number">128</span>)</span><br><span class="line">score = modle.evaluate(x_test,y_test,batch_size=<span class="number">128</span>)</span><br><span class="line">print(score)</span><br><span class="line">modle.save(<span class="string">'MLP_minist.h5'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential,save_model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Dropout,Flatten,Conv2D,MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adadelta</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()   <span class="comment">#加载数据</span></span><br><span class="line">print(x_train.shape,x_test.shape)</span><br><span class="line">x_train = x_train.reshape(<span class="number">60000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">'float32'</span>)  <span class="comment">#二维数据</span></span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">x_train /= <span class="number">255</span>  <span class="comment">#训练数据归一化</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"></span><br><span class="line">y_train = keras.utils.to_categorical(y_train)    <span class="comment">#one-hot编码</span></span><br><span class="line">y_test = keras.utils.to_categorical(y_test)</span><br><span class="line">num_classes = y_test.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">model = Sequential()    <span class="comment">#创建序列模型</span></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,(<span class="number">3</span>,<span class="number">3</span>),activation=<span class="string">'relu'</span>,input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))  <span class="comment">#第一层卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))    <span class="comment">#池化层</span></span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,(<span class="number">3</span>,<span class="number">3</span>),activation=<span class="string">'relu'</span>))  <span class="comment">#第二层卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))    <span class="comment">#池化层</span></span><br><span class="line"></span><br><span class="line">model.add(Flatten())    <span class="comment">#铺平当前节点</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">128</span>,activation=<span class="string">'relu'</span>))     <span class="comment">#全连接层</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>)) <span class="comment">#随机失活</span></span><br><span class="line">model.add(Dense(num_classes,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])   <span class="comment">#编译模型</span></span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">128</span>,epochs=<span class="number">10</span>)     <span class="comment">#训练模型</span></span><br><span class="line">score = model.evaluate(x_test,y_test,batch_size=<span class="number">128</span>)    <span class="comment">#评价模型</span></span><br><span class="line"></span><br><span class="line">print(score)    <span class="comment">#打印分类准确率</span></span><br><span class="line"></span><br><span class="line">model.save(<span class="string">'CNN_minist.h5'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Keras </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交叉验证集、测试集</title>
      <link href="/2018/06/09/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E9%9B%86%E3%80%81%E6%B5%8B%E8%AF%95%E9%9B%86/"/>
      <url>/2018/06/09/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E9%9B%86%E3%80%81%E6%B5%8B%E8%AF%95%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>什么有交叉验证：主要是<strong>因为训练集较小</strong>。无法直接像前面那样只分出训练集，验证集，测试就可以了（简单交叉验证）。</p><p>最佳的数据分类情况是把数据集分为三部分，分别为：<strong>训练集</strong>(train set)，<strong>验证集</strong>(validation set)和<strong>测试集</strong>(test set)</p><p>验证集和测试集两者的主要区别是：<strong>验证集</strong>用于<strong>进一步确定模型中的超参数</strong>(例如正则项系数、ANN{Artificial Neural Network}中隐含层的节点个数、网络层数、迭代次数、学习率)而<strong>测试集</strong>只是<strong>用于评估模型的精确度(即泛化能力)</strong>！</p><p>举个例子：假设建立一个BP神经网络，对于隐含层的节点数目，我们并没有很好的方法去确定。一般将节点数设定为某一具体的值，通过训练集训练出相应的参数后，再<strong>由交叉验证集去检测该模型的误差</strong>；<strong>然后再改变节点数，重复上述过程，直到交叉验证误差最小</strong>。此时的节点数可以认为是最优节点数，即该节点数(<strong>这个参数)是通过交叉验证集得到的</strong>。</p><p>而<strong>测试集</strong>是在<strong>确定了所有参数之后，根据测试误差来评判这个学习模型的；也可以说是用来评估模型的泛化能力</strong>。所以，<strong>验证集</strong>主要主要是<strong>用于模型的调参</strong>。</p><a id="more"></a><p>“<strong>交叉验证法</strong>“ (cross validation)先将数据集<strong>D</strong> <strong>划分为k 个大小相似的互斥子集</strong>， 即<strong>D = D**</strong>1<strong> </strong>∪<strong> </strong>D<strong>**2</strong> <strong>∪**</strong>…<strong> </strong>∪<strong> </strong>D<strong><strong>k</strong></strong>, Di<strong> </strong>∩<strong> </strong>Dj = ø (<strong><strong>i≠</strong></strong>j)<strong> . </strong>每个子集Di 都尽可能保持数据分布的一致性<strong>，即从D 中通过</strong>分层采样<strong>得到. 然后，每次用k-1 个子集的并集作为训练集，余下的那个子集作为测试集;这样就可获得k组训练/测试集，从而可进行k 次训练和测试，最终返回的是这</strong>k 个测试结果的均值<strong>**。</strong>显然，<strong>交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值</strong>，为强调这一点，通常把交叉验证法称为” <strong>k 折**</strong>/倍<strong>**交叉验证</strong>“ (k-fold cross validation). k 最常用的取值是<strong>10</strong> ，此时称为10折交叉验证; 其他常用的k 值有5、20 等.</p><p><img src="http://img0.ph.126.net/qb2MusthyyOYQcTgrg_hog==/1621295865953709417.png" alt=""></p><p>为了<strong>避免其他属性携带的信息被训练集中未出现的属性值”抹去</strong>”，在估计概率值时通常要进行”平滑” (smoothing) ，常用”<strong>拉普拉斯修正</strong>“，所以，P(c)和P(xi|c)修正为：</p><p>其中N 表示训练集D 中可能的类别数，Ni表示第</p><p>与留出法相似，将数据集D 划分为k 个子集同样存在多种划分方式.为<strong>减小因样本划分不同而引入的差别</strong>，<strong>k折交叉验证通常要随机使用不同的划分重复p 次</strong>。最终的评估结果是这<strong>p 次k 折交叉验证结果的均值</strong>，例如常见的有”10 次10 折交叉验证。</p><p>假定数据集D中包含m个样本，若令<strong>k=m</strong> ，则得到了<strong>交叉验证法的一个特例</strong>:<strong>留一法</strong>(Leave- One-Out比，简称LOO) . 显然，<strong>留一法不受随机样本划分方式的影响</strong>，因为m个样本只有唯一的方式划分为<strong>m个子集**</strong>—<strong>**每个子集包含一个样本</strong>;留一法使用的训练集与初始数据集相比只少了一个样本，这就使得在绝大多数情况下，<strong>留一法中被实际评估的模型与期望评估的用D 训练出的模型很相似</strong>.因此，<strong>留一法的评估结果往往被认为比较准确</strong>.然而，留一法也有其<strong>缺陷:在数据集比较大时</strong>，训练m个模型的计算开销可能是难以忍受的(例如数据集包含1 百万个样本，则需训练1 百万个模型)，而这还是在未考虑算法调参的情况下.另外，留一法的估计结果也未必永远比其他评估方法准确;”没有免费的午餐”定理对实验评估方法同样适用.</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 模型评估 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>查准率precision和查全率recall、F1</title>
      <link href="/2018/06/09/%E6%9F%A5%E5%87%86%E7%8E%87precision%E5%92%8C%E6%9F%A5%E5%85%A8%E7%8E%87recall%E3%80%81F1/"/>
      <url>/2018/06/09/%E6%9F%A5%E5%87%86%E7%8E%87precision%E5%92%8C%E6%9F%A5%E5%85%A8%E7%8E%87recall%E3%80%81F1/</url>
      <content type="html"><![CDATA[<p>真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative），分别用TP、FP、TN、FN表示相应样例数，样例总数=TP+FP+TN+FN；分类结果混淆矩阵：</p><table><thead><tr><th>真实情况</th><th>预测结果</th><th></th></tr></thead><tbody><tr><td>正例</td><td>反例</td><td></td></tr><tr><td>正例</td><td>TP（真正例）</td><td>FN（假反例）</td></tr><tr><td>反例</td><td>FP（假正例）</td><td>TN（真反例）</td></tr></tbody></table><p><img src="http://img0.ph.126.net/KEZuAtQ5O-L1OQ3Z-Q07Fw==/6631529560586716227.png" alt=""></p><a id="more"></a><p>查准率（precision）：<strong>被认定为正例的里面，判断正确的比例</strong>。</p><p>查全率（recall）：<strong>真实正例里，被判断出为正例的比例</strong>。</p><p>查准率和查全率是一对矛盾的度量.一般来说，查准率高时，查全率往往偏低;而查全率高时，查准率往往偏低,可以通过P-R曲线来取两者的平衡值</p><p><img src="http://img0.ph.126.net/y0wS5Mk_91uJ6Byf-_1W5Q==/6608245202842946148.png" alt=""></p><p>若一个学习器P-R曲线被另一个学习器的曲线完全”<strong>包住</strong>“,则可断言<strong>后者的性能优于前者</strong>， 例如图中学习器A 的性能优于学习器C; 如果两个学习器的P-R 曲线发生了交叉7,例如图中的A 与B ，则难以一般性地断言两者孰优孰劣，只能在具体的查准率或查全率条件下进行比较然而，在很多情形下，人们往往仍希望把学习器A 与B 比出个高低. 这时一个比较合理的判据是比较<strong>P-R 曲线节面积</strong>的大小。</p><p>“<strong>平衡点</strong>“是”<strong>查准率=查全率</strong>“时的取值。</p><p>但更常用的使用<strong>F1</strong>来衡量查准率与查全率；</p><p>F1基于查准率与查全率的<strong>调和平均：</strong><img src="http://img0.ph.126.net/yg8YAE8RHL175oCy3vjc3g==/6632743421421514260.png" alt=""></p><p><img src="http://img0.ph.126.net/jpR5P7LKuB3AzZtvxzj_EA==/6631628516633222094.png" alt="">，sum为样例总数，</p><p>具体应用中可能对P和R有不同的倚重。比如<strong>商品推荐</strong>中，为了尽可能少打扰用户，更希望推荐内容确是用户感兴趣的，这时候<strong>查准率更重要</strong>。而在<strong>逃犯检索系统</strong>中，更希望尽可能少漏掉逃犯，此时<strong>查全率更重要</strong>。</p><p>F1度量的一般形式<strong>F**</strong>β<strong>（</strong>加权调和平均**）就可以表达这种偏好。 </p><p><img src="http://img2.ph.126.net/QSkXIzD2uBJSYNeqVKXbnA==/2291206310525129759.png" alt="">即  <img src="http://img2.ph.126.net/mlX2uGe9BlIO58oi64A-6w==/6632646664398271337.png" alt=""></p><p><strong>ß = 1时退化为标准的F1,当β&gt;1意味着P占比重更大</strong>，<strong>反之则是R</strong>。</p><h5 id="ROC、AUC"><a href="#ROC、AUC" class="headerlink" title="ROC、AUC"></a><strong>ROC、AUC</strong></h5><p><strong>ROC</strong>:全称“<strong>受试者工作特征</strong>”，<strong>表达了模型的泛化能力</strong>。其纵坐标为“<strong>TPR真正例率</strong>”；横坐标为“<strong>FPR假正例率</strong>”。</p><p><strong>ROC曲线根据模型的排序结果，一个个划分正负</strong>，每次得出两个值TPR,FPR。很多学习器是为测试样本产生一个<strong>实值</strong>或<strong>概率预测</strong>，然后将这个预测值与一个分类阈值进行比较，若大于阈值则分为正类，否则为反类。为啥在ROC曲线画一个y=x呢，那表示<strong>随机猜测的ROC</strong>。</p><p><strong>AUC:ROC曲线下的面积</strong>.AUC=1,是完美分类器(并不存在)；0.5。<strong>AUC 越大，意味着辨别能力越强</strong>。</p><p>与P-R图相似，如果一条ROC曲线<strong>包含另一条</strong>ROC曲线，则<strong>前者的学习器性能更优越</strong>。如果<strong>曲线有交叉</strong>，则可以通过<strong>计算AUC</strong>大小得到。</p><h5 id="代价敏感错误率、代价曲线"><a href="#代价敏感错误率、代价曲线" class="headerlink" title="代价敏感错误率、代价曲线"></a><strong>代价敏感错误率、代价曲线</strong></h5><p><strong>代价敏感错误率</strong>：<strong>为不同错误类型赋予不同的权重</strong>。<strong>不同类型的错误所造成的后果不同</strong>.例如在<strong>医疗诊断</strong>中，错误地把患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了”一次错误”但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机;再如，<strong>门禁系统</strong>错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可<strong>为错误赋予”非均等代价”</strong> 。</p><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”<strong>代价曲线</strong>“ 则可达到该目的.代价曲线图的<strong>横轴是取值为[0，1]的正例概率代价;纵轴是取值为[0，1] 的归一化代价。</strong></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 性能评估 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>偏差、方差、噪声</title>
      <link href="/2018/06/09/%E5%81%8F%E5%B7%AE%E3%80%81%E6%96%B9%E5%B7%AE%E3%80%81%E5%99%AA%E5%A3%B0/"/>
      <url>/2018/06/09/%E5%81%8F%E5%B7%AE%E3%80%81%E6%96%B9%E5%B7%AE%E3%80%81%E5%99%AA%E5%A3%B0/</url>
      <content type="html"><![CDATA[<p><strong>代价敏感错误率</strong>：<strong>为不同错误类型赋予不同的权重</strong>。<strong>不同类型的错误所造成的后果不同</strong>.例如在<strong>医疗诊断</strong>中，错误地把患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了”一次错误”但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机;再如，<strong>门禁系统</strong>错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可<strong>为错误赋予”非均等代价”</strong> 。</p><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”<strong>代价曲线</strong>“ 则可达到该目的.代价曲线图的<strong>横轴是取值为[0，1]的正例概率代价;纵轴是取值为[0，1] 的归一化代价。</strong></p><h4 id="偏差（Bias）和方差（Variance）"><a href="#偏差（Bias）和方差（Variance）" class="headerlink" title="偏差（Bias）和方差（Variance）"></a><strong>偏差（Bias）和方差（Variance）</strong></h4><p><strong>偏差（Bias）</strong>：描述的是<strong>预测值（估计值）的期望与真实值之间的差距</strong>。<strong>偏差越大，越偏离真实数据</strong>。</p><p><strong>方差（Variance）</strong>：描述的是<strong>预测值的变化范围，离散程度</strong>，也就是离其期望值的距离。<strong>方差越大，数据的分布越分散</strong>。</p><p><img src="http://img2.ph.126.net/r1haOaQD_onwqs9zl_4gqw==/6632693943398259845.png" alt=""></p><a id="more"></a><p><strong>偏差：形容数据跟我们期望的中心差得有多远</strong>，算是“有监督的”，有人的知识参与指标；</p><p><strong>方差：形容数据分散程度</strong>的，算是“无监督的”，客观的指标。</p><p><strong>噪声</strong>：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>刻画了学习问题本身的难度</strong>.</p><p>偏差一方差分解说明，<strong>泛化性能</strong>是由<strong>学习算法的能力</strong>、<strong>数据的充分性</strong>以及<strong>学习任务本身的难度</strong>所共同决定的.</p><p>给定学习任务，为了取得好的泛化性能，则需使<strong>偏差较小</strong>，即<strong>能够充分拟合数据</strong>，并且使<strong>方差较小</strong>，即<strong>使得数据扰动产生的影响小</strong>.</p><p>一般来说偏差与方差是有冲突的，这称为<strong>偏差—方差窘境</strong>，给定学习任务，假定我们能控制学习算法的<strong>训练程度</strong>（例如<strong>决策树可控制层数</strong>，<strong>神经网络可控制训练轮数</strong>，<strong>集成学习方法可控制基学习器个数</strong>），则在<strong>训练不足时</strong>，<strong>学习器的拟合能力不够强</strong>，训练数据的扰动不足以便学习器产生显著变化，此时<strong>偏差主导了泛化错误率</strong>;<strong>随着训练程度的加深</strong>，<strong>学习器的拟合能力逐渐增强</strong>，训练数据发生的扰动渐渐能被学习器学到，<strong>方差逐渐主导了泛化错误率</strong>;<strong>在训练程度充足后，学习器的拟合能力已非常强，训练数据发生的轻微扰动都会导致学习器发生显著变化，若训练数据自身的、非全局的特性被学习器学到了，则将发生过拟合</strong>.</p><p><img src="http://img0.ph.126.net/Pf_BHxPZBFJ3I9qDD82fFA==/6597626119542477447.png" alt=""></p><p>为什么<strong>KNN</strong>（k最近邻k-Nearest Neighbor）算法在<strong>增大k时，偏差会变大</strong>；但<strong>RF</strong>（Random Forest随机森林）<strong>增大树的数目时偏差却保持不变</strong>；<strong>GBDT</strong>（Gradient Boosting）在<strong>增大树的数目时偏差却又能变小</strong>。</p><p>对于KNN算法，<strong>k值越大，表示模型的学习能力越弱</strong>，因为<strong>k越大，它越倾向于从“面”上考虑做出判断，而不是具体地考虑一个样本近身的情况来做出判断</strong>，所以，它的<strong>偏差会越来越大</strong>。</p><p>对于<strong>RF</strong>，我们实际上是<strong>部分实现了多次训练取均值的效果</strong>，<strong>每次训练得到的树都是一个很强的学习者</strong>，<strong>每一个的方差都比较大，但综合起来就会比较小</strong>。好比一个很强的学习者学习时，刮着西风，它会据此调整自己的瞄准方法，另一个很强的学习者学习时刮着东风，（西风、东风可以理解为不同训练集中的<strong>噪声</strong>）它也会据此调整自己的瞄准方法，在测试样本时，<strong>一个误差向西，一个误差向东，刚好起到互相抵消的作用，所以方差会比较小。但是由于每棵树的偏差都差不多，所以，我们取平均时，偏差不会怎么变化</strong>。</p><p>为什么说是<strong>部分</strong>实现了多次训练取均值的效果而不是全部呢？因为我们在训练各棵树时，是通过<strong>抽样样本集来实现多次训练</strong>的，<strong>不同的训练集中不可避免地会有重合的情况</strong>，此时，就<strong>不能认为是独立的多次训练了，各个训练得到的树之间的方差会产生一定的相关性</strong>，训练集中重合的样本越多，则两棵树之间的方差的相关性越强，就越难达成方差互相抵消的效果。</p><p>对于<strong>GBDT</strong>，<strong>N棵树之间根本就不是一种多次训练取均值的关系，而是N棵树组成了相关关联，层层递进的超级学习者</strong>，可想而知，它的<strong>方差一定是比较大</strong>的。但由于它的<strong>学习能力比较强</strong>，所以，它的<strong>偏差是很小</strong>的，而且树的<strong>棵树越多，学习能力就越强，偏差就越小</strong>。也就是说，只要学习次数够多，预测的均值会无限接近于目标。简单讲就是<strong>GBDT的N棵树实际上是一个有机关联的模型，不能认为是N个模型</strong>。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 性能评估 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最长公共子串-最长公共子序列</title>
      <link href="/2018/06/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/06/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a><strong>最长公共子串</strong></h3><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubStr</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.length();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.length();</span><br><span class="line"><span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [len1][len2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;<span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">if</span>(dp[i][j] &gt; result) &#123;</span><br><span class="line">result = dp[i][j];</span><br><span class="line">index = i;<span class="comment">// 记录最大子串的最后一个下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result = result &gt; dp[i][j] ? result : dp[i][j];</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">result = result &gt; dp[i][j] ? result : dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index - result + <span class="number">1</span>; i &lt;= index; i++) &#123;</span><br><span class="line">System.out.print(str1.charAt(i) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><strong>最长公共子序列</strong></h3><p>####动态规划<br>假设Z=&lt;z1,z2,⋯,zk&gt;是X与Y的LCS， 我们观察到<br>如果Xm=Yn，则Zk=Xm=Yn，有Zk−1是Xm−1与Yn−1的LCS；<br>如果Xm≠Yn，则Zk是Xm与Yn−1的LCS，或者是Xm−1与Yn的LCS。<br>因此，求解LCS的问题则变成递归求解的两个子问题。但是，上述的递归求解的办法中，重复的子问题多，效率低下。改进的办法——用空间换时间，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了。<br>DP求解LCS<br>用二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度，则可得到状态转移方程</p><h3 id="DP实现-1"><a href="#DP实现-1" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.length();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.length();</span><br><span class="line"><span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] &gt; dp[i][j-<span class="number">1</span>] ? dp[i-<span class="number">1</span>][j] : dp[i][j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> dp[len1-<span class="number">1</span>][len2-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP-单词拆分 I</title>
      <link href="/2018/06/09/DP-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20I/"/>
      <url>/2018/06/09/DP-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20I/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><a id="more"></a><p>示例 2：<br>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a><strong>算法思路</strong></h3><p>动态规划的思路：<br>将问题拆分成更小的子问题。用dp[i]表示0到i的子字符串是否可以拆分成满足条件的单词，在计算dp[i]的时候，我们已经知道dp[0],dp[1],…,dp[i-1],如果以i为结尾的j~i子串是满足条件的，并且0~j的子串也是在字典中的，那么dp[i]就是true。<br>用公式表示就是：</p><font color="red" size="5"><strong>dp[j]&amp;&amp;s.substring[j,i+1]∈dict</strong></font><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;;</span><br><span class="line">        <span class="keyword">boolean</span> [] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>]；</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS解法，超时"><a href="#DFS解法，超时" class="headerlink" title="DFS解法，超时"></a><strong>DFS解法，超时</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; wordDict, <span class="keyword">int</span> index)</span></span>&#123; <span class="comment">// 超时</span></span><br><span class="line">        String left = s.substring(index, s.length());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            String temp = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer each:list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(s, wordDict, each))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬虫</title>
      <link href="/2018/06/09/Python%E7%88%AC%E8%99%AB/"/>
      <url>/2018/06/09/Python%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h2 id="文本爬取"><a href="#文本爬取" class="headerlink" title="文本爬取"></a><strong>文本爬取</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests,urllib3.request,time,os</span><br><span class="line"><span class="keyword">import</span> random,csv,socket,http.client</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contend</span><span class="params">(url, data = None)</span>:</span>  <span class="comment">#获取网页中html代码</span></span><br><span class="line">    header=&#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">        &#125;</span><br><span class="line">    timeout = random.choice(range(<span class="number">80</span>,<span class="number">180</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rep = requests.get(url,headers = header,timeout=timeout)</span><br><span class="line">            rep.encoding = <span class="string">'utf-8'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'3'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">8</span>,<span class="number">15</span>))</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'4'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">20</span>,<span class="number">60</span>))</span><br><span class="line">        <span class="keyword">except</span> http.client.BadStatusLine <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'5'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">30</span>,<span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> http.client.IncompleteRead <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'6'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">5</span>,<span class="number">15</span>))</span><br><span class="line">    <span class="keyword">return</span> rep.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(html_text)</span>:</span></span><br><span class="line">    final = []</span><br><span class="line">    bs = BeautifulSoup(html_text,<span class="string">'html.parser'</span>) <span class="comment">#创建BeautifulSoup对象</span></span><br><span class="line">    body = bs.body  <span class="comment">#获取body部分</span></span><br><span class="line">    data = body.find(<span class="string">'div'</span>,&#123;<span class="string">'id'</span>:<span class="string">'7d'</span>&#125;) <span class="comment">#找到需要爬取部分的div</span></span><br><span class="line">    ul = data.find(<span class="string">'ul'</span>)   <span class="comment">#获取ul部分</span></span><br><span class="line">    li = ul.find_all(<span class="string">'li'</span>)  <span class="comment">#获取所有的li</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> li:  <span class="comment">#对li标签中内容进行遍历</span></span><br><span class="line">        temp = []</span><br><span class="line">        date =day.find(<span class="string">'h1'</span>).string <span class="comment">#找到日期</span></span><br><span class="line">        temp.append(date)   <span class="comment">#将日期添加到temp中</span></span><br><span class="line">        p = day.find_all(<span class="string">'p'</span>)   <span class="comment">#找到每个li中的所有p标签</span></span><br><span class="line">        temp.append(p[<span class="number">0</span>].string,)    <span class="comment">#第一个p标签中的天气状况添加到temp</span></span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>].find(<span class="string">'span'</span>) == <span class="keyword">None</span>:</span><br><span class="line">            t_highest = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t_highest = p[<span class="number">1</span>].find(<span class="string">'span'</span>).string    <span class="comment">#找到最高温</span></span><br><span class="line">            t_highest = t_highest.replace(<span class="string">'C'</span>,<span class="string">''</span>)</span><br><span class="line">        t_lowest = p[<span class="number">1</span>].find(<span class="string">'i'</span>).string  <span class="comment"># 找到最低温</span></span><br><span class="line">        t_lowest = t_lowest.replace(<span class="string">'C'</span>,<span class="string">''</span>)</span><br><span class="line">        temp.append(t_highest)</span><br><span class="line">        temp.append(t_lowest)</span><br><span class="line">        final.append(temp)</span><br><span class="line">    <span class="keyword">return</span> final</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(data,name)</span>:</span>  <span class="comment">#将数据写入文件</span></span><br><span class="line">    file_name = name</span><br><span class="line">    <span class="keyword">with</span> open(file_name, <span class="string">'a'</span>, errors=<span class="string">'ignore'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_csv = csv.writer(f)</span><br><span class="line">        f_csv.writerows(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://www.weather.com.cn/weather/101190401.shtml'</span></span><br><span class="line">    html = get_contend(url)</span><br><span class="line">    result = get_data(html)</span><br><span class="line">    print(result)</span><br><span class="line">    write_data(result,<span class="string">'weather.csv'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="图虫图片爬取"><a href="#图虫图片爬取" class="headerlink" title="图虫图片爬取"></a><strong>图虫图片爬取</strong></h2><h2 id="按标签爬取"><a href="#按标签爬取" class="headerlink" title="按标签爬取"></a><strong>按标签爬取</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">__author__ = <span class="string">'Result_Lv'</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_json</span><span class="params">(url)</span>:</span></span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">              <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">              <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">              <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">              &#125;</span><br><span class="line">    rep = requests.get(url, headers = header)   <span class="comment">#请求json地址</span></span><br><span class="line">    json_dict = json.loads(rep.text)            <span class="comment">#解析json</span></span><br><span class="line">    <span class="keyword">return</span> json_dict                            <span class="comment">#返回json字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_album_name</span><span class="params">(json_dict)</span>:</span></span><br><span class="line">    album_name = []</span><br><span class="line">    postlist = json_dict[<span class="string">'postList'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postlist)):</span><br><span class="line">        <span class="keyword">if</span> postlist[i][<span class="string">'title'</span>] == <span class="string">''</span>:                  <span class="comment">#图集标题为空时，命名为默认</span></span><br><span class="line">            album_name.append(<span class="string">'Default'</span> + str(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            album_name.append(postlist[i][<span class="string">'title'</span>])</span><br><span class="line">    <span class="keyword">return</span> album_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_photo_id</span><span class="params">(json_dict)</span>:</span>   <span class="comment">#获得所有照片的ID</span></span><br><span class="line">    author_id = []</span><br><span class="line">    album_id = []</span><br><span class="line">    post_list = json_dict[<span class="string">'postList'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(post_list)):                                     <span class="comment">#获取每个图集的照片ID</span></span><br><span class="line">        photo_id = []</span><br><span class="line">        author_id.append(post_list[i][<span class="string">'author_id'</span>])                     <span class="comment"># 获取每个图集作者ID</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(post_list[i][<span class="string">'images'</span>])):</span><br><span class="line">            photo_id.append(post_list[i][<span class="string">'images'</span>][j][<span class="string">'img_id'</span>])        <span class="comment">#将所有每个图集里的照片全部添加到list</span></span><br><span class="line">        album_id.append(photo_id)</span><br><span class="line">    <span class="keyword">return</span> author_id,album_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_album</span><span class="params">(path,album_name,author_id,album_id)</span>:</span>     <span class="comment">#下载图集</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(album_id)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path + album_name[i]):        <span class="comment">#若不存在对应图集的文件夹</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.makedirs(path + album_name[i])           <span class="comment">#以图集名创建文件夹</span></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">'正在下载第'</span> + str(i + <span class="number">1</span>) + <span class="string">'个图册:'</span> + album_name[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(album_id[i])):</span><br><span class="line">            fileurl = <span class="string">'https://photo.tuchong.com/'</span> + str(author_id[i]) +<span class="string">'/f/'</span> + str(album_id[i][j]) + <span class="string">'.jpg'</span>    <span class="comment">#生成每张照片Url</span></span><br><span class="line">            filename = path + album_name[i] + <span class="string">'/'</span> + str(j+<span class="number">1</span>) + <span class="string">'.jpg'</span>                                           <span class="comment">#命名照片</span></span><br><span class="line">            print(<span class="string">'    正在下载第'</span> + str(j+<span class="number">1</span>) + <span class="string">'张照片:'</span> + fileurl)</span><br><span class="line">            <span class="keyword">with</span> open(filename,<span class="string">'w'</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    request.urlretrieve(fileurl,filename)   <span class="comment">#下载照片</span></span><br><span class="line">                    time.sleep(np.random.rand())            <span class="comment">#下载间隔</span></span><br><span class="line">                <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">                    print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    page = <span class="number">3</span>              <span class="comment">#爬取页数</span></span><br><span class="line">    path = <span class="string">'F:/少女/'</span>     <span class="comment">#存放路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(page):</span><br><span class="line">        url = <span class="string">'https://tuchong.com/rest/tags/少女/posts?page='</span> + str(i+<span class="number">1</span>) + <span class="string">'&amp;count=20&amp;order=weekly'</span>  <span class="comment">#tag的json地址</span></span><br><span class="line">        json_dict = get_json(url)</span><br><span class="line">        album_name = get_album_name(json_dict)</span><br><span class="line">        para = get_photo_id(json_dict)</span><br><span class="line">        author_id = para[<span class="number">0</span>]</span><br><span class="line">        album_id = para[<span class="number">1</span>]</span><br><span class="line">        download_album(path,album_name,author_id,album_id)</span><br></pre></td></tr></table></figure><h3 id="按作者爬取"><a href="#按作者爬取" class="headerlink" title="按作者爬取"></a><strong>按作者爬取</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_json</span><span class="params">(url)</span>:</span>  <span class="comment">#解析json</span></span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">              <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">              <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">              <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">              &#125;</span><br><span class="line">    rep = requests.get(url, headers = header)   <span class="comment">#请求json地址</span></span><br><span class="line">    json_dict = json.loads(rep.text)            <span class="comment">#解析json</span></span><br><span class="line">    <span class="keyword">return</span> json_dict                            <span class="comment">#返回json字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_photo_id</span><span class="params">(json_dict)</span>:</span>   <span class="comment">#获得所有照片的ID</span></span><br><span class="line">    <span class="comment">#post_id = []</span></span><br><span class="line">    photo_id = []</span><br><span class="line">    post_list = json_dict[<span class="string">'post_list'</span>]</span><br><span class="line">    author_id = post_list[<span class="number">0</span>][<span class="string">'author_id'</span>]                               <span class="comment">#获取作者ID</span></span><br><span class="line">    author_name = post_list[<span class="number">0</span>][<span class="string">'site'</span>][<span class="string">'name'</span>]                          <span class="comment">#获取作者姓名</span></span><br><span class="line">    <span class="comment"># for i in range(len(post_list)):                                   #获取所有图集ID</span></span><br><span class="line">    <span class="comment">#     post_id.append(post_list[i]['post_id'])</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(post_list)):                                     <span class="comment">#获取每个图集的照片ID</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(post_list[i][<span class="string">'images'</span>])):</span><br><span class="line">            photo_id.append(post_list[i][<span class="string">'images'</span>][j][<span class="string">'img_id'</span>])        <span class="comment">#将所有每个图集里的照片全部添加到list</span></span><br><span class="line">    <span class="keyword">return</span> author_name,author_id,photo_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_photo</span><span class="params">(path,author_id,photo_id)</span>:</span>    <span class="comment">#下载全部照片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(photo_id)):</span><br><span class="line">        filename = path + <span class="string">'/'</span> + str(i+<span class="number">1</span>) + <span class="string">'.jpg'</span></span><br><span class="line">        fileurl = <span class="string">'https://photo.tuchong.com/'</span> + str(author_id) + <span class="string">'/f/'</span> + str(photo_id[i]) + <span class="string">'.jpg'</span></span><br><span class="line">        print(<span class="string">'    第'</span> + str(i + <span class="number">1</span>) + <span class="string">'张图片:'</span> + fileurl)</span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'w'</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                request.urlretrieve(fileurl,filename)   <span class="comment">#下载照片</span></span><br><span class="line">                time.sleep(np.random.rand())            <span class="comment">#下载间隔</span></span><br><span class="line">            <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    page = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(page):</span><br><span class="line">        url = <span class="string">'https://thomaskksj.tuchong.com/rest/2/sites/395013/posts?count=20&amp;page='</span> + str(i + <span class="number">1</span>)  <span class="comment">#作者主页的json地址</span></span><br><span class="line">        print(<span class="string">'正在下载第'</span> + str(i+<span class="number">1</span>) + <span class="string">'页:'</span> + url)</span><br><span class="line">        json_dict = get_json(url)</span><br><span class="line">        para = get_all_photo_id(json_dict)</span><br><span class="line">        author_name = para[<span class="number">0</span>]</span><br><span class="line">        author_id = para[<span class="number">1</span>]</span><br><span class="line">        photo_id = para[<span class="number">2</span>]</span><br><span class="line">        path = <span class="string">'F:/'</span> + author_name + <span class="string">'/page'</span> + str(i + <span class="number">1</span>)</span><br><span class="line">        download_photo(path,author_id,photo_id)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP+回溯-单词拆分 II</title>
      <link href="/2018/06/09/DP+%E5%9B%9E%E6%BA%AF-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/"/>
      <url>/2018/06/09/DP+%E5%9B%9E%E6%BA%AF-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。<br>说明：<br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>“cats and dog”,<br>“cat sand dog”<br>]</p><a id="more"></a><p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>“pine apple pen apple”,<br>“pineapple pen apple”,<br>“pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a><strong>算法思路</strong></h3><p>这道题类似 Word Break I 判断是否能把字符串拆分为字典里的单词 @LeetCode 只不过要求计算的并不仅仅是是否能拆分，而是要求出所有的拆分方案。因此用递归。<br>但是直接递归做会超时，原因是LeetCode里有几个很长但是无法拆分的情况，所以就先跑一遍Word Break I，先判断能否拆分，然后再进行拆分。</p><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span>[] canBreak = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];  </span><br><span class="line">        canBreak[<span class="number">0</span>] = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=s.length(); i++) &#123;  </span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(canBreak[j] &amp;&amp; wordDict.contains(s.substring(j,i))) &#123;  </span><br><span class="line">                    flag = <span class="keyword">true</span>;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            canBreak[i] = flag;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> canBreak[s.length()];  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; wordDict, String str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        String result = str;            <span class="comment">//记录字符串状态</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        String tmp = s.substring(index, len);</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(tmp))&#123;     <span class="comment">//最后一段存在于字典中，则保存结果</span></span><br><span class="line">            str += tmp;</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; listIndex = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;String&gt; listStr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; len; i++)&#123;</span><br><span class="line">            String temp = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                listIndex.add(i+<span class="number">1</span>);</span><br><span class="line">                listStr.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = result;   <span class="comment">//保存递归前的字符串状态，以便回溯</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listIndex.size(); i++)&#123;</span><br><span class="line">            result += listStr.get(i) + <span class="string">" "</span>;</span><br><span class="line">            dfs(s, wordDict, result, listIndex.get(i));</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isBreak(s, wordDict)) <span class="keyword">return</span> res;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        dfs(s, wordDict, str, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/2018/06/09/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/09/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-GitHub搭建个人博客"><a href="#Hexo-GitHub搭建个人博客" class="headerlink" title="Hexo+GitHub搭建个人博客"></a>Hexo+GitHub搭建个人博客</h1><p>目录：</p><p><strong>前言</strong>：</p><ul><li>​    准备工作</li></ul><p>搭建github博客</p><ul><li>​    创建仓库<br>   ​    绑定域名</li></ul><p><strong>配置SSH key</strong></p><ul><li>​    测试是否成功</li></ul><p><strong>使用hexo写博客</strong></p><ul><li>​    hexo简介<br>   ​    原理<pre><code>    注意事项    安装    初始化​    修改主题​    上传到github    保留CNAME、README.md等文件    常用hexo命令​    _config.yml    写博客        </code></pre></li></ul><p><strong>最终效果</strong></p><a id="more"></a><p><a href="https://dadavision.cn/" target="_blank" rel="noopener">https://dadavision.cn/</a></p><p><strong>技巧</strong></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol><h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1. 准备工作"></a>1.1. 准备工作</h2><p>在开始一切之前，你必须已经：</p><ul><li>有一个github账号，没有的话去注册一个；</li><li>安装了node.js、npm，并了解相关基础知识；</li><li>安装了git for windows（或者其它git客户端）</li></ul><p>本文所使用的环境：</p><ul><li>Windows10企业版</li><li><a href="mailto:node.js@8.11.2" target="_blank" rel="noopener">node.js@8.11.2</a></li><li><a href="mailto:git@2.17.1" target="_blank" rel="noopener">git@2.17.1</a></li><li><a href="mailto:hexo@3.7.1" target="_blank" rel="noopener">hexo@3.7.1</a></li></ul><h1 id="2-搭建github博客"><a href="#2-搭建github博客" class="headerlink" title="2.搭建github博客"></a>2.搭建github博客</h1><h2 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1. 创建仓库"></a>2.1. 创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li></ol><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2. 绑定域名"></a>2.2. 绑定域名</h2><p>当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p><p>首先你要注册一个域名，域名注册以前总是推荐去<code>godaddy</code>，现在觉得其实国内的阿里云、腾讯云也挺不错的，价格也不贵，毕竟是大公司，放心！或者说万网，本质上都是在万网上。</p><p>绑定域名分2种情况：带www和不带www的。</p><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-88e308cf654d0fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p><ul><li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a></li><li>如果你填写的是带www的，比如 <a href="http://www.mygit.me" target="_blank" rel="noopener">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a></li><li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a></li></ul><p>另外说一句，在你绑定了新域名之后，原来的<code>你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p><h1 id="3-配置SSH-key"><a href="#3-配置SSH-key" class="headerlink" title="3.配置SSH key"></a>3.配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0b20424399a4d60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>将刚复制的内容粘贴到key那里，title随便填，保存。 </p><h2 id="3-1-测试是否成功"><a href="#3-1-测试是否成功" class="headerlink" title="3.1. 测试是否成功"></a>3.1. 测试是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！</p><p>此时你还需要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;dadavision&quot;// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;dadavision@qq.com&quot;// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>具体这个配置是干嘛的我没仔细深究。</p><h1 id="4-使用hexo写博客"><a href="#4-使用hexo写博客" class="headerlink" title="4.使用hexo写博客"></a>4.使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1. hexo简介"></a>4.1. hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p><h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2. 原理"></a>4.2. 原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h2><p>安装之前先来说几个注意事项：</p><ol><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li><li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li></ol><h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4. 安装"></a>4.4. 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5. 初始化"></a>4.5. 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\Workspaces\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /f/GitBlog/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-ff306eee584e3fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里有个’更新博客’，这里涉及一个技巧，后面讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动服务</span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0e2b9101fa5c2bcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，可以用<code>hexo clean</code>。</p><p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。</p><h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6. 修改主题"></a>4.6. 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。</p><p>个人比较喜欢的2个主题：<a href="https://github.com/pinggod/hexo-theme-jekyll" target="_blank" rel="noopener">hexo-theme-jekyll</a> 和 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>。</p><p>首先下载这个主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /f/Workspaces/hexo/</span><br><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载后的主题都在这里：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-11b9df349f6a787c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><p>另外一种更方便的方式是：</p><p>我用的next主题。</p><p>直接从官网github上，clone down下来，解压后直接放进文件夹更快。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-b1f01b0333d6ae3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: next</code>，然后重新执行<code>hexo g</code>来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7. 上传之前"></a>4.7. 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="4-8-上传到github"><a href="#4-8-上传到github" class="headerlink" title="4.8. 上传到github"></a>4.8. 上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:DaDaVision/DaDaVision.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com:DaDaVision/DaDaVision.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure><p>原因是还需要安装一个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p><p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会.</p><h2 id="4-9-保留CNAME、README-md等文件"><a href="#4-9-保留CNAME、README-md等文件" class="headerlink" title="4.9. 保留CNAME、README.md等文件"></a>4.9. 保留CNAME、README.md等文件</h2><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-1f808e15286a9be8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p><hr><p>这里需要注意：</p><p>在添加绑定域名后需要注意以下问题（未绑定可以不用）</p><p>需要将github上CNAME里面内容在文件工程中GitBlog\source\CNAME</p><p>这里注意新建的CNAME不要有后缀名。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3eb1866b15f4f46d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2c825d1db371b855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10. 常用hexo命令"></a>4.10. 常用hexo命令</h2><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h2 id="4-11-config-yml"><a href="#4-11-config-yml" class="headerlink" title="4.11. _config.yml"></a>4.11. _config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p><p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><h2 id="4-12-写博客"><a href="#4-12-写博客" class="headerlink" title="4.12. 写博客"></a>4.12. 写博客</h2><p>定位到我们的hexo根目录，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;哈喽&apos;</span><br></pre></td></tr></table></figure><p>hexo会帮我们在<code>_posts</code>下生成相关md文件，我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-1ce797798b38d5be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2018-7-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;my-second-blog&quot;</span><br></pre></td></tr></table></figure><p>生成如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6c7fed837d3f5ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最终部署时生成：<code>GitBlog\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。 </p><h3 id="4-12-1-写博客工具"><a href="#4-12-1-写博客工具" class="headerlink" title="4.12.1. 写博客工具"></a>4.12.1. 写博客工具</h3><p>那么用什么工具写博客呢？</p><p>推荐用Typora和Hbuilder X。</p><h3 id="4-12-2-如何让博文列表不显示全部内容"><a href="#4-12-2-如何让博文列表不显示全部内容" class="headerlink" title="4.12.2. 如何让博文列表不显示全部内容"></a>4.12.2. 如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可。</p><h1 id="5-最终效果"><a href="#5-最终效果" class="headerlink" title="5.最终效果"></a>5.最终效果</h1><p>可以访问我的git博客来查看效果：<a href="https://dadavision.cn" target="_blank" rel="noopener">https://dadavision.cn</a></p><h1 id="6-技巧"><a href="#6-技巧" class="headerlink" title="6.技巧"></a>6.技巧</h1><p>其中生成，上传github有很多命令，以下方法可以减少繁琐，就是创建.bat批处理文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">cd GitBlog</span><br><span class="line">hexo clean &amp; hexo g &amp;&amp; gulp &amp; hexo d &amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/12654931-9a1c787ea7b7e0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>还可以设置全局快捷键：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-45711fa97293b226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> next </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分糖果</title>
      <link href="/2018/06/09/%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2018/06/09/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>o 分糖果：科大讯飞第二道编程题</p><p>o 小明和小红是好朋友，但最近遇到一个棘手的问题，有一盒糖果要分成两份但是每颗糖果质量都不尽相同，</p><p>o 但为了分配的公平每份糖的糖果数量相差不得超过1，在此条件下两份糖果的质量差距尽可能小。</p><p>o 输入一行数，包含一个数n，代表糖果数量，后面一次是n个整数一次表示每个糖果的质量，每个糖果的质量都是1到450</p><p>o 之间的一个整数，每盒最多有20个糖果。</p><p>o 输出：每个样例输出两个数字分别为两堆糖果的质量，如不相同，先小后大。</p><p>o 样例：输入：5 9 6 5 8 7</p><p>o 输出：17 18</p><a id="more"></a><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h3><p>o 回溯，在数量差值为1的结果中找出最小的质量差</p><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a><strong>Python实现</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(candies, num, select, sum, total, index)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> min</span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    <span class="keyword">if</span>(abs(total-sum*<span class="number">2</span>) &lt; min):</span><br><span class="line">        res = sum</span><br><span class="line">        min = abs(total-sum*<span class="number">2</span>)</span><br><span class="line">        result.append(select)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candies)):</span><br><span class="line">        <span class="keyword">if</span>(index == num<span class="number">-1</span>): return3</span><br><span class="line">        select.append(candies[index])</span><br><span class="line">        sum += candies[index]</span><br><span class="line">        temp = select.copy()</span><br><span class="line">        <span class="keyword">if</span>(len(select) &lt;= int(num/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            divide(candies, num, temp, sum, total, index)</span><br><span class="line">        sum -= select[len(select) - <span class="number">1</span>]</span><br><span class="line">        select.remove(select[len(select)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回溯法思想</title>
      <link href="/2018/06/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>/2018/06/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      <content type="html"><![CDATA[<h3 id="子集树与排列树"><a href="#子集树与排列树" class="headerlink" title="子集树与排列树"></a><strong>子集树与排列树</strong></h3><p>当所给问题是从n个元素的集合S中找出满足某种性质的子集时，解空间为子集树。<br>例如：0-1背包问题 (选或不选问题)<br>当所给问题是从n个元素的集合S中找出满足某种性质的排列时，解空间为排列树。<br>例如：旅行售货员问题（选择顺序问题）</p><h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a><strong>算法结构</strong></h3><p><img src="http://img0.ph.126.net/gCNuXL5Bfja8EblAZBh3rA==/2607021234314375610.png" alt=""></p><a id="more"></a><h3 id="深度优先搜索与广度优先搜索算法有何区别"><a href="#深度优先搜索与广度优先搜索算法有何区别" class="headerlink" title="深度优先搜索与广度优先搜索算法有何区别"></a><strong>深度优先搜索与广度优先搜索算法有何区别</strong></h3><p>深度优先搜索法不全部保留结点，扩展完的结点从数据存储结构栈中弹出删去，在栈中存储的结点数就是解空间树的深度，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。<br>广度优先搜索算法，一般需存储产生所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作（即入栈和出栈的操作），所以运行速度比深度优先搜索要快些。</p><h3 id="回溯与分支限界区别"><a href="#回溯与分支限界区别" class="headerlink" title="回溯与分支限界区别"></a><strong>回溯与分支限界区别</strong></h3><p>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。它们在问题的解空间树T上搜索的方法不同，适合解决的问题也就不同。一般情况下，回溯法的求解目标是找出T中满足约束条件的所有解的方案，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。相对而言，分支限界算法的解空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。</p><h3 id="最优化处理问题"><a href="#最优化处理问题" class="headerlink" title="最优化处理问题"></a><strong>最优化处理问题</strong></h3><p>在处理最优问题时，采用穷举法、回溯法或分支限界法都可以通过利用当前最优解和上界函数加速。仅就对限界剪支的效率而言，优先队列的分支限界法显然要更充分一些。在穷举法中通过上界函数与当前情况下函数值的比较可以直接略过不合要求的情况而省去了更进一步的枚举和判断；回溯法则因为层次的划分，可以在上界函数值小于当前最优解时，剪去以该结点为根的子树，也就是节省了搜索范围；分支限界法在这方面除了可以做到回溯法能做到的之外，同时若采用优先队列的分支限界法，用上界函数作为活结点的优先级，一旦有叶结点成为当前扩展结点，就意味着该叶结点所对应的解即为最优解，可以立即终止其余的过程。在前面的例题中曾说明，优先队列的分支限界法更象是有选择、有目的地进行搜索，时间效率、空间效率都是比较高的。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a><strong>算法总结</strong></h3><p>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！<br>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h4><p>1.求最优解问题<br>2.整体问题的最优解依赖于各个子问题的最优解<br>3.把大问题分解成小问题，小问题之间还有相互重叠的更小的子问题<br>4.从上往下分析，从下往上求解，避免重复求解小问题</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/08/hello-world/"/>
      <url>/2018/06/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
