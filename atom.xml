<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaDaVision</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-09T10:27:07.150Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tengda Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer（五十三）：表示数值的字符串</title>
    <link href="http://yoursite.com/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-2/"/>
    <id>http://yoursite.com/2018/09/09/剑指Offer（五十三）：表示数值的字符串-2/</id>
    <published>2018-09-09T10:27:07.000Z</published>
    <updated>2018-09-09T10:27:07.150Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十三）：表示数值的字符串</title>
    <link href="http://yoursite.com/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-1/"/>
    <id>http://yoursite.com/2018/09/09/剑指Offer（五十三）：表示数值的字符串-1/</id>
    <published>2018-09-09T10:26:53.000Z</published>
    <updated>2018-09-09T10:26:53.814Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十三）：表示数值的字符串</title>
    <link href="http://yoursite.com/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/09/09/剑指Offer（五十三）：表示数值的字符串/</id>
    <published>2018-09-09T10:26:41.000Z</published>
    <updated>2018-09-09T10:28:40.060Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题还是比较简单的。表示数值的字符串遵循如下模式：</p><p>[sign]integral-digits.[fractional-digits]exponential-digits]</p><p>其中，(‘[‘和’]’之间的为可有可无的部分)。</p><p>在数值之前可能有一个表示正负的’+’或者’-‘。接下来是若干个0到9的数位表示数值的整数部分（在某些小数里可能没有数值的整数部分）。如果数值是一个小数，那么在小数后面可能会有若干个0到9的数位表示数值的小数部分。如果数值用科学记数法表示，接下来是一个’e’或者’E’，以及紧跟着的一个整数（可以有正负号）表示指数。</p><p>判断一个字符串是否符合上述模式时，首先看第一个字符是不是正负号。如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。如果是一个小数，则将遇到小数点。另外，如果是用科学记数法表示的数值，在整数或者小数的后面还有可能遇到’e’或者’E’。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，</span></span><br><span class="line">    <span class="comment">// 其中A和C都是整数（可以有正负号，也可以没有）</span></span><br><span class="line">    <span class="comment">// 而B是一个无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 非法输入处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">NULL</span> || *<span class="built_in">string</span> == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正负号判断</span></span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'+'</span> || *<span class="built_in">string</span> == <span class="string">'-'</span>)&#123;</span><br><span class="line">            ++<span class="built_in">string</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> numeric = <span class="literal">true</span>;</span><br><span class="line">        scanDigits(&amp;<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">string</span> != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 小数判断</span></span><br><span class="line">            <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'.'</span>)&#123;</span><br><span class="line">                ++<span class="built_in">string</span>;</span><br><span class="line">                scanDigits(&amp;<span class="built_in">string</span>);</span><br><span class="line">                <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'e'</span> || *<span class="built_in">string</span> == <span class="string">'E'</span>)&#123;</span><br><span class="line">                    numeric = isExponential(&amp;<span class="built_in">string</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 整数判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">string</span> == <span class="string">'e'</span> || *<span class="built_in">string</span> == <span class="string">'E'</span>)&#123;</span><br><span class="line">                numeric = isExponential(&amp;<span class="built_in">string</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                numeric = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; *<span class="built_in">string</span> == <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 扫描数字，对于合法数字，直接跳过</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scanDigits</span><span class="params">(<span class="keyword">char</span>** <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(**<span class="built_in">string</span> != <span class="string">'\0'</span> &amp;&amp; **<span class="built_in">string</span> &gt;= <span class="string">'0'</span> &amp;&amp; **<span class="built_in">string</span> &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            ++(*<span class="built_in">string</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来潘达un科学计数法表示的数值的结尾部分是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isExponential</span><span class="params">(<span class="keyword">char</span>** <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">        ++(*<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span>(**<span class="built_in">string</span> == <span class="string">'+'</span> || **<span class="built_in">string</span> == <span class="string">'-'</span>)&#123;</span><br><span class="line">            ++(*<span class="built_in">string</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(**<span class="built_in">string</span> == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scanDigits(<span class="built_in">string</span>);</span><br><span class="line">        <span class="comment">// 判断是否结尾，如果没有结尾，说明还有其他非法字符串</span></span><br><span class="line">        <span class="keyword">return</span> (**<span class="built_in">string</span> == <span class="string">'\0'</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十二）：正则表达式匹配</title>
    <link href="http://yoursite.com/2018/09/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2018/09/09/剑指Offer（五十二）：正则表达式匹配/</id>
    <published>2018-09-09T10:24:10.000Z</published>
    <updated>2018-09-09T10:26:26.825Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>请实现一个函数用来匹配包括’.’和’*’的正则表达式。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题有些绕，需要好好思考下。</p><p>我们先来分析下如何匹配一个字符，现在只考虑字符’.’，不考虑’*’看一下：</p><p>如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。</p><p>接下来，把字符’*’考虑进去，它可以匹配任意次的字符，当然出现0次也可以。</p><p>我们分两种情况来看：</p><ul><li>模式串的下一个字符不是’*’，也就是上面说的只有字符’.’的情况。</li></ul><p>如果字符串中的第一个字符和模式串中的第一个字符相匹配，那么字符串的模式串都向后移动一个字符，然后匹配剩余的字符串和模式串。如果字符串中的第一个字符和模式中的第一个字符不相匹配，则直接返回false。</p><ul><li>模式串的下一个字符是’*’，此时就要复杂一些。</li></ul><p>因为可能有多种不同的匹配方式。</p><p>选择一：无论字符串和模式串当前字符相不相等，我们都将模式串后移两个字符，相当于把模式串中的当前字符和’<em>‘忽略掉，因为’</em>‘可以匹配任意次的字符，所以出现0次也可以。</p><p>选择二：如果字符串和模式串当前字符相等，则字符串向后移动一个字符。而模式串此时有两个选择：</p><p>1、我们可以在模式串向后移动两个字符，继续匹配；</p><p>2、也可以保持模式串不变，这样相当于用字符’<em>‘继续匹配字符串，也就是模式串中的字符’</em>‘匹配字符串中的字符多个的情况。</p><p>用一张图表示如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-af5633fd28965d63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如上图所示，当匹配进入状态2，并且字符串中的字符是’a’时，我们有两个选择：可以进入状态3（在模式串向后移动两个字符），也可以回到状态2（模式串保持不变）。</p><p>除此之外，还要注意对空指针的处理。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 指针为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 字符串和模式串都运行到了结尾，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符串没有到结尾，模式串到了，则返回false</span></span><br><span class="line">        <span class="comment">// 模式串没有到结尾，字符串到了，则根据后续判断进行，需要对'*'做处理</span></span><br><span class="line">        <span class="keyword">if</span>((*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果模式串的下一个字符是'*'，则进入状态机的匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果字符串和模式串相等，或者模式串是'.'，并且字符串没有到结尾，则继续匹配</span></span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))&#123;</span><br><span class="line">                <span class="comment">// 进入下一个状态，就是匹配到了一个</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>) ||</span><br><span class="line">                    <span class="comment">// 保持当前状态，就是继续那这个'*'去匹配</span></span><br><span class="line">                    matchCore(str + <span class="number">1</span>, pattern) ||</span><br><span class="line">                    <span class="comment">// 跳过这个'*'</span></span><br><span class="line">                    matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果字符串和模式串不相等，则跳过当前模式串的字符和'*'，进入新一轮的匹配</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 跳过这个'*'</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果字符串和模式串相等，或者模式串是'.'，并且字符串没有到结尾，则继续匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;请实现一个函数用来匹配包括’.’和’*’的正则表达式。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;请实现一个函数用来匹配包括’.’和’&lt;em&gt;‘的正则表达式。模式中的字符’.’表示任意一个字符，而’&lt;/em&gt;‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab&lt;em&gt;ac&lt;/em&gt;a”匹配，但是与”aa.a”和”ab*a”均不匹配。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十九）：把字符串转换成整数</title>
    <link href="http://yoursite.com/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2018/09/08/剑指Offer（四十九）：把字符串转换成整数/</id>
    <published>2018-09-08T14:02:05.000Z</published>
    <updated>2018-09-08T14:05:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><a id="more"></a><p><strong>输入描述：</strong></p><p>输入一个字符串,包括数字字母符号,可以为空</p><p><strong>输出描述：</strong></p><p>如果是合法的数值表达则返回该数字，否则返回0</p><p>示例1</p><p>输入</p><blockquote><p>+2147483647</p><p>1a33</p></blockquote><p>输出</p><blockquote><p>2147483647</p><p>0</p></blockquote><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题要考虑全面，对异常值要做出处理。</p><p>对于这个题目，需要注意的要点有：</p><ul><li>指针是否为空指针以及字符串是否为空字符串；</li><li>字符串对于正负号的处理；</li><li>输入值是否为合法值，即小于等于’9’，大于等于’0’；</li><li>int为32位，需要判断是否溢出；</li><li>使用错误标志，区分合法值0和非法值0。</li></ul><p>代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，minus标志位用来表示是否为负数。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status&#123;kValid = <span class="number">0</span>, kInValid&#125;;</span><br><span class="line">    <span class="keyword">int</span> g_nStatus = kValid;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        g_nStatus = kInValid;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line">        <span class="comment">// 判断是否为指针和是否为空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(cstr != <span class="literal">NULL</span> &amp;&amp; *cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 正负号标志位，默认是加号</span></span><br><span class="line">            <span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(*cstr == <span class="string">'+'</span>)&#123;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*cstr == <span class="string">'-'</span>)&#123;</span><br><span class="line">                minus = <span class="literal">true</span>;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(*cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">                num = StrToIntCore(cstr, minus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr, <span class="keyword">bool</span> minus)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断是否是非法值</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr &gt;= <span class="string">'0'</span> &amp;&amp; *cstr &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + flag * (*cstr - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">// 判断是否溢出,32位</span></span><br><span class="line">                <span class="keyword">if</span>((!minus &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))&#123;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否正常结束</span></span><br><span class="line">        <span class="keyword">if</span>(*cstr == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            g_nStatus = kValid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minus = <span class="keyword">False</span></span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                minus = <span class="keyword">True</span></span><br><span class="line">            begin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                begin = <span class="number">1</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            minus = <span class="number">-1</span> <span class="keyword">if</span> minus <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> each <span class="keyword">in</span> s[begin:]:</span><br><span class="line">                <span class="keyword">if</span> each &gt;= <span class="string">'0'</span> <span class="keyword">and</span> each &lt;= <span class="string">'9'</span>:</span><br><span class="line">                    num = num * <span class="number">10</span> + minus * (ord(each) - ord(<span class="string">'0'</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十四）：翻转单词顺序序列</title>
    <link href="http://yoursite.com/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/09/08/剑指Offer（四十四）：翻转单词顺序序列/</id>
    <published>2018-09-08T13:47:12.000Z</published>
    <updated>2018-09-08T13:55:57.181Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>翻转单词顺序序列，将“student. a am I”翻转成正确的“I am a student.”</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>观察字符串变化规律，你会发现这道题很简单。只需要对每个单词做翻转，然后再整体做翻转就得到了正确的结果。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = str;</span><br><span class="line">        <span class="keyword">int</span> length = result.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 追加一个空格，作为反转标志位</span></span><br><span class="line">        result += <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据空格，反转所有单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                Reverse(result, mark, i - <span class="number">1</span>);</span><br><span class="line">                mark = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉添加的空格</span></span><br><span class="line">        result = result.substr(<span class="number">0</span>, length);</span><br><span class="line">        <span class="comment">// 整体反转</span></span><br><span class="line">        Reverse(result, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//注意是string &amp;str，不是string str(最普通的参数传递方式，不可以直接改变传递进来的对象。)</span></span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">            swap(str[begin++], str[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s_list = s.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s_list[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;翻转单词顺序序列，将“student. a am I”翻转成正确的“I am a student.”&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十三）：左旋转字符串</title>
    <link href="http://yoursite.com/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/09/08/剑指Offer（四十三）：左旋转字符串/</id>
    <published>2018-09-08T12:56:15.000Z</published>
    <updated>2018-09-08T12:57:47.442Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！😁<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>例如：输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”;</p><p>第一步：翻转字符串“ab”，得到”ba”；</p><p>第二步：翻转字符串”cdefg”，得到”gfedc”；</p><p>第三步：翻转字符串”bagfedc”，得到”cdefgab”；</p><p>或者：</p><p>第一步：翻转整个字符串”abcdefg”,得到”gfedcba”</p><p>第二步：翻转字符串“gfedc”，得到”cdefg”</p><p>第三步：翻转字符串”ba”,得到”ab”</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = str;</span><br><span class="line">        <span class="keyword">int</span> length = result.size();</span><br><span class="line">        <span class="keyword">if</span>(length &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &lt;= n &lt;= length)&#123;</span><br><span class="line">            <span class="keyword">int</span> pFirstBegin = <span class="number">0</span>, pFirstEnd = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pSecondBegin = n, pSecondEnd = length - <span class="number">1</span>;</span><br><span class="line">            ReverseString(result, pFirstBegin, pFirstEnd);</span><br><span class="line">            ReverseString(result, pSecondBegin, pSecondEnd);</span><br><span class="line">            ReverseString(result, pFirstBegin, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">            swap(str[begin++], str[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">if</span> n &gt; length:</span><br><span class="line">            n = n % length</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！😁&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十四）：第一个只出现一次的字符</title>
    <link href="http://yoursite.com/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2018/09/08/剑指Offer（三十四）：第一个只出现一次的字符/</id>
    <published>2018-09-08T12:26:06.000Z</published>
    <updated>2018-09-08T12:55:28.306Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>在一个字符串中找到第一个只出现一次的字符,并返回它的位置。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>建立一个哈希表，第一次扫描的时候，统计每个字符的出现次数。第二次扫描的时候，如果该字符出现的次数为1，则返回这个字符的位置。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = str.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; item;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            item[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item[str[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> str[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        item = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> item.keys():</span><br><span class="line">                item[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item[s[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> item[s[i]] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;在一个字符串中找到第一个只出现一次的字符,并返回它的位置。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;在一个字符串(1&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二十七）：字符串的排列</title>
    <link href="http://yoursite.com/2018/09/08/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2018/09/08/剑指Offer（二十七）：字符串的排列/</id>
    <published>2018-09-08T11:53:11.000Z</published>
    <updated>2018-09-08T12:11:01.584Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><a id="more"></a></p><p><strong>输入描述：</strong></p><p>输入一个字符串,长度不超过9(可能有字符重复)，字符只包括大小写字母。</p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4980988863882df8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。</p><p>这个思路，是典型的递归思路。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="comment">//判断输入</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        PermutationCore(str, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//对结果进行排序</span></span><br><span class="line">        sort(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归结束的条件：第一位和最后一位交换完成</span></span><br><span class="line">        <span class="keyword">if</span>(begin == str.length())&#123;</span><br><span class="line">            result.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//如果字符串相同，则不交换</span></span><br><span class="line">            <span class="keyword">if</span>(i != begin &amp;&amp; str[i] == str[begin])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置交换</span></span><br><span class="line">            swap(str[begin], str[i]);</span><br><span class="line">            <span class="comment">//递归调用，前面begin+1的位置不变，后面的字符串全排列</span></span><br><span class="line">            PermutationCore(str, begin + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(ss) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.PermutationCore(ss, <span class="number">0</span>)</span><br><span class="line">        sorted(self.result)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PermutationCore</span><span class="params">(self, str_, begin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> begin == len(str_):</span><br><span class="line">            self.result.append(str_)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, len(str_)):</span><br><span class="line">            <span class="keyword">if</span> i != begin <span class="keyword">and</span> str_[i] == str_[begin]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            str_list = list(str_)</span><br><span class="line">            str_list[i], str_list[begin] = str_list[begin], str_list[i]</span><br><span class="line">            str_ = <span class="string">''</span>.join(str_list)</span><br><span class="line">            self.PermutationCore(str_, begin+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p><strong>Python：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(ss) &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = list()</span><br><span class="line">        self.perm(ss,res,<span class="string">''</span>)</span><br><span class="line">        uniq = list(set(res))</span><br><span class="line">        <span class="keyword">return</span> sorted(uniq)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perm</span><span class="params">(self,ss,res,path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ss==<span class="string">''</span>:</span><br><span class="line">            res.append(path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</span><br><span class="line">                self.perm(ss[:i]+ss[i+<span class="number">1</span>:],res,path+ss[i])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔试面试总结</title>
    <link href="http://yoursite.com/2018/09/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/03/深度学习笔试面试总结/</id>
    <published>2018-09-03T01:19:27.000Z</published>
    <updated>2018-09-03T01:22:38.303Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔试面试总结</title>
    <link href="http://yoursite.com/2018/09/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/03/机器学习笔试面试总结/</id>
    <published>2018-09-03T01:19:17.000Z</published>
    <updated>2018-09-03T09:14:15.423Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q1. 下列说法正确的是？（多选）</strong></p><p>A. AdaGrad 使用的是一阶导数</p><p>B. L-BFGS 使用的是二阶导数</p><p>C. AdaGrad 使用的是二阶导数<br><a id="more"></a></p><p>D. L-BFGS 使用的是一阶导数</p><p><strong>答案</strong>：AB</p><p><strong>解析</strong>：AdaGrad 是基于梯度下降算法的，AdaGrad算法能够在训练中自动的对学习速率 α 进行调整，对于出现频率较低参数采用较大的 α 更新；相反，对于出现频率较高的参数采用较小的 α 更新。Adagrad非常适合处理稀疏数据。很明显，AdaGrad 算法利用的是一阶导数。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-72719e5327ac8b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>L-BFGS 是基于牛顿优化算法的，牛顿优化算法使用的是二阶导数。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-83efe7aa07c70bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q2. “增加卷积核的尺寸，一定能提高卷积神经网络的性能。” 这句话是否正确？</strong></p><p>A. 正确</p><p>B. 错误</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：卷积核的尺寸是超参数，不一定增加其尺寸就一定增加神经网络的性能，需要验证选择最佳尺寸。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f6f31ede1eaafc51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q3. 假设你在卷积神经网络的第一层中有 5 个卷积核，每个卷积核尺寸为 7×7，具有零填充且步幅为 1。该层的输入图片的维度是 224×224×3。那么该层输出的维度是多少？</strong></p><p>A. 217 x 217 x 3</p><p>B. 217 x 217 x 8</p><p>C. 218 x 218 x 5</p><p>D. 220 x 220 x 7</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：一般地，如果原始图片尺寸为 nxn，filter 尺寸为 fxf，则卷积后的图片尺寸为 (n-f+1)x(n-f+1)，注意 f 一般为奇数。</p><p>若考虑存在填充和步幅，用 s 表示 stride 长度，p 表示 padding 长度，如果原始图片尺寸为 nxn，filter 尺寸为 fxf，则卷积后的图片尺寸为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f6f31ede1eaafc51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上式中，⌊⋯⌋ 表示向下取整。</p><p>此例中， n=224，p=0，f=7，s=1，因此，该层输出的尺寸为 218x218。</p><p>输出的第三个维度由滤波器的个数决定，即为 5。</p><p><strong>Q4. 假如现在有个神经网络，激活函数是 ReLU，若使用线性激活函数代替 ReLU，那么该神经网络还能表征 XNOR 函数吗？</strong></p><p>A. 可以</p><p>B. 不可以</p><p><strong>答案</strong>：B</p><p>解析：异或（XNOR）关系是非线性的，线性激活函数只能解决线性问题，不能解决非线性问题。如果用线性激活代替 ReLU，则神经网络失去逼近非线性函数的能力。</p><p><strong>Q5. 机器学习训练时，Mini-Batch 的大小优选为2个的幂，如 256 或 512。它背后的原因是什么？</strong></p><p>A. Mini-Batch 为偶数的时候，梯度下降算法训练的更快</p><p>B. Mini-Batch 设为 2 的 幂，是为了符合 CPU、GPU 的内存要求，利于并行化处理</p><p>C. 不使用偶数时，损失函数是不稳定的</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：B</p><p><strong>Q6. 下列哪种方法可以用来减小过拟合？（多选）</strong></p><p>A. 更多的训练数据</p><p>B. L1 正则化</p><p>C. L2 正则化</p><p>D. 减小模型的复杂度</p><p><strong>答案</strong>：ABCD</p><p><strong>解析</strong>：增加训练样本、L1正则化、L2 正则化、减小模型复杂度都能有效避免发生过拟合。</p><p><strong>Q7. 下列说法错误的是？</strong></p><p>A. 当目标函数是凸函数时，梯度下降算法的解一般就是全局最优解</p><p>B. 进行 PCA 降维时，需要计算协方差矩阵</p><p>C. 沿负梯度的方向一定是最优的方向</p><p>D. 利用拉格朗日函数能解带约束的优化问题</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：沿负梯度的方向是函数值减少最快的方向但不一定就是最优方向。</p><p><strong>Q8. K-Means 算法无法聚以下哪种形状的样本？</strong></p><p>A. 圆形分布</p><p>B. 螺旋分布</p><p>C. 带状分布</p><p>D. 凸多边形分布</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：K-Means 算法是基于距离测量的，无法聚非凸形状的样本。</p><p><strong>Q9. 向量 X=[1,2,3,4,-9,0] 的 L1 范数为？</strong></p><p>A. 1</p><p>B. 19</p><p>C. 6</p><p>D. √111</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：L0 范数表示向量中所有非零元素的个数；L1 范数指的是向量中各元素的绝对值之和，又称“稀疏矩阵算子”；L2 范数指的是向量中各元素的平方和再求平方根。</p><p>本例中，L0 范数为 5，L1 范数为 19，L2 范数为 √111。</p><p><strong>Q10. 关于 L1、L2 正则化下列说法正确的是？</strong></p><p>A. L2 正则化能防止过拟合，提升模型的泛化能力，但 L1 做不到这点</p><p>B. L2 正则化技术又称为 Lasso Regularization</p><p>C. L1 正则化得到的解更加稀疏</p><p>D. L2 正则化得到的解更加稀疏</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：L1、L2 正则化都能防止过拟合，提升模型的泛化能力。L1 正则化技术又称为 Lasso Regularization。L1 正则化得到的解更加稀疏，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-48a462e1fe29342c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以二维情况讨论，上图左边是 L2 正则化，右边是 L1 正则化。从另一个方面来看，满足正则化条件，实际上是求解蓝色区域与黄色区域的交点，即同时满足限定条件和 Ein 最小化。对于 L2 来说，限定区域是圆，这样，得到的解 w1 或 w2 为 0 的概率很小，很大概率是非零的。</p><p>对于 L1 来说，限定区域是正方形，方形与蓝色区域相交的交点是顶点的概率很大，这从视觉和常识上来看是很容易理解的。也就是说，方形的凸点会更接近 Ein 最优解对应的 wlin 位置，而凸点处必有 w1 或 w2 为 0。这样，得到的解 w1 或 w2 为零的概率就很大了。所以，L1 正则化的解具有稀疏性。</p><p>扩展到高维，同样的道理，L2 的限定区域是平滑的，与中心点等距；而 L1 的限定区域是包含凸点的，尖锐的。这些凸点更接近 Ein 的最优解位置，而在这些凸点上，很多 wj 为 0。</p><p><strong>Q11. 有 N 个样本，一般用于训练，一般用于测试。若增大 N 值，则训练误差和测试误差之间的差距会如何变化？</strong></p><p>A. 增大</p><p>B. 减小</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：增加数据，能够有效减小过拟合，减小训练样本误差和测试样本误差之间的差距。</p><p><strong>Q12. 假定你在神经网络中的隐藏层中使用激活函数 X。在特定神经元给定任意输入，你会得到输出 -0.01。X 可能是以下哪一个激活函数？</strong></p><p>A. ReLU</p><p>B. tanh </p><p>C. Sigmoid</p><p>D. 以上都有可能</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：ReLU 的输出范围是 [0,+∞)，tanh 的输出范围是 (-1,+1)，Sigmoid 的输出范围是 (0,+1)。</p><p><strong>Q13. k-NN 最近邻方法在什么情况下效果较好？</strong></p><p>A. 样本较多但典型性不好 </p><p>B. 样本较少但典型性好 </p><p>C. 样本呈团状分布 </p><p>D. 样本呈链状分布 </p><p><strong>答案</strong>：B </p><p><strong>解析</strong>：K 近邻算法主要依靠的是周围的点，因此如果样本过多，则难以区分，典型性好的容易区分。</p><p>样本呈团状或链状都具有迷惑性，这样 kNN 就发挥不出其求近邻的优势了，整体样本应该具有典型性好，样本较少，比较适宜。</p><p><strong>Q14. 下列方法中，可以用于特征降维的方法包括？（多选）</strong></p><p>A. 主成分分析 PCA </p><p>B. 线性判别分析 LDA </p><p>C. AutoEncoder </p><p>D. 矩阵奇异值分解 SVD </p><p>E. 最小二乘法 LeastSquares </p><p><strong>答案</strong>：ABCD </p><p><strong>解析</strong>：主成分分析 PCA 、线性判别分析 LDA 、AutoEncoder、矩阵奇异值分解 SVD 都是用于特征降维的方法。最小二乘法是解决线性回归问题的算法，但是并没有进行降维。</p><p><strong>Q15. 以下哪些方法不可以直接来对文本分类？</strong></p><p>A. K-Means</p><p>B. 决策树</p><p>C. 支持向量机</p><p>D. kNN</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：K-Means 是无监督算法，它之所以不能称为分类是因为它之前并没有类别标签，因此只能聚类。</p><p><strong>Q16. 在回归模型中，下列哪一项在权衡欠拟合（under-fitting）和过拟合（over-fitting）中影响最大？</strong></p><p>A. 多项式阶数</p><p>B. 更新权重 w 时，使用的是矩阵求逆还是梯度下降</p><p>C. 使用常数项</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：选择合适的多项式阶数非常重要。如果阶数过大，模型就会更加复杂，容易发生过拟合；如果阶数较小，模型就会过于简单，容易发生欠拟合。如果有对过拟合和欠拟合概念不清楚的，见下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5b857076a6456a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q17. 假设你有以下数据：输入和输出都只有一个变量。使用线性回归模型（y=wx+b）来拟合数据。那么使用留一法（Leave-One Out）交叉验证得到的均方误差是多少？</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-e1ce73a05c75fce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 10/27</p><p>B. 39/27</p><p>C. 49/27</p><p>D. 55/27</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：留一法，简单来说就是假设有 N 个样本，将每一个样本作为测试样本，其它 N-1 个样本作为训练样本。这样得到 N 个分类器，N 个测试结果。用这 N个结果的平均值来衡量模型的性能。</p><p>对于该题，我们先画出 3 个样本点的坐标：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5946f97fb1555707.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用两个点进行线性拟合，分成三种情况，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-64c71d87b2a23885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第一种情况下，回归模型是 y = 2，误差 E1 = 1。</p><p>第二种情况下，回归模型是 y = -x + 4，误差 E2 = 2。</p><p>第三种情况下，回归模型是 y = -1/3x + 2,误差 E3 = 2/3。</p><p>则总的均方误差为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e407dc44d5888d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q18. 下列关于极大似然估计（Maximum Likelihood Estimate，MLE），说法正确的是（多选）？</strong></p><p>A. MLE 可能并不存在</p><p>B. MLE 总是存在</p><p>C. 如果 MLE 存在，那么它的解可能不是唯一的</p><p>D. 如果 MLE 存在，那么它的解一定是唯一的</p><p><strong>答案</strong>：AC</p><p><strong>解析</strong>：如果极大似然函数 L(θ) 在极大值处不连续，一阶导数不存在，则 MLE 不存在，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6b21ad91933d034e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>另一种情况是 MLE 并不唯一，极大值对应两个 θ。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c469c4fe5e9dc986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Q19. 如果我们说“线性回归”模型完美地拟合了训练样本（训练样本误差为零），则下面哪个说法是正确的？</strong></p><p>A. 测试样本误差始终为零</p><p>B. 测试样本误差不可能为零</p><p>C. 以上答案都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：根据训练样本误差为零，无法推断测试样本误差是否为零。值得一提是，如果测试样本样本很大，则很可能发生过拟合，模型不具备很好的泛化能力！</p><p><strong>Q20. 在一个线性回归问题中，我们使用 R 平方（R-Squared）来判断拟合度。此时，如果增加一个特征，模型不变，则下面说法正确的是？</strong></p><p>A. 如果 R-Squared 增加，则这个特征有意义</p><p>B. 如果R-Squared 减小，则这个特征没有意义</p><p>C. 仅看 R-Squared 单一变量，无法确定这个特征是否有意义。</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。其表达式如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fc03e7e893d7eb39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上式中，分子部分表示真实值与预测值的平方差之和，类似于均方差 MSE；分母部分表示真实值与均值的平方差之和，类似于方差 Var。根据 R-Squared 的取值，来判断模型的好坏：如果结果是 0，说明模型拟合效果很差；如果结果是 1，说明模型无错误。一般来说，R-Squared 越大，表示模型拟合效果越好。R-Squared 反映的是大概有多准，因为，随着样本数量的增加，R-Square必然增加，无法真正定量说明准确程度，只能大概定量。</p><p>对于本题来说，单独看 R-Squared，并不能推断出增加的特征是否有意义。通常来说，增加一个特征，R-Squared 可能变大也可能保持不变，两者不一定呈正相关。</p><p>如果使用校正决定系数（Adjusted R-Square）：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0c0deca260a65c33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，n 是样本数量，p 是特征数量。Adjusted R-Square 抵消样本数量对 R-Square的影响，做到了真正的 0~1，越大越好。</p><p><strong>Q21. 下列关于线性回归分析中的残差（Residuals）说法正确的是？</strong></p><p>A. 残差均值总是为零</p><p>B. 残差均值总是小于零</p><p>C. 残差均值总是大于零</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：线性回归分析中，目标是残差最小化。残差平方和是关于参数的函数，为了求残差极小值，令残差关于参数的偏导数为零，会得到残差和为零，即残差均值为零。</p><p><strong>Q22. 下列关于异方差（Heteroskedasticity）说法正确的是？</strong></p><p>A. 线性回归具有不同的误差项</p><p>B. 线性回归具有相同的误差项</p><p>C. 线性回归误差项为零</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：异方差性是相对于同方差（Homoskedasticity）而言的。所谓同方差，是为了保证回归参数估计量具有良好的统计性质，经典线性回归模型的一个重要假定：总体回归函数中的随机误差项满足同方差性，即它们都有相同的方差。如果这一假定不满足，即：随机误差项具有不同的方差，则称线性回归模型存在异方差性。</p><p>通常来说，奇异值的出现会导致异方差性增大。</p><p><strong>Q23. 下列哪一项能反映出 X 和 Y 之间的强相关性？</strong></p><p>A. 相关系数为 0.9</p><p>B. 对于无效假设 β=0 的 p 值为 0.0001</p><p>C. 对于无效假设 β=0 的 t 值为 30</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：相关系数的概念我们很熟悉，它反映了不同变量之间线性相关程度，一般用 r 表示。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e5efceb45b6dab94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，Cov(X,Y) 为 X 与 Y 的协方差，Var[X] 为 X 的方差，Var[Y] 为 Y 的方差。r 取值范围在 [-1,1] 之间，r 越大表示相关程度越高。A 选项中，r=0.9 表示 X 和 Y 之间有较强的相关性。</p><p>而 p 和 t 的数值大小没有统计意义，只是将其与某一个阈值进行比对,以得到二选一的结论。例如，有两个假设：</p><ul><li>无效假设（null hypothesis）H0：两参量间不存在“线性”相关。</li><li>备择假设（alternative hypothesis）H1：两参量间存在“线性”相关。</li></ul><p>如果阈值是 0.05，计算出的 p 值很小，比如为 0.001，则可以说“有非常显著的证据拒绝 H0 假设,相信 H1 假设。即两参量间存在“线性”相关。p 值只用于二值化判断，因此不能说 p=0.06 一定比 p=0.07 更好。</p><p><strong>Q24. 下列哪些假设是我们推导线性回归参数时遵循的（多选）？</strong></p><p>A. X 与 Y 有线性关系（多项式关系）</p><p>B. 模型误差在统计学上是独立的</p><p>C. 误差一般服从 0 均值和固定标准差的正态分布</p><p>D. X 是非随机且测量没有误差的</p><p><strong>答案</strong>：ABCD</p><p><strong>解析</strong>：在进行线性回归推导和分析时，我们已经默认上述四个条件是成立的。</p><p><strong>Q25. 为了观察测试 Y 与 X 之间的线性关系，X 是连续变量，使用下列哪种图形比较适合？</strong></p><p>A. 散点图</p><p>B. 柱形图</p><p>C. 直方图</p><p>D. 以上都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：散点图反映了两个变量之间的相互关系，在测试 Y 与 X 之间的线性关系时，使用散点图最为直观。</p><p><strong>Q26. 一般来说，下列哪种方法常用来预测连续独立变量？</strong></p><p>A. 线性回归</p><p>B. 逻辑回顾</p><p>C. 线性回归和逻辑回归都行</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：线性回归一般用于实数预测，逻辑回归一般用于分类问题。</p><p><strong>Q27. 个人健康和年龄的相关系数是 -1.09。根据这个你可以告诉医生哪个结论？</strong></p><p>A. 年龄是健康程度很好的预测器</p><p>B. 年龄是健康程度很糟的预测器</p><p>C. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：因为相关系数的范围是 [-1,1] 之间，所以，-1.09 不可能存在。</p><p><strong>Q28. 下列哪一种偏移，是我们在最小二乘直线拟合的情况下使用的？图中横坐标是输入 X，纵坐标是输出 Y。</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-32f0dd9b646c9298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 垂直偏移（vertical offsets）</p><p>B. 垂向偏移（perpendicular offsets）</p><p>C. 两种偏移都可以</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：线性回归模型计算损失函数，例如均方差损失函数时，使用的都是 vertical offsets。perpendicular offsets 一般用于主成分分析（PCA）中。</p><p><strong>Q29. 假如我们利用 Y 是 X 的 3 阶多项式产生一些数据（3 阶多项式能很好地拟合数据）。那么，下列说法正确的是（多选）？</strong></p><p>A. 简单的线性回归容易造成高偏差（bias）、低方差（variance）</p><p>B. 简单的线性回归容易造成低偏差（bias）、高方差（variance）</p><p>C. 3 阶多项式拟合会造成低偏差（bias）、高方差（variance）</p><p>D. 3 阶多项式拟合具备低偏差（bias）、低方差（variance）</p><p><strong>答案</strong>：AD</p><p><strong>解析</strong>：偏差和方差是两个相对的概念，就像欠拟合和过拟合一样。如果模型过于简单，通常会造成欠拟合，伴随着高偏差、低方差；如果模型过于复杂，通常会造成过拟合，伴随着低偏差、高方差。</p><p>用一张图来形象地表示偏差与方差的关系：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dde5b5280cc26c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>偏差（bias）可以看成模型预测与真实样本的差距，想要得到 low bias，就得复杂化模型，但是容易造成过拟合。方差（variance）可以看成模型在测试集上的表现，想要得到 low variance，就得简化模型，但是容易造成欠拟合。实际应用中，偏差和方差是需要权衡的。若模型在训练样本和测试集上都表现的不错，偏差和方差都会比较小，这也是模型比较理想的情况。</p><p><strong>Q30. 假如你在训练一个线性回归模型，有下面两句话：</strong></p><pre><code>**1. 如果数据量较少，容易发生过拟合。****2. 如果假设空间较小，容易发生过拟合。**</code></pre><p><strong>关于这两句话，下列说法正确的是？</strong></p><p>A. 1 和 2 都错误</p><p>B. 1 正确，2 错误</p><p>C. 1 错误，2 正确</p><p>D. 1 和 2 都正确</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：先来看第 1 句话，如果数据量较少，容易在假设空间找到一个模型对训练样本的拟合度很好，容易造成过拟合，该模型不具备良好的泛化能力。</p><p>再来看第 2 句话，如果假设空间较小，包含的可能的模型就比较少，也就不太可能找到一个模型能够对样本拟合得很好，容易造成高偏差、低方差，即欠拟合。</p><p><strong>Q31. 假如我们使用 Lasso 回归来拟合数据集，该数据集输入特征有 100 个（X1，X2，…，X100）。现在，我们把其中一个特征值扩大 10 倍（例如是特征 X1），然后用相同的正则化参数对 Lasso 回归进行修正。</strong></p><p><strong>那么，下列说法正确的是？</strong></p><p>A. 特征 X1 很可能被排除在模型之外</p><p>B. 特征 X1 很可能还包含在模型之中</p><p>C. 无法确定特征 X1 是否被舍弃</p><p>D. 以上说法都不对</p><p><strong>答案</strong>： B</p><p><strong>解析</strong>：Lasso 回归类似于线性回归，只不过它在线性回归的基础上，增加了一个对所有参数的数值大小约束，如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f824a5250cab98b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，t 为正则化参数。Lasso 回归其实就是在普通线性回归的损失函数的基础上增加了个 β 的约束。那么 β 的约束为什么要使用这种形式，而不使用 β 的平方约束呢？原因就在于第一范数的约束下，一部分回归系数刚好可以被约束为 0。这样的话，就达到了特征选择的效果。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0fd152a1d71f7c9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>左边是第二范式，右边是第一范式。第一范数约束下，β 更有可能被约束成 0。这点非常类似于 L1 和 L2 正则化的区别。</p><p>因此，Lasso 回归适用于样本数量较少，特征维度较大的情形，便于从较多特征中进行特征选择。例如 DNA 数据，特征维度很大，我们只希望通过 Lasso 回归找出与某些疾病有关的 DNA 片段。</p><p>本题中，将特征 X1 数值扩大 10 倍，他对应的回归系数将相应会减小，但不为 0，以此来保证仍然满足 β 的正则化约束。</p><p><strong>Q32. 关于特征选择，下列对 Ridge 回归和 Lasso 回归说法正确的是？</strong></p><p>A. Ridge 回归适用于特征选择</p><p>B. Lasso 回归适用于特征选择</p><p>C. 两个都适用于特征选择</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：上一题我们已经介绍过，Lasso 回归会让一部分回归系数刚好可以被约束为 0，起到特征选择的效果。</p><p>Ridge 回归又称岭回归，它是普通线性回归加上 L2 正则项，用来防止训练过程中出现的过拟合。L2 正则化效果类似上一题左图，限定区域是圆，这样，得到的回归系数为 0 的概率很小，很大概率是非零的。因此，比较来说，Lasso 回归更容易得到稀疏的回归系数，有利于舍弃冗余或无用特征，适用于特征选择。</p><p><strong>Q33. 如果在线性回归模型中增加一个特征变量，下列可能发生的是（多选）？</strong></p><p>A. R-squared 增大，Adjust R-squared 增大</p><p>B. R-squared 增大，Adjust R-squared 减小</p><p>C. R-squared 减小，Adjust R-squared 减小</p><p>D. R-squared 减小，Adjust R-squared 增大</p><p><strong>答案</strong>：AB</p><p><strong>解析</strong>：线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。其表达式如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1c12567aef4f9b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上式中，分子部分表示真实值与预测值的平方差之和，类似于均方差 MSE；分母部分表示真实值与均值的平方差之和，类似于方差 Var。一般来说，R-Squared 越大，表示模型拟合效果越好。R-Squared 反映的是大概有多准，因为，随着样本数量的增加，R-Squared 必然增加，无法真正定量说明准确程度，只能大概定量。</p><p>单独看 R-Squared，并不能推断出增加的特征是否有意义。通常来说，增加一个特征特征，R-Squared 可能变大也可能保持不变，两者不一定呈正相关。</p><p>如果使用校正决定系数（Adjusted R-Squared）：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-93556aa2d3107428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，n 是样本数量，p 是特征数量。Adjusted R-Squared 抵消样本数量对 R-Squared 的影响，做到了真正的 0~1，越大越好。</p><p>增加一个特征变量，如果这个特征有意义，Adjusted R-Square 就会增大，若这个特征是冗余特征，Adjusted R-Squared 就会减小。</p><p><strong>Q34. 下面三张图展示了对同一训练样本，使用不同的模型拟合的效果（蓝色曲线）。那么，我们可以得出哪些结论（多选）？</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-61e845f7b298f9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 第 1 个模型的训练误差大于第 2 个、第 3 个模型</p><p>B. 最好的模型是第 3 个，因为它的训练误差最小</p><p>C. 第 2 个模型最为“健壮”，因为它对未知样本的拟合效果最好</p><p>D. 第 3 个模型发生了过拟合</p><p>E. 所有模型的表现都一样，因为我们并没有看到测试数据</p><p><strong>答案</strong>：ACD</p><p><strong>解析</strong>：1、2、3 模型分别对应的多项式阶数由小到大，即模型由简单到复杂。模型越简单，容易发生欠拟合；模型越复杂，容易发生过拟合。第 1 个模型过于简单，出现欠拟合；第 3 个模型过于复杂，对训练样本拟合得很好，但在测试样本上效果会很差，即过拟合；第 2 个模型最为“健壮”，在训练样本和测试样本上拟合效果都不错！</p><p><strong>Q35. 下列哪些指标可以用来评估线性回归模型（多选）？</strong></p><p>A. R-Squared</p><p>B. Adjusted R-Squared</p><p>C. F Statistics</p><p>D. RMSE / MSE / MAE</p><p><strong>答案</strong>：ABCD</p><p><strong>解析</strong>：R-Squared 和 Adjusted R-Squared 的概念，我们在 Q3 有过介绍，它们都可以用来评估线性回归模型。F Statistics 是指在零假设成立的情况下，符合F分布的统计量，多用于计量统计学中。</p><p>RMSE 指的是均方根误差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3066338bd93bb507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>MSE 指的是均方误差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-ac45f3e8cfb10e2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>MAE 指的是评价绝对误差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-bc1ee5c524fbd792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上指标都可以用来评估线性回归模型。</p><p><strong>Q36. 线性回归中，我们可以使用正规方程（Normal Equation）来求解系数。下列关于正规方程说法正确的是？</strong></p><p>A. 不需要选择学习因子</p><p>B. 当特征数目很多的时候，运算速度会很慢</p><p>C. 不需要迭代训练</p><p><strong>答案</strong>：ABC</p><p><strong>解析</strong>：求解线性回归系数，我们一般最常用的方法是梯度下降，利用迭代优化的方式。除此之外，还有一种方法是使用正规方程，原理是基于最小二乘法。下面对正规方程做简要的推导。</p><p>已知线性回归模型的损失函数 Ein 为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fd966d40c0a2848c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对 Ein 计算导数，令 ∇Ein=0：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-d48a982d7ae724c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后就能计算出 W：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a5484827933b999f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上就是使用正规方程求解系数 W 的过程。可以看到，正规方程求解过程不需要学习因子，也没有迭代训练过程。当特征数目很多的时候，XTX 矩阵求逆会很慢，这时梯度下降算法更好一些。</p><p>如果 XTX 矩阵不可逆，是奇异矩阵怎么办呢？其实，大部分的计算逆矩阵的软件程序，都可以处理这个问题，也会计算出一个逆矩阵。所以，一般伪逆矩阵是可解的。</p><p><strong>Q37. 如果 Y 是 X（X1，X2，…，Xn）的线性函数：</strong></p><p><strong>Y = β0 + β1X1 + β2X2 + ··· + βnXn</strong></p><p><strong>则下列说法正确的是（多选）？</strong></p><p>A. 如果变量 Xi 改变一个微小变量 ΔXi，其它变量不变。那么 Y 会相应改变 βiΔXi。</p><p>B. βi 是固定的，不管 Xi 如何变化</p><p>C. Xi 对 Y 的影响是相互独立的，且 X 对 Y 的总的影响为各自分量 Xi 之和</p><p><strong>答案</strong>：ABC</p><p><strong>解析</strong>：这题非常简单，Y 与 X（X1，X2，…，Xn）是线性关系，故能得出 ABC 结论。</p><p><strong>Q38. 构建一个最简单的线性回归模型需要几个系数（只有一个特征）？</strong></p><p>A. 1 个</p><p>B. 2 个</p><p>C. 3 个</p><p>D. 4 个</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：最简单的线性回归模型，只有一个特征，即 Y = aX + b，包含 a 和 b 两个系数。</p><p><strong>Q39. 下面两张图展示了两个拟合回归线（A 和 B），原始数据是随机产生的。现在，我想要计算 A 和 B 各自的残差之和。注意：两种图中的坐标尺度一样。</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-9efa7b49191ac4ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>关于 A 和 B 各自的残差之和，下列说法正确的是？</strong></p><p>A. A 比 B 高</p><p>B. A 比 B 小</p><p>C. A 与 B 相同</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：A 和 B 中各自的残差之和应该是相同的。线性回归模型的损失函数为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1aaeddbdb1f9da6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对损失函数求导，并令 ∇J=0，即可得到 XW-Y=0，即残差之和始终为零。</p><p><strong>Q40. 如果两个变量相关，那么它们一定是线性关系吗？</strong></p><p>A. 是</p><p>B. 不是</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：相关不一定是线性关系，也有可能是非线性相关。</p><p><strong>Q41. 两个变量相关，它们的相关系数 r 可能为 0。这句话是否正确？</strong></p><p>A. 正确</p><p>B. 错误</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：一般来说，相关系数 r=0 是两变量相互独立的必要不充分条件。也就是说，如果两个变量相互独立，那么相关系数 r 一定为 0，如果相关系数 r=0，则不一定相互独立。相关系数 r=0 只能说明两个变量之间不存在线性关系，仍然可能存在非线性关系。</p><p>那么，若两个变量相关，存在非线性关系，那么它们的相关系数 r 就为 0。</p><p><strong>Q42. 加入使用逻辑回归对样本进行分类，得到训练样本的准确率和测试样本的准确率。现在，在数据中增加一个新的特征，其它特征保持不变。然后重新训练测试。则下列说法正确的是？</strong></p><p>A. 训练样本准确率一定会降低</p><p>B. 训练样本准确率一定增加或保持不变</p><p>C. 测试样本准确率一定会降低</p><p>D. 测试样本准确率一定增加或保持不变</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：在模型中增加更多特征一般会增加训练样本的准确率，减小 bias。但是测试样本准确率不一定增加，除非增加的特征是有效特征。</p><p>这题对应的知识点也包括了增加模型复杂度，虽然会减小训练样本误差，但是容易发生过拟合。</p><p><strong>Q43. 下面这张图是一个简单的线性回归模型,图中标注了每个样本点预测值与真实值的残差。计算 SSE 为多少？</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-4dd8f7be18e93aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. 3.02</p><p>B. 0.75</p><p>C. 1.01</p><p>D. 0.604</p><p><strong>答案</strong>：A</p><p><strong>解析</strong>：SSE 是平方误差之和（Sum of Squared Error），SSE = (-0.2)^2 + (0.4)^2 + (-0.8)^2 + (1.3)^2 + (-0.7)^2 = 3.02</p><p><strong>Q44. 假设变量 Var1 和 Var2 是正相关的，那么下面那张图是正确的？图中，横坐标是 Var1，纵坐标是 Var2，且对 Var1 和 Var2 都做了标准化处理。</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-f6de97674698194d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A. Plot 1</p><p>B. Plot 2</p><p><strong>答案</strong>：B</p><p>解析：显然，Plot 2 显示出 Var2 与 Var1 是正相关的，例如 Var2 = Var1。Plot 1 显示出 Var2 与 Var1 是负相关的，例如 Var2 = -Var1。</p><p><strong>Q45. 假设一个公司的薪资水平中位数是 $35,000，排名第 25% 和 75% 的薪资分别是 $21,000 和 $ 53,000。如果某人的薪水是 $1，那么它可以被看成是异常值（Outlier）吗？</strong></p><p>A. 可以</p><p>B. 不可以</p><p>C. 需要更多的信息才能判断</p><p>D. 以上说法都不对</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：异常值（Outlier）指样本中的个别值，其数值明显偏离它（或他们）所属样本的其余观测值，也称异常数据，离群值。目前人们对异常值的判别与剔除主要采用物理判别法和统计判别法两种方法。</p><p>所谓物理判别法就是根据人们对客观事物已有的认识，判别由于外界干扰、人为误差等原因造成实测数据值偏离正常结果，在实验过程中随时判断，随时剔除。</p><p>统计判别法是给定一个置信概率，并确定一个置信限，凡超过此限的误差，就认为它不属于随机误差范围，将其视为异常值剔除。当物理识别不易判断时，一般采用统计识别法。</p><p>该题中，所给的信息量过少，无法肯定一定是异常值。</p><p><strong>Q46. 关于“回归（Regression）”和“相关（Correlation）”，下列说法正确的是？注意：x 是自变量，y 是因变量。</strong></p><p>A. 回归和相关在 x 和 y 之间都是互为对称的</p><p>B. 回归和相关在 x 和 y 之间都是非对称的</p><p>C. 回归在 x 和 y 之间是非对称的，相关在 x 和 y 之间是互为对称的</p><p>D. 回归在 x 和 y 之间是对称的，相关在 x 和 y 之间是非对称的</p><p><strong>答案</strong>：C</p><p><strong>解析</strong>：相关（Correlation）是计算两个变量的线性相关程度，是对称的。也就是说，x 与 y 的相关系数和 y 与 x 的相关系数是一样的，没有差别。</p><p>回归（Regression）一般是利用 特征 x 预测输出 y，是单向的、非对称的。</p><p><strong>Q47. 仅仅知道变量的均值（Mean）和中值（Median），能计算的到变量的偏斜度（Skewness）吗？</strong></p><p>A. 可以</p><p>B. 不可以</p><p><strong>答案</strong>：B</p><p><strong>解析</strong>：偏斜度是对统计数据分布偏斜方向及程度的度量。偏斜度是利用 3 阶矩定义的，其计算公式如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5755183c130bc9de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Q1. 下列说法正确的是？（多选）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. AdaGrad 使用的是一阶导数&lt;/p&gt;
&lt;p&gt;B. L-BFGS 使用的是二阶导数&lt;/p&gt;
&lt;p&gt;C. AdaGrad 使用的是二阶导数&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十一）：二进制中1的个数</title>
    <link href="http://yoursite.com/2018/09/02/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2018/09/02/剑指Offer（十一）：二进制中1的个数/</id>
    <published>2018-09-02T09:10:48.000Z</published>
    <updated>2018-09-02T09:15:54.767Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现<strong>减1的结果是把最右边的一个1开始的所有位都取反了</strong>。这个时候如果我们再把原来的整数和减去1之后的结果做<strong>与运算</strong>，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count = 0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             ++count;</span><br><span class="line">             n = (n - 1) &amp; n;</span><br><span class="line">         &#125;</span><br><span class="line">         return count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在Python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机是以补码存在的，往右移，符号位不变，符号位1往右移，最终可能会出现全1的情况，导致死循环。与0xffffffff相与，就可以消除负数的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        count = 0</span><br><span class="line">        if n&lt;0:</span><br><span class="line">            n = n &amp; 0xffffffff</span><br><span class="line">        while n:</span><br><span class="line">            count += 1</span><br><span class="line">            n = n &amp; (n-1)</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure></p><p>或者可以使用一个更直观的方法，直接位移即可，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def NumberOf1(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        return sum([(n &gt;&gt; i &amp; 1) for i in range(0,32)])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="其它" scheme="http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十）：矩形覆盖</title>
    <link href="http://yoursite.com/2018/09/02/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2018/09/02/剑指Offer（十）：矩形覆盖/</id>
    <published>2018-09-02T08:01:03.000Z</published>
    <updated>2018-09-02T09:05:33.733Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>以2x8的矩形为例。示意图如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-186ab26d39d6ccaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角也横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是<strong>斐波那契数列</strong>。</p><p>注：这里用循环就好，用递归的话，时间复杂度比较高。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">if(number &lt;= 2)&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 1, second = 2, third = 0;</span><br><span class="line">        for(int i = 3; i &lt;= number; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        return third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def rectCover(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;= 2:</span><br><span class="line">            return number</span><br><span class="line">        first, second, third = 1, 2, 0</span><br><span class="line">        for i in range(3, number+1):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        return third</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（九）：变态跳台阶</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（九）：变态跳台阶/</id>
    <published>2018-09-01T15:42:23.000Z</published>
    <updated>2018-09-02T08:05:01.812Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我想说，这青蛙真变态，真能跳。</p><ul><li>当n=1时，结果为1；</li><li>当n=2时，结果为2；</li><li>当n=3时，结果为4；</li></ul><p>以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">if(number == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int total = 1;</span><br><span class="line">        for(int i = 1; i &lt; number; i++)&#123;</span><br><span class="line">            total *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def jumpFloorII(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;= 2:</span><br><span class="line">            return number</span><br><span class="line">        total = 1</span><br><span class="line">        for _ in range(1, number):</span><br><span class="line">            total *= 2</span><br><span class="line">        return total</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（八）：跳台阶</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（八）：跳台阶/</id>
    <published>2018-09-01T15:30:29.000Z</published>
    <updated>2018-09-02T08:05:07.039Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。</p><p>接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数<strong>f(n)=f(n-1)+f(n-2)</strong>。分析到这里，我们不难看出这实际上就是<strong>斐波那契数列</strong>了。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number &lt;= 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(number &lt; 3)&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = 1, second = 2, third = 0;</span><br><span class="line">        for(int i = 3; i &lt;= number; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        return third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt; 3:</span><br><span class="line">            return number</span><br><span class="line">        first, second, third = 1, 2, 0</span><br><span class="line">        for i in range(3, number+1):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        return third</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（七）：裴波那契数列</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A3%B4%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（七）：裴波那契数列/</id>
    <published>2018-09-01T15:03:28.000Z</published>
    <updated>2018-09-01T15:21:50.072Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）</p><a id="more"></a><p>斐波那契数列公式为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8953edbbc9043289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题递归很好写，但是存在<strong>很严重的效率问题。</strong>我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8a743d1342848c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们不难发现在这棵树中有<strong>很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大</strong>。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。</p><p>所以，使用简单的循环方法来实现。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>Ｃ++:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        first, second, third = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        <span class="keyword">return</span> third</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&amp;lt;=39）&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&amp;lt;=39）&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六）：旋转数组的最小数字</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（六）：旋转数组的最小数字/</id>
    <published>2018-09-01T12:22:31.000Z</published>
    <updated>2018-09-01T14:13:02.283Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为<strong>数组的旋转</strong>。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾</strong>，我们称之为<strong>数组的旋转</strong>。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我们注意到旋转之后的数组实际上可以划分为<strong>两个排序的子数组</strong>，而且前面的子数组的元素大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。在排序的数组中可以用二分查找实现O(logn)的查找。本题给出的数组在一定程度上是排序的，因此我们可以试着用二分查找法的思路来寻找这个最小的元素。</p><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</li><li>接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。</li><li>同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。</li><li>第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。</li></ul><p>示意图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-704dff113e4514da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>特殊情况：</p><ul><li><p>如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。</p></li><li><p>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-2dc939898031e973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int size = rotateArray.size();//数组长度</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;//左指针</span><br><span class="line">        int right = size - 1;//右指针</span><br><span class="line">        int mid = 0;//中间指针</span><br><span class="line">        while(rotateArray[left] &gt;= rotateArray[right])&#123;//确保旋转</span><br><span class="line">            if(right - left == 1)&#123;//左右指针相邻</span><br><span class="line">                mid = right;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / 2;//计算中间指针位置</span><br><span class="line">            //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找</span><br><span class="line">            if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123;</span><br><span class="line">                return MinInOrder(rotateArray, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面</span><br><span class="line">            if(rotateArray[mid] &gt;= rotateArray[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span><br><span class="line">            else&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //顺序寻找最小值</span><br><span class="line">    int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123;</span><br><span class="line">        int result = num[left];</span><br><span class="line">        for(int i = left + 1; i &lt; right; i++)&#123;</span><br><span class="line">            if(num[i] &lt; result)&#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(rotateArray) == 0:</span><br><span class="line">            return 0</span><br><span class="line">        left = 0</span><br><span class="line">        right = len(rotateArray) - 1</span><br><span class="line">        mid = 0</span><br><span class="line">        while rotateArray[left] &gt;= rotateArray[right]:</span><br><span class="line">            if right - left == 1:</span><br><span class="line">                mid = right</span><br><span class="line">                break</span><br><span class="line">            mid = left + (right - left) // 2</span><br><span class="line">            if rotateArray[left] == rotateArray[mid] and rotateArray[mid] == rotateArray[right]:</span><br><span class="line">                return self.minInorder(rotateArray, left, right)</span><br><span class="line">            if rotateArray[mid] &gt;= rotateArray[left]:</span><br><span class="line">                left = mid</span><br><span class="line">            else:</span><br><span class="line">                right = mid</span><br><span class="line">        return rotateArray[mid]</span><br><span class="line">    </span><br><span class="line">    def minInorder(self, array, left, right):</span><br><span class="line">        result = array[left]</span><br><span class="line">        for i in range(left+1, right+1):</span><br><span class="line">            if array[i] &lt; result:</span><br><span class="line">                result = array[i]</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为&lt;strong&gt;数组的旋转&lt;/strong&gt;。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;把一个数组最开始的若干个元素搬到数组的末尾&lt;/strong&gt;，我们称之为&lt;strong&gt;数组的旋转&lt;/strong&gt;。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五）：用两个栈实现队列</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（五）：用两个栈实现队列/</id>
    <published>2018-09-01T11:51:19.983Z</published>
    <updated>2018-09-01T12:23:38.162Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>用<strong>两个栈来实现一个队列，完成队列的Push和Pop操作</strong>。 队列中的元素为int类型。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>创建两个栈stack1和stack2，<strong>使用两个“先进后出”的栈实现一个“先进先出”的队列</strong>。</p><p>我们通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。</p><p>这个时候我们试着从队列中删除一个元素。按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。注意stack2我们一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。</p><p>因此我们的思路是：<strong>当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压倒stack1的栈底，经过弹出和压入之后就处于stack2的栈顶，有可以直接弹出。如果有新元素d插入，我们直接把它压入stack1即可。</strong></p><p>流程示意图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-2e93b8b8d543dcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(stack1.size() &gt; 0)&#123;</span><br><span class="line">                int data = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int pop_element = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return pop_element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong></p><p>对于python来讲，栈就是用list实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    def push(self, node):</span><br><span class="line">        # write code here</span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    def pop(self):</span><br><span class="line">        # return xx</span><br><span class="line">        if len(self.stack2) == 0:</span><br><span class="line">            while self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        return self.stack2.pop()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;两个栈来实现一个队列，完成队列的Push和Pop操作&lt;/strong&gt;。 队列中的元素为int类型。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四）：重建二叉树</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（四）：重建二叉树/</id>
    <published>2018-09-01T08:35:08.000Z</published>
    <updated>2018-09-01T09:16:32.414Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>输入某二叉树的<strong>前序遍历</strong>和<strong>中序遍历</strong>的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><a id="more"></a><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a95a5f2e70bca737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>通常树有如下几种遍历方式：</p><ul><li>前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。<strong>根左右</strong></li><li>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。<strong>左根右</strong></li><li>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。<strong>左右根</strong></li></ul><p>本题为前序遍历和中序遍历，<strong>最少需要两种遍历方式，才能重建二叉树。</strong></p><p>前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以<strong>递归</strong>来实现，具体如图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e417b447c5ba0b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">if(pre.size() == 0)&#123;//如果为空，返回NULL</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次是前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树</span><br><span class="line">        vector&lt;int&gt; left_pre, right_pre, left_vin, right_vin;</span><br><span class="line">        //中序遍历第一个节点一定为根节点</span><br><span class="line">        TreeNode* head = new TreeNode(pre[0]);</span><br><span class="line">        //找到中序遍历的根节点</span><br><span class="line">        int root = 0;</span><br><span class="line">        //遍历找到中序遍历根节点索引值</span><br><span class="line">        for(int i = 0; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            if(pre[0] == vin[i])&#123;</span><br><span class="line">                root = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       //利用中序遍历的根节点，对二叉树节点进行归并</span><br><span class="line">        for(int i = 0; i &lt; root; i++)&#123;</span><br><span class="line">            left_vin.push_back(vin[i]);</span><br><span class="line">            left_pre.push_back(pre[i + 1]);//前序遍历第一个为根节点</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = root + 1; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            right_vin.push_back(vin[i]);</span><br><span class="line">            right_pre.push_back(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br><span class="line">        head-&gt;left = reConstructBinaryTree(left_pre, left_vin);</span><br><span class="line">        head-&gt;right = reConstructBinaryTree(right_pre, right_vin);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(pre) == 0:</span><br><span class="line">            return None</span><br><span class="line">        elif len(pre) == 1:</span><br><span class="line">            return TreeNode(pre[0])</span><br><span class="line">        else:</span><br><span class="line">            root = TreeNode(pre[0])</span><br><span class="line">            pos = tin.index(pre[0])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;输入某二叉树的&lt;strong&gt;前序遍历&lt;/strong&gt;和&lt;strong&gt;中序遍历&lt;/strong&gt;的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三）：从尾到头打印链表</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（三）：从尾到头打印链表/</id>
    <published>2018-09-01T07:51:52.000Z</published>
    <updated>2018-09-01T08:36:10.846Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>输入一个链表，返回一个反序的链表。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个链表，返回一个反序的链表。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>通常，这种情况下，我们<strong>不希望修改原链表的结构</strong>。返回一个反序的链表，这就是经典的<strong>“后进先出”</strong>，我们可以使用<strong>栈</strong>实现这种顺序。<strong>每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，给一个新的链表结构，这样链表就实现了反转。</strong></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong></p><p>对于python来讲，不用如此麻烦，我们可以直接使用<strong>列表</strong>的插入方法，<strong>每次插入数据，只插入在首位</strong>s。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            result.insert(<span class="number">0</span>, listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;输入一个链表，返回一个反序的链表。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;输入一个链表，返回一个反序的链表。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
