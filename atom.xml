<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaDaVision</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-01T15:08:34.210Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tengda Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer（七）：裴波那契数列</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A3%B4%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（七）：裴波那契数列/</id>
    <published>2018-09-01T15:03:28.000Z</published>
    <updated>2018-09-01T15:08:34.210Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）</p><a id="more"></a><p>斐波那契数列公式为：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8953edbbc9043289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8a743d1342848c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。</p><p>所以，使用简单的循环方法来实现。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>Ｃ++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n &lt;= 0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n == 1)</span><br><span class="line">            return 1;</span><br><span class="line">        int first = 0, second = 1, third = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        return third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;= 1:</span><br><span class="line">            return n</span><br><span class="line">        first, second, third = 0, 1, 0</span><br><span class="line">        for i in range(2, n+1):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        return third</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&amp;lt;=39）&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&amp;lt;=39）&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六）：旋转数组的最小数字</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（六）：旋转数组的最小数字/</id>
    <published>2018-09-01T12:22:31.000Z</published>
    <updated>2018-09-01T14:13:02.283Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为<strong>数组的旋转</strong>。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾</strong>，我们称之为<strong>数组的旋转</strong>。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>我们注意到旋转之后的数组实际上可以划分为<strong>两个排序的子数组</strong>，而且前面的子数组的元素大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。在排序的数组中可以用二分查找实现O(logn)的查找。本题给出的数组在一定程度上是排序的，因此我们可以试着用二分查找法的思路来寻找这个最小的元素。</p><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</li><li>接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。</li><li>同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。</li><li>第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。</li></ul><p>示意图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-704dff113e4514da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>特殊情况：</p><ul><li><p>如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。</p></li><li><p>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-2dc939898031e973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int size = rotateArray.size();//数组长度</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;//左指针</span><br><span class="line">        int right = size - 1;//右指针</span><br><span class="line">        int mid = 0;//中间指针</span><br><span class="line">        while(rotateArray[left] &gt;= rotateArray[right])&#123;//确保旋转</span><br><span class="line">            if(right - left == 1)&#123;//左右指针相邻</span><br><span class="line">                mid = right;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / 2;//计算中间指针位置</span><br><span class="line">            //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找</span><br><span class="line">            if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123;</span><br><span class="line">                return MinInOrder(rotateArray, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面</span><br><span class="line">            if(rotateArray[mid] &gt;= rotateArray[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面</span><br><span class="line">            else&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //顺序寻找最小值</span><br><span class="line">    int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123;</span><br><span class="line">        int result = num[left];</span><br><span class="line">        for(int i = left + 1; i &lt; right; i++)&#123;</span><br><span class="line">            if(num[i] &lt; result)&#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(rotateArray) == 0:</span><br><span class="line">            return 0</span><br><span class="line">        left = 0</span><br><span class="line">        right = len(rotateArray) - 1</span><br><span class="line">        mid = 0</span><br><span class="line">        while rotateArray[left] &gt;= rotateArray[right]:</span><br><span class="line">            if right - left == 1:</span><br><span class="line">                mid = right</span><br><span class="line">                break</span><br><span class="line">            mid = left + (right - left) // 2</span><br><span class="line">            if rotateArray[left] == rotateArray[mid] and rotateArray[mid] == rotateArray[right]:</span><br><span class="line">                return self.minInorder(rotateArray, left, right)</span><br><span class="line">            if rotateArray[mid] &gt;= rotateArray[left]:</span><br><span class="line">                left = mid</span><br><span class="line">            else:</span><br><span class="line">                right = mid</span><br><span class="line">        return rotateArray[mid]</span><br><span class="line">    </span><br><span class="line">    def minInorder(self, array, left, right):</span><br><span class="line">        result = array[left]</span><br><span class="line">        for i in range(left+1, right+1):</span><br><span class="line">            if array[i] &lt; result:</span><br><span class="line">                result = array[i]</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为&lt;strong&gt;数组的旋转&lt;/strong&gt;。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;把一个数组最开始的若干个元素搬到数组的末尾&lt;/strong&gt;，我们称之为&lt;strong&gt;数组的旋转&lt;/strong&gt;。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五）：用两个栈实现队列</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（五）：用两个栈实现队列/</id>
    <published>2018-09-01T11:51:19.983Z</published>
    <updated>2018-09-01T12:23:38.162Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>用<strong>两个栈来实现一个队列，完成队列的Push和Pop操作</strong>。 队列中的元素为int类型。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>创建两个栈stack1和stack2，<strong>使用两个“先进后出”的栈实现一个“先进先出”的队列</strong>。</p><p>我们通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。</p><p>这个时候我们试着从队列中删除一个元素。按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。注意stack2我们一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。</p><p>因此我们的思路是：<strong>当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压倒stack1的栈底，经过弹出和压入之后就处于stack2的栈顶，有可以直接弹出。如果有新元素d插入，我们直接把它压入stack1即可。</strong></p><p>流程示意图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-2e93b8b8d543dcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(stack1.size() &gt; 0)&#123;</span><br><span class="line">                int data = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int pop_element = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return pop_element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong></p><p>对于python来讲，栈就是用list实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    def push(self, node):</span><br><span class="line">        # write code here</span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    def pop(self):</span><br><span class="line">        # return xx</span><br><span class="line">        if len(self.stack2) == 0:</span><br><span class="line">            while self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        return self.stack2.pop()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;两个栈来实现一个队列，完成队列的Push和Pop操作&lt;/strong&gt;。 队列中的元素为int类型。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四）：重建二叉树</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（四）：重建二叉树/</id>
    <published>2018-09-01T08:35:08.000Z</published>
    <updated>2018-09-01T09:16:32.414Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>输入某二叉树的<strong>前序遍历</strong>和<strong>中序遍历</strong>的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><a id="more"></a><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a95a5f2e70bca737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>通常树有如下几种遍历方式：</p><ul><li>前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。<strong>根左右</strong></li><li>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。<strong>左根右</strong></li><li>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。<strong>左右根</strong></li></ul><p>本题为前序遍历和中序遍历，<strong>最少需要两种遍历方式，才能重建二叉树。</strong></p><p>前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以<strong>递归</strong>来实现，具体如图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e417b447c5ba0b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">if(pre.size() == 0)&#123;//如果为空，返回NULL</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次是前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树</span><br><span class="line">        vector&lt;int&gt; left_pre, right_pre, left_vin, right_vin;</span><br><span class="line">        //中序遍历第一个节点一定为根节点</span><br><span class="line">        TreeNode* head = new TreeNode(pre[0]);</span><br><span class="line">        //找到中序遍历的根节点</span><br><span class="line">        int root = 0;</span><br><span class="line">        //遍历找到中序遍历根节点索引值</span><br><span class="line">        for(int i = 0; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            if(pre[0] == vin[i])&#123;</span><br><span class="line">                root = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       //利用中序遍历的根节点，对二叉树节点进行归并</span><br><span class="line">        for(int i = 0; i &lt; root; i++)&#123;</span><br><span class="line">            left_vin.push_back(vin[i]);</span><br><span class="line">            left_pre.push_back(pre[i + 1]);//前序遍历第一个为根节点</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = root + 1; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            right_vin.push_back(vin[i]);</span><br><span class="line">            right_pre.push_back(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br><span class="line">        head-&gt;left = reConstructBinaryTree(left_pre, left_vin);</span><br><span class="line">        head-&gt;right = reConstructBinaryTree(right_pre, right_vin);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(pre) == 0:</span><br><span class="line">            return None</span><br><span class="line">        elif len(pre) == 1:</span><br><span class="line">            return TreeNode(pre[0])</span><br><span class="line">        else:</span><br><span class="line">            root = TreeNode(pre[0])</span><br><span class="line">            pos = tin.index(pre[0])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;输入某二叉树的&lt;strong&gt;前序遍历&lt;/strong&gt;和&lt;strong&gt;中序遍历&lt;/strong&gt;的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三）：从尾到头打印链表</title>
    <link href="http://yoursite.com/2018/09/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/09/01/剑指Offer（三）：从尾到头打印链表/</id>
    <published>2018-09-01T07:51:52.000Z</published>
    <updated>2018-09-01T08:36:10.846Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>输入一个链表，返回一个反序的链表。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>输入一个链表，返回一个反序的链表。</p><a id="more"></a><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>通常，这种情况下，我们<strong>不希望修改原链表的结构</strong>。返回一个反序的链表，这就是经典的<strong>“后进先出”</strong>，我们可以使用<strong>栈</strong>实现这种顺序。<strong>每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，给一个新的链表结构，这样链表就实现了反转。</strong></p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p><strong>C++:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong></p><p>对于python来讲，不用如此麻烦，我们可以直接使用<strong>列表</strong>的插入方法，<strong>每次插入数据，只插入在首位</strong>s。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            result.insert(<span class="number">0</span>, listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;输入一个链表，返回一个反序的链表。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;输入一个链表，返回一个反序的链表。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>topK问题</title>
    <link href="http://yoursite.com/2018/09/01/topK%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/01/topK问题/</id>
    <published>2018-09-01T03:41:51.000Z</published>
    <updated>2018-09-01T04:06:41.377Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：有 N (N&gt;1000000)个数,求出其中的前K个最小的数（又被称作topK问题）。</p><p>针对topK类问题，通常比较好的方案是<strong>【分治+trie树/hash+小顶堆】</strong>，即先将数据集按照hash算法分解成多个小数据集，然后使用<strong>trie</strong>树或者hash表统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。<br><a id="more"></a></p><p>实际上，最优的解决方案应该是最符合实际设计需求的方案，在实际应用中，可能有足够大的内存，那么直接将数据扔到内存中一次性处理即可，也可能机器有多个核，这样可以采用多线程处理整个数据集。</p><p>第一种方法将数据<strong>全部排序</strong> ，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为<strong>O（nlogn）</strong>，如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</p><p>第二种方法为<strong>局部淘汰法</strong>，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。</p><p> 第三种方法是<strong>分治法</strong>，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100<em>10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6</em>4=4MB，一共需要101次这样的比较。</p><p>第四种方法是<strong>Hash法</strong>。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。</p><p>第五种方法采用<strong>最小堆</strong>。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。</p><p>还有没有更简单的算法呢？答案是肯定的。 </p><p>第六种方法<strong>利用快速排序的分划函数找到分划位置K，则其前面的内容即为所求。</strong>该算法是一种非常有效的处理方式，时间复杂度是<strong>O(N)</strong>（证明可以参考算法导论书籍）。对于能一次加载到内存中的数组，该策略非常优秀。如果能完整写出代码，那么相信面试官会对你刮目相看的。</p><p>下面，给出第六种方法的Python代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(L, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将L[left:right]进行一次快速排序的partition，返回分割点</span></span><br><span class="line"><span class="string">   :param L: 数据List</span></span><br><span class="line"><span class="string">    :param left: 排序起始位置</span></span><br><span class="line"><span class="string">   :param right: 排序终止位置</span></span><br><span class="line"><span class="string">   :return: 分割点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        <span class="keyword">print</span> left</span><br><span class="line">        key = L[left]</span><br><span class="line">        low = left</span><br><span class="line">        high = right</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> L[high] &gt;= key:</span><br><span class="line">                high = high - <span class="number">1</span></span><br><span class="line">            L[low] = L[high]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> L[low] &lt;= key:</span><br><span class="line">                low = low + <span class="number">1</span></span><br><span class="line">            L[high] = L[low]</span><br><span class="line">        L[low] = key</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topK</span><span class="params">(L, K)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求L中的前K个最小值</span></span><br><span class="line"><span class="string">   :param L: 数据List</span></span><br><span class="line"><span class="string">    :param K: 最小值的数目</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(L) &lt; K:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(L) - <span class="number">1</span></span><br><span class="line">    j = partition(L, low, high)</span><br><span class="line">    <span class="keyword">while</span> j != K: <span class="comment"># 划分位置不是K则继续处理</span></span><br><span class="line">      <span class="keyword">if</span> K &gt; j: <span class="comment">#k在分划点后面部分</span></span><br><span class="line">         low = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = j  <span class="comment"># K在分划点前面部分</span></span><br><span class="line">      j = partition(L, low, high)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：有 N (N&amp;gt;1000000)个数,求出其中的前K个最小的数（又被称作topK问题）。&lt;/p&gt;
&lt;p&gt;针对topK类问题，通常比较好的方案是&lt;strong&gt;【分治+trie树/hash+小顶堆】&lt;/strong&gt;，即先将数据集按照hash算法分解成多个小数据集，然后使用&lt;strong&gt;trie&lt;/strong&gt;树或者hash表统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="海量数据" scheme="http://yoursite.com/tags/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="topK" scheme="http://yoursite.com/tags/topK/"/>
    
  </entry>
  
  <entry>
    <title>判别式模型和生成式模型</title>
    <link href="http://yoursite.com/2018/08/26/%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/08/26/判别式模型和生成式模型/</id>
    <published>2018-08-26T14:12:53.000Z</published>
    <updated>2018-08-27T02:28:12.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判别式模型-与-生成式模型"><a href="#判别式模型-与-生成式模型" class="headerlink" title="判别式模型 与 生成式模型"></a>判别式模型 与 生成式模型</h1><p>生成式模型(Generative Model)与判别式模型(Discrimitive Model)是分类器常遇到的概念，它们的区别在于：</p><p>对于输入x，类别标签y：</p><ul><li><strong>判别式模型</strong>估计<strong>条件概率分布$P(y|x)$</strong>（y在x下的概率 ），直接对条件概率$p(y|x;θ)$建模 。</li></ul><p><strong>举例：要确定一个羊是山羊还是绵羊，用判别模型的方法是从历史数据中学习到模型，然后通过提取这只羊的特征来预测出这只羊是山羊的概率，是绵羊的概率。</strong></p><ul><li><strong>生成式模型</strong>估计它们的<strong>联合概率分布$P(x,y)$</strong>。会对x和y的联合分布$p(x,y)$建模，然后通过贝叶斯公式来求得$p(y_{i}|x)$，然后选取使得$p(y_{i}|x)$最大的$y_{i}$，即： </li></ul><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe1eb0dcb7a6c930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>举例：利用生成模型是根据山羊的特征首先学习出一个山羊的模型，然后根据绵羊的特征学习出一个绵羊的模型，然后从这只羊中提取特征，放到山羊模型中看概率是多少，在放到绵羊模型中看概率是多少，哪个大就是哪个。</strong> </p><p><strong>生成式模型可以根据贝叶斯公式得到判别式模型，但反过来不行</strong>。</p><h2 id="判别式模型常见的主要有："><a href="#判别式模型常见的主要有：" class="headerlink" title="判别式模型常见的主要有："></a><strong>判别式模型常见的主要有：</strong></h2><ul><li>线性回归(Linear Regression)</li><li>逻辑回归(Logistic Regression)</li><li>决策树</li><li>神经网络(NN)</li><li>支持向量机(SVM)</li><li>高斯过程(Gaussian Process)</li><li>条件随机场(CRF)</li><li>CART(Classification and Regression Tree)</li><li>Boosting</li></ul><h2 id="生成式模型常见的主要有："><a href="#生成式模型常见的主要有：" class="headerlink" title="生成式模型常见的主要有："></a><strong>生成式模型常见的主要有：</strong></h2><ul><li>朴素贝叶斯</li><li>K近邻(KNN)</li><li>混合高斯模型</li><li>隐马尔科夫模型(HMM)</li><li>贝叶斯网络</li><li>Sigmoid Belief Networks</li><li>马尔科夫随机场(Markov Random Fields)</li><li>深度信念网络(DBN)</li></ul><p>​    假设你现在有一个分类问题，x是特征，y是类标记。用生成模型学习一个联合概率分布$P（x，y）$，而用判别模型学习一个条件概率分布$P（y|x）$。<br>    用一个简单的例子来说明这个这个问题。假设x就是两个（1或2），y有两类（0或1），有如下如下样本（1，0）、（1，0）、（2，0）、（2，1）<br>则学习到的<strong>联合概率分布$P（x，y）$</strong>（生成模型）如下：</p><table><thead><tr><th></th><th>y=0</th><th>y=1</th></tr></thead><tbody><tr><td>x=1</td><td>1/2</td><td>0</td></tr><tr><td>x=2</td><td>1/4</td><td>1/4</td></tr></tbody></table><p>而学习到的<strong>条件概率分布</strong>$P（y|x）$（判别模型）如下： </p><table><thead><tr><th></th><th>y=0</th><th>y=1</th></tr></thead><tbody><tr><td>x=1</td><td>1</td><td>0</td></tr><tr><td>x=2</td><td>1/2</td><td>1/2</td></tr></tbody></table><p>​    在实际分类问题中，<strong>判别模型可以直接用来判断特征的类别情况</strong>，而<strong>生成模型，需要加上贝叶斯法则</strong>，然后应用到分类中。但是，生成模型的概率分布可以还有其他应用，就是说生成模型更一般更普适。不过判别模型更直接，更简单。 </p><h1 id="两个模型的对比"><a href="#两个模型的对比" class="headerlink" title="两个模型的对比"></a>两个模型的对比</h1><p><img src="https://upload-images.jianshu.io/upload_images/12654931-8a5d642f888471b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判别式模型-与-生成式模型&quot;&gt;&lt;a href=&quot;#判别式模型-与-生成式模型&quot; class=&quot;headerlink&quot; title=&quot;判别式模型 与 生成式模型&quot;&gt;&lt;/a&gt;判别式模型 与 生成式模型&lt;/h1&gt;&lt;p&gt;生成式模型(Generative Model)与判别式模型(Discrimitive Model)是分类器常遇到的概念，它们的区别在于：&lt;/p&gt;
&lt;p&gt;对于输入x，类别标签y：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;判别式模型&lt;/strong&gt;估计&lt;strong&gt;条件概率分布$P(y|x)$&lt;/strong&gt;（y在x下的概率 ），直接对条件概率$p(y|x;θ)$建模 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举例：要确定一个羊是山羊还是绵羊，用判别模型的方法是从历史数据中学习到模型，然后通过提取这只羊的特征来预测出这只羊是山羊的概率，是绵羊的概率。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生成式模型&lt;/strong&gt;估计它们的&lt;strong&gt;联合概率分布$P(x,y)$&lt;/strong&gt;。会对x和y的联合分布$p(x,y)$建模，然后通过贝叶斯公式来求得$p(y_{i}|x)$，然后选取使得$p(y_{i}|x)$最大的$y_{i}$，即： &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="判别式模型" scheme="http://yoursite.com/tags/%E5%88%A4%E5%88%AB%E5%BC%8F%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="生成式模型" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%BC%8F%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二）：替换空格</title>
    <link href="http://yoursite.com/2018/08/25/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/08/25/剑指Offer（二）：替换空格/</id>
    <published>2018-08-25T13:42:37.000Z</published>
    <updated>2018-09-01T05:10:42.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer-二-：替换空格"><a href="#剑指Offer-二-：替换空格" class="headerlink" title="剑指Offer(二)：替换空格"></a>剑指Offer(二)：替换空格</h1><p>摘要</p><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指Offer》刷题笔记。</p><p>刷题平台：[牛客网]</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>请实现一个函数，将一个[字符串]中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>最简单的方法就是从头到尾遍历，但是时间复杂度为O(n^2)。</p><p>本文采用一种时间复杂度为O(n)的方法。</p><p>我们可以先遍历一次字符串，这样就可以统计出字符串空格的总数，并可以由此计算出替换之后的字符串的总长度。<strong>每替换一个空格，长度增加2</strong>，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。</p><p>我们从字符串的尾部开始复制和替换。首先准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串”%20”。由于”%20”的长度为3，同时也要把P2向前移动3格。</p><p>移动示意图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8645629703febdaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2、编程实现"><a href="#2、编程实现" class="headerlink" title="2、编程实现"></a>2、编程实现</h3><p><strong>C++：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*original_length为字符串str的实际长度*/</span></span><br><span class="line">        <span class="keyword">int</span> original_length = <span class="number">0</span>;<span class="comment">//原始长度</span></span><br><span class="line">        <span class="keyword">int</span> number_blank = <span class="number">0</span>;<span class="comment">//空格数</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span>(str[i++] != <span class="string">'\0'</span>)&#123;<span class="comment">//遍历字符串</span></span><br><span class="line">            ++original_length;<span class="comment">//长度+1</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                ++number_blank;<span class="comment">//遇到空格+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*new_length为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> new_length = original_length + <span class="number">2</span> * number_blank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index_original = original_length;<span class="comment">//原始字符串末尾索引值</span></span><br><span class="line">        <span class="keyword">int</span> index_new = new_length;<span class="comment">//计算长度后的字符串末尾索引值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*index_original指针开始向前移动，如果遇到空格，替换成'%20'，否则进行复制操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(index_original &gt;= <span class="number">0</span> &amp;&amp; index_new &gt; index_original)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[index_original] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[index_new--] = <span class="string">'0'</span>;</span><br><span class="line">                str[index_new--] = <span class="string">'2'</span>;</span><br><span class="line">                str[index_new--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[index_new--] = str[index_original];</span><br><span class="line">            &#125;</span><br><span class="line">            --index_original;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Python2.7：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer-二-：替换空格&quot;&gt;&lt;a href=&quot;#剑指Offer-二-：替换空格&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer(二)：替换空格&quot;&gt;&lt;/a&gt;剑指Offer(二)：替换空格&lt;/h1&gt;&lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指Offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：[牛客网]&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;请实现一个函数，将一个[字符串]中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>为什么梯度的负方向是梯度下降最快的方向</title>
    <link href="http://yoursite.com/2018/08/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A2%AF%E5%BA%A6%E7%9A%84%E8%B4%9F%E6%96%B9%E5%90%91%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%B9%E5%90%91/"/>
    <id>http://yoursite.com/2018/08/25/为什么梯度的负方向是梯度下降最快的方向/</id>
    <published>2018-08-25T11:52:01.000Z</published>
    <updated>2018-08-25T13:11:20.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是梯度？"><a href="#什么是梯度？" class="headerlink" title="什么是梯度？"></a>什么是梯度？</h2><p>​    对于梯度下降算法（Gradient Descent Algorithm），我们都已经很熟悉了。无论是在线性回归（Linear Regression）、逻辑回归（Logistic Regression）还是神经网络（Neural Network）等等，都会用到梯度下降算法。我们先来看一下梯度下降算法的直观解释：</p><p>​    假设我们位于山的某个山腰处，山势连绵不绝，不知道怎么下山。于是决定走一步算一步，也就是每次沿着当前位置最陡峭最易下山的方向前进一小步，然后继续沿下一个位置最陡方向前进一小步。这样一步一步走下去，一直走到觉得我们已经到了山脚。这里的<strong>下山最陡的方向就是梯度的负方向</strong>。    </p><p>​    首先理解什么是<strong>梯度</strong>？通俗来说，<strong>梯度就是表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在当前位置的导数</strong>。</p><p>$∇=\frac{df(\theta)}{d\theta}$</p><a id="more"></a><p>上式中，$\theta$是自变量，$f(\theta)$是关于$\theta$的函数，$\theta$表示梯度。</p><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>​    如果函数$f(\theta)$是凸函数，那么就可以使用梯度下降算法进行优化。梯度下降算法的公式我们已经很熟悉了：</p><p>$\theta=\theta_{0}−η⋅∇f(\theta_{0})$</p><p>​    其中，$\theta_{0}$是自变量参数，即下山位置坐标，$η$是学习因子，即下山每次前进的一小步（步进长度），$\theta$是更新后的$\theta_{0}$，即下山移动一小步之后的位置。</p><p>​    梯度下降算法的公式非常简单！但是”沿着梯度的反方向（坡度最陡）“是我们日常经验得到的，其本质的原因到底是什么呢？为什么局部下降最快的方向就是梯度的负方向呢？也许很多朋友还不太清楚。没关系，接下来我将以通俗的语言来详细解释梯度下降算法公式的数学推导过程。</p><h2 id="一阶泰勒展开式"><a href="#一阶泰勒展开式" class="headerlink" title="一阶泰勒展开式"></a>一阶泰勒展开式</h2><p>​    这里需要一点数学基础，对泰勒展开式有些了解。简单地来说，泰勒展开式利用的就是函数的局部线性近似这个概念。我们以一阶泰勒展开式为例：</p><p>$f(\theta)\approx f(\theta_{0})+(\theta-\theta_{0})\cdot\bigtriangledown f(\theta_{0})$</p><p>不懂上面的公式？没有关系。用下面这张图来解释。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-d3059cfb700bba95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>凸函数$f(\theta)​$的某一小段$[\theta_{0},\theta]​$由上图黑色曲线表示，可以利用线性近似的思想求出$f(\theta)​$的值，如上图红色直线。该直线的斜率等于$f(\theta)​$在$\theta_{0}​$处的导数。则根据直线方程，很容易得到$f(\theta)​$的近似表达式为：</p><p>$f(\theta)\approx f(\theta_{0})+(\theta-\theta_{0})\cdot\bigtriangledown f(\theta_{0})$</p><p>这就是一阶泰勒展开式的推导过程，主要利用的数学思想就是曲线函数的线性拟合近似。</p><h2 id="梯度下降数学原理"><a href="#梯度下降数学原理" class="headerlink" title="梯度下降数学原理"></a>梯度下降数学原理</h2><p>知道了一阶泰勒展开式之后，接下来就是重点了！我们来看一下梯度下降算法是如何推导的。</p><p>先写出一阶泰勒展开式的表达式：</p><p>$f(\theta)≈f(\theta_{0})+(\theta−\theta_{0})⋅∇f(\theta_{0})$</p><p>其中，$\theta−\theta_{0}$是微小矢量，它的大小就是我们之前讲的步进长度η，类比于下山过程中每次前进的一小步，η为标量，而$\theta−\theta_{0}$的单位向量用$v$表示。则$\theta−\theta_{0}$可表示为：</p><p>$\theta−\theta_{0}=ηv$</p><p>特别需要注意的是，$\theta−\theta_{0}$不能太大，因为太大的话，线性近似就不够准确，一阶泰勒近似也不成立了。替换之后，$f(\theta)$的表达式为：</p><p>$f(\theta)≈f(\theta_{0})+ηv⋅∇f(\theta_{0})$</p><p>重点来了，局部下降的目的是希望每次$\theta$更新，都能让函数值$f(\theta)$变小。也就是说，上式中，我们希望$f(\theta)&lt;f(\theta_{0})$。则有：</p><p>$f(\theta)−f(\theta_{0})≈ηv⋅∇f(\theta_{0})&lt;0$</p><p>因为$η$为标量，且一般设定为正值，所以可以忽略，不等式变成了：</p><p>$v⋅∇f(\theta_{0})&lt;0$</p><p>上面这个不等式非常重要！$v$和$∇f(\theta_{0})$都是向量，$∇f(\theta_{0})$是当前位置的梯度方向，$v$表示下一步前进的单位向量，是需要我们求解的，有了它，就能根据$\theta−\theta_{0}=ηv$确定$\theta$值了。</p><p>想要两个向量的乘积小于零，我们先来看一下两个向量乘积包含哪几种情况：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f7f779a9600abcb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>A和B均为向量，$α$为两个向量之间的夹角。A和B的乘积为：</p><p>$A⋅B=||A||⋅||B||⋅cos(α)$</p><p>$||A||$和$||B||$均为标量，在$||A||$和$||B||$确定的情况下，只要$cos(α)=−1$，即A和B完全反向，就能让A和B的向量乘积最小（负最大值）。</p><p>顾名思义，当$v$与$∇f(\theta_{0})$互为反向，即$v$为当前梯度方向的负方向的时候，能让$v⋅∇f(\theta_{0})$最大程度地小，也就保证了$v$的方向是局部下降最快的方向。</p><p>知道$v$是$∇f(\theta_{0})$的反方向后，可直接得到：</p><p>$v=−\frac{∇f(\theta_{0})}{||∇f(\theta_{0})||}$</p><p>之所以要除以$∇f(\theta_{0})$的模$||∇f(\theta_{0})||$，是因为$v$是单位向量。</p><p>求出最优解$v$之后，带入到$\theta−\theta_{0}=ηv$中，得：</p><p>$v=\theta_{0}−η\frac{∇f(\theta_{0})}{||∇f(\theta_{0})||}$</p><p>一般地，因为$||∇f(\theta_{0})||$是标量，可以并入到步进因子$η$中，即简化为：</p><p>$\theta=\theta_{0}−η∇f(\theta_{0})$</p><p>这样，我们就推导得到了梯度下降算法中$\theta$的更新表达式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一阶泰勒展开式，利用线性近似和向量相乘最小化的思想搞懂了梯度下降算法的数学原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是梯度？&quot;&gt;&lt;a href=&quot;#什么是梯度？&quot; class=&quot;headerlink&quot; title=&quot;什么是梯度？&quot;&gt;&lt;/a&gt;什么是梯度？&lt;/h2&gt;&lt;p&gt;​    对于梯度下降算法（Gradient Descent Algorithm），我们都已经很熟悉了。无论是在线性回归（Linear Regression）、逻辑回归（Logistic Regression）还是神经网络（Neural Network）等等，都会用到梯度下降算法。我们先来看一下梯度下降算法的直观解释：&lt;/p&gt;
&lt;p&gt;​    假设我们位于山的某个山腰处，山势连绵不绝，不知道怎么下山。于是决定走一步算一步，也就是每次沿着当前位置最陡峭最易下山的方向前进一小步，然后继续沿下一个位置最陡方向前进一小步。这样一步一步走下去，一直走到觉得我们已经到了山脚。这里的&lt;strong&gt;下山最陡的方向就是梯度的负方向&lt;/strong&gt;。    &lt;/p&gt;
&lt;p&gt;​    首先理解什么是&lt;strong&gt;梯度&lt;/strong&gt;？通俗来说，&lt;strong&gt;梯度就是表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在当前位置的导数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;$∇=\frac{df(\theta)}{d\theta}$&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="梯度下降" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>协方差与相关系数</title>
    <link href="http://yoursite.com/2018/08/25/%E5%8D%8F%E6%96%B9%E5%B7%AE%E4%B8%8E%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/25/协方差与相关系数/</id>
    <published>2018-08-25T02:52:46.000Z</published>
    <updated>2018-08-28T08:14:48.396Z</updated>
    
    <content type="html"><![CDATA[<p>什么是协方差（Covariance）？</p><blockquote><p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。</p></blockquote><p>以上是某百科的解释。</p><p><strong>1、协方差是怎么来的？</strong></p><a id="more"></a><p>​    简单地来说，<strong>协方差</strong>就是反映两个变量 X 和 Y 的相互关系。这种相互关系大致分为三种：<strong>正相关</strong>、<strong>负相关</strong>、<strong>不相关</strong>。</p><p>​    什么是正相关呢？例如房屋面积（X）越大，房屋总价（Y）越高，则房屋面积与房屋总价是正相关的；</p><p>​    什么是负相关呢？例如一个学生打游戏的时间（X）越多，学习成绩（Y）越差，则打游戏时间与学习成绩是负相关的；</p><p>​    什么是不相关呢？例如一个人皮肤的黑白程度（X）与他的身体健康程度（Y）并无明显关系，所以是不相关的。</p><p>我们先来看第一种情况，令变量 X 和变量 Y 分别为：</p><p>X = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y = [12 15 17 21 22 21 18 23 26 25 22 28 24 28 30 33 28 34 36 35]</p><p>在坐标上描绘出 X 和 Y 的联合分布：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c7b704496e93a645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，Y 在整体趋势上是随着 X 的增加而增加的，即 Y 与 X 的变化是同向的。这种情况，我们就称 X 与 Y 是<strong>正相关</strong>的。</p><p>我们再来看第二种情况，令变量 X 和变量 Y 分别为：</p><p>X = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y = [35 35 29 29 28 28 27 26 26 23 21 22 25 19 16 19 20 16 15 16]</p><p>在坐标上描绘出 X 和 Y 的联合分布：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-449b98898b06e5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，Y 在整体趋势上是随着 X 的增加而减少的，即 Y 与 X 的变化是反向的。这种情况，我们就称 X 与 Y 是<strong>负相关</strong>的。</p><p>我们再来看第三种情况，令变量 X 和变量 Y 分别为：</p><p>X = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y = [16 16 28 17 20 26 20 17 21 15 12 29 24 25 16 15 21 13 17 25]</p><p>在坐标上描绘出 X 和 Y 的联合分布：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-783fd5ff0bdbf5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，Y 在整体趋势上与 X 的并无正相关或者负相关的关系。这种情况，我们就称 X 与 Y 是<strong>不相关</strong>的。</p><p>回过头来，我们来看 X 与 Y 正相关的情况，令 EX、EY 分别是 X 和 Y 的<strong>期望</strong>值。什么是期望呢？在这里我们可以把它看成是<strong>平均值</strong>，即 EX 是变量 X 的平均值，EY 是变量 Y 的平均值。把 EX 和 EY 在图中表示出来得到下面的图形：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5af683128993d898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中，整个区域被 EX 和 EY 分割成 I、II、III、IV 四个区域，且 X 和 Y 大部分分布在 I、III 区域内，只有少部分分布在 II、IV 区域内。</p><p>在区域 I 中，满足 X&gt;EX，Y&gt;EY，则有 (X-EX)(Y-EY)&gt;0；</p><p>在区域 II 中，满足 X&lt;EX，Y&gt;EY，则有 (X-EX)(Y-EY)&lt;0；</p><p>在区域 III 中，满足 X&lt;EX，Y&lt;EY，则有 (X-EX)(Y-EY)&gt;0；</p><p>在区域 IV 中，满足 X&gt;EX，Y&lt;EY，则有 (X-EX)(Y-EY)&lt;0。</p><p>显然，在区域 I、III 中，(X-EX)(Y-EY)&gt;0；在区域 II、IV 中，(X-EX)(Y-EY)&lt;0。而 X 和 Y 正相关时，数据大部分是分布在 I、III 区域内，只有少部分分布在 II、IV 区域。因此，从平均角度来看，正相关满足：</p><p>$E(X-EX)(Y-EY)&gt;0$</p><p>上式表示的是 (X-EX)(Y-EY) 的期望大于零，即 (X-EX)(Y-EY) 的平均值大于零。</p><p>然后，再来看 X 和 Y 负相关的情况：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-85f9087cf9fbcd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中，X 和 Y 大部分分布在 II、IV 区域内，只有少部分分布在 I、III 区域内。</p><p>同样，在区域 I、III 中，(X-EX)(Y-EY)&gt;0；在区域 II、IV 中，(X-EX)(Y-EY)&lt;0。而 X 和 Y 负相关时，数据大部分是分布在 II、IV 区域内，只有少部分分布在 I、III 区域。因此，从平均角度来看，负相关满足：</p><p>$E(X-EX)(Y-EY)&lt;0$</p><p>上式表示的是 (X-EX)(Y-EY) 的期望小于零，即 (X-EX)(Y-EY) 的平均值小于零。</p><p>最后，再来看 X 和 Y 不相关的情况：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-783fd5ff0bdbf5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中，X 和 Y 在 I、II、III、IV 区域内近似均匀分布。</p><p>同样，在区域 I、III 中，(X-EX)(Y-EY)&gt;0；在区域 II、IV 中，(X-EX)(Y-EY)&lt;0。而 X 和 Y 不相关时，数据在各区域内均匀分布，从平均角度来看，不相关满足：</p><p>$E(X-EX)(Y-EY)=0$</p><p>上式表示的是 (X-EX)(Y-EY) 的期望等于零，即 (X-EX)(Y-EY) 的平均值等于零。</p><p>综上所述，我们得到以下结论：</p><ul><li>当 X 和 Y 正相关时：$E(X-EX)(Y-EY)&gt;0$</li><li>当 X 和 Y 负相关时： $E(X-EX)(Y-EY)&lt;0$</li><li>当 X 和 Y 不相关时： $E(X-EX)(Y-EY)=0$</li></ul><p>因此，我们就引出了<strong>协方差</strong>的概念，它是表示 X 和 Y 之间相互关系的数字特征。我们定义协方差为： </p><p>$Cov(X,Y)=E(X-EX)(Y-EY)$</p><p>根据之前讨论的结果，</p><ul><li><strong>当 Cov(X,Y) &gt; 0 时，X 与 Y 正相关；</strong></li><li><strong>当 Cov(X,Y) &lt; 0 时，X 与 Y 负相关；</strong></li><li><strong>当 Cov(X,Y) = 0 时，X 与 Y 不相关。</strong></li></ul><p>值得一提的是，<strong>E</strong> 代表求期望值。也可以用平均值来计算协方差：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e5737a0988684364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里，<strong>之所以除以 N-1 而不是 N 的原因是对总体样本期望的无偏估计</strong>(抽取的部分样本不能代表整体的情况，抽样越多越接近真实情况  ，在多次重复下，它们的平均数接近所估计的参数真值。 )。顺便提一下，如果令 Y = X，则协方差表示的正是 X 的方差。</p><p>下面，我们根据协方差的公式，分别计算上面三种情况下 X 与 Y 的协方差。</p><p>X 与 Y 正相关时，Cov(X,Y) = 37.3684；</p><p>X 与 Y 负相关时，Cov(X,Y) = -34.0789；</p><p>X 与 Y 不相关时，Cov(X,Y) = -1.0263。</p><p><strong>2、相关系数与协方差有什么关系？</strong></p><p>我们已经知道了什么是协方差以及协方差公式是怎么来的，如果知道两个变量 X 与 Y 的协方差与零的关系，我们就能推断出 X 与 Y 是正相关、负相关还是不相关。那么有一个问题：协方差数值大小是否代表了相关程度呢？也就是说如果协方差为 100 是否一定比协方差为 10 的正相关性强呢？</p><p>请看下面这个例子！</p><p>变量 X1 与 Y1 分别为：</p><p>X1 = [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]</p><p>Y1 = [12 12 13 15 16 16 17 19 21 22 22 23 23 26 25 28 29 29 31 32]</p><p>变量 X2 和 Y2 分别为：</p><p>X2 = [110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300]</p><p>Y2 = [113 172 202 206 180 184 242 180 256 209 288 255 240 278 319 322 345 289 333 372]</p><p>X1、Y1 和 X2、Y2 分别联合分布图，如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-20451d31c197597e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>显然，从图中可以看出，X1、Y1 和 X2、Y2 都呈正相关，而且 X1 与 Y1 正相关的程度明显比 X2 与 Y2 更大一些。接下来，我们计算两幅图的协方差看看是不是这样。</p><p>Cov(X1,Y1) = 37.5526</p><p>Cov(X2,Y2) = 3730.26</p><p>意外！X2 与 Y2 的协方差竟然比 X1 与 Y1 的协方差还大 100 倍。看来并不是协方差越大，正相关程度越高。这到底是为什么呢？</p><p>其实，出现这种情况的原因是<strong>两种情况数值变化的幅值不同（或者量纲不同）</strong>。计算协方差的时候我们并没有把不同变量幅值差异性考虑进来，在比较协方差的时候也就<strong>没有一个统一的量纲标准</strong>。</p><p>所以，为了消除这一影响，为了准确得到变量之间的相似程度，我们需要把协方差除以各自变量的标准差。这样就得到了<strong>相关系数</strong>的表达式：</p><p> $\rho=\frac{Cov(X,Y)}{\sigma X\sigma Y}$</p><p>可见，相关系数就是在协方差的基础上除以变量 X 和 Y 的标准差。其中标准差的计算公式为： </p><p>$\sigma X = \sqrt{\frac{1}{N-1}\sum^{N}<em>{i=1}(X</em>{i}-\overline{X_{i}})}$</p><p>$\sigma Y = \sqrt{\frac{1}{N-1}\sum^{N}<em>{i=1}(Y</em>{i}-\overline{Y_{i}})}$</p><p>​    为什么除以各自变量的标准差就能消除幅值影响呢？这是因为<strong>标准差本身反映了变量的幅值变化程度</strong>，<strong>除以标准差正好能起到抵消的作用，让协方差标准化</strong>。这样，相关系数的范围就被归一化到 [-1,1] 之间了。</p><p>下面，我们就来分别计算上面这个例子中 X1、Y1 和 X2、Y2 的相关系数。</p><p>ρ(X1,Y1) = 0.9939</p><p>ρ(X2,Y2) = 0.9180</p><p>好了，我们得到 X1 与 Y1 的相关系数大于 X2 与 Y2 的相关系数。这符合实际情况。也就是说，根据相关系数，我们就能判定两个变量的相关程度，得到以下结论：</p><ul><li><strong>相关系数大于零，则表示两个变量正相关，且相关系数越大，正相关性越高；</strong></li><li><strong>相关系数小于零，则表示两个变量负相关，且相关系数越小，负相关性越高；</strong></li><li><strong>相关系数等于零，则表示两个变量不相关。</strong></li></ul><p>​    回过头来看一下协方差与相关系数的关系，其实，<strong>相关系数是协方差的标准化、归一化形式，消除了量纲、幅值变化不一的影响</strong>。实际应用中，在比较不同变量之间相关性时，使用相关系数更为科学和准确。但是协方差在机器学习的很多领域都有应用，而且非常重要！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是协方差（Covariance）？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是某百科的解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、协方差是怎么来的？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="协方差" scheme="http://yoursite.com/tags/%E5%8D%8F%E6%96%B9%E5%B7%AE/"/>
    
      <category term="相关系数" scheme="http://yoursite.com/tags/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>DeepIOT神经网络压缩</title>
    <link href="http://yoursite.com/2018/08/24/DeepIOT%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2018/08/24/DeepIOT神经网络压缩/</id>
    <published>2018-08-24T10:48:33.000Z</published>
    <updated>2018-08-27T12:01:06.884Z</updated>
    
    <content type="html"><![CDATA[<!-- DeepIoT: Compressing Deep Neural Network Structures for Sensing Systems with a Compressor-Critic FrameworkShuochao YaoUniversity of Illinois Urbana ChampaignYiran ZhaoUniversity of Illinois Urbana ChampaignAston ZhangUniversity of Illinois Urbana ChampaignLu SuState University of New York at BualoTarek AbdelzaherUniversity of Illinois Urbana Champaign --><p>​    物联网在我们的日常感知场景中越来越受欢迎，有很多应用，比如智能家居/城市，在我们的日常生活中有大量的嵌入式/移动设备，下一个自然的步骤是构建能够集体学习的智能感知系统 。另一方面，DL最近在复杂的传感和识别任务上取得了很大进展 。</p><p>​    然而,挑战仍然存在,当我们部署先进的dl模型在低端很多设备参考这个数字从一篇分析先进的图像识别cnn模型,这些模型通常需要大约10 Giga-operations和100 mb的大小会导致记忆的问题,时间,能量消耗物联网设备上部署这些模型时。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/12654931-1133a30c19324047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    深度学习的最新进展激发了在传感应用中使用深度中立网络的动力，但是在<strong>受限的嵌入式设备</strong>上的<strong>过度的资源需求</strong>仍然是一个重要的障碍。最近探索的解决方案空间是在设备使用前，以某种方式<strong>压缩(近似或简化)深层神经网络</strong>。一种新的<strong>压缩解决方案</strong>，叫做<strong>DeepIoT</strong>，它在这个空间中做出了两个关键的贡献。</p><ul><li><p>首先，与目前针对压缩特殊性型神经网络的解决方案不同的是，DeepIoT提出了一种统一普适的方法，它<strong>压缩了所有常用的用于传感应用的深度学习结构</strong>，包括完<strong>全连接的、卷积的和递归的神经网络</strong>，<strong>以及它们的组合</strong>。</p></li><li><p>其次，与<strong>稀疏加权矩阵</strong>或<strong>假定加权矩阵内的线性结构</strong>的解决方案不同，DeepIoT通过<strong>寻找最少数量的非冗余隐藏元素（例如每层所需的滤波器和维度</strong>）<strong>将神经网络结构压缩为更小的密集矩阵</strong>，<strong>同时保留传感应用的性能相同</strong>。即不降低准确率。重要的是，它使用一种方法来<strong>获得参数冗余的全局视图</strong>，该方法被证明可以产生更好的压缩。</p></li></ul><p>由DeepIoT生成的压缩模型可以直接使用现有的深度学习库，这些库在嵌入式和移动系统上运行，无需进一步的修改。结果表明了<strong>深度神经网络在资源受限的嵌入式设备上的开发潜力</strong>。</p><p><strong>一、已有方法介绍</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-4eb2b88e8d6697fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    <strong>1、大密度参数矩阵——&gt;稀疏矩阵</strong></p><p>​    有研究试图解决这个问题，现有的最先进的压缩算法是一种基于量级的修剪方法如上所示，该算法查看权重矩阵，并迭代地删除小于3列的实体。最终，它将把这个大而密集的矩阵转换成一个大而稀疏的矩阵。通常这种方法只能将参数的数量减少到10个。</p><ul><li><strong>基于幅值</strong></li></ul><p>1、<strong>基于幅度的fine-tuning压缩方法</strong>。</p><p>​    该方法是<strong>迭代地去除低幅度的重量连接</strong>;然而，它<strong>需要更多的资源消耗实现稀疏矩阵</strong>。</p><p>2、<strong>剪枝</strong></p><p>​    积极的修剪方法增加了不可挽回的网络损害的潜在风险。虽然有一种连接拼接的压缩算法，为一定的阈值提供了恢复的机会然而，该算法仍然侧重于权重水平而不是结构水平。</p><ul><li><strong>基于因子分解</strong></li></ul><p>  除了基于幅度的方法之外，另一系列作品着重于基于因子分解的方法，其通过<strong>利用参数中的低秩结构来降低神经网络的复杂性</strong>。 </p><p>3、利用各种<strong>矩阵分解</strong>方法和fine-tunning近似卷积运算，以减少神经网络的执行时间。 </p><p>4、应用<strong>稀疏编码</strong>和基于矩阵分解的方法分别降低全连接层和卷积层的复杂度。</p><p>​    主要原因是稀疏矩阵实现效率低。一方面，<strong>稀疏矩阵需要记录</strong>，这导致了2倍的内存消耗。另一方面，<strong>稀疏矩阵相乘很难优化</strong> 。</p><p>​    然而，基于分解的方法与基于量值的方法相比通常获得较低的压缩比，并且低等级假设可能损害最终网络性能。 </p><p>5、应用<strong>频域信息</strong>进行模型压缩。然而，需要额外的实现来加速频域表示，并且该方法不适用于具有小卷积滤波器大小的现代CNN。 </p><p>6、Hinton等人提出了一个<strong>teacher-student框架</strong>，将整个模型中的知识提炼成一个模型。然而，框架更侧重于将模型集合压缩为单一模型而不是结构压缩。</p><p><strong>二、系统介绍</strong></p><p>​    DeepIoT通过<strong>决定每层中最小元素的数量来压缩常用的深度神经网络结构以用于传感应用</strong>。 先前关于神经网络压缩的照明研究使疏密密集将参数矩阵转换为大型稀疏矩阵。 相比之下，<strong>DeepIoT最大限度地减少了每层中的元素数量，从而将参数转化为一组小密集矩阵</strong>。<strong>小密集矩阵不需要为元素索引额外存储</strong>，并且对处理进行了有效优化。</p><p>​    DeepIoT借用了广泛使用的被称为<strong>Dropout</strong>的<strong>深度学习正则化方法隐藏元素</strong>的想法。 <strong>Dropout操作给每个隐藏元素一个Dropout概率</strong>。 在<strong>dropout过程</strong>中，<strong>隐藏元素可根据其dropout概率进行修剪</strong>。 可以生成“<strong>细化</strong>”的网络结构。 但是，这些dropout概率通常设置为预定义值，例如0.5。 这种预定义的值不是最优的概率，从而导致对解空间的有效探索较少。如果我们能够<strong>获得每个隐藏元素的最优dropout概率</strong>，那么我们就有可能<strong>生成 最优的薄网络结构，在保留了传感应用的精度，同时最大限度地降低了传感系统的资源消耗</strong>。DeepIoT的一个重要目的是<strong>为神经网络中的每个隐藏元素找到最优的dropout概率</strong>。</p><p>​    注意，Dropout可以很容易地应用于所有常用的神经网络结构。</p><p>​    1、在<strong>全连接的神经网络</strong>中，神经元在每一<strong>层</strong>都被丢弃;</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-b911647b450f5464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>直接删除隐藏的元素/神经元，而不是权重</strong>。最后，我们将一个大的稠密权矩阵转化为一个细网络结构的小密度权矩阵。因此，我们可以绕过稀疏矩阵的表示 .</p><p><strong>一开始没有最优压缩决策，所以前期是计算梯度变化，抑制dropout概率，并逐渐压缩，而不是直接删除。</strong></p><p>​    2、在<strong>卷积神经网络</strong>中，<strong>卷积核</strong>被丢弃在每一层;<br><img src="https://upload-images.jianshu.io/upload_images/12654931-20ce37c77a5f48ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    对于CNN的每一层，都有一组卷积核来学习输入图像的特征。DeepIoT尝试删除冗余卷积核，以减少CNN层的卷积核数量。 </p><p>​    3、并且在<strong>递归神经网络</strong>中，减小每层的<strong>维度</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0bed97057f74ccdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于RNN层，DeepIoT直接降低了RNN的维度，用于模型压缩。 </p><p>​    意味着<strong>DeepIoT可以应用于所有常用的神经网络结构及其组合</strong>。</p><p>​    DeepIoT的贡献在于<strong>利用新颖的压缩器神经网络将每个层的模型参数作为输入，学习参数冗余，并相应地生成Dropout概率</strong>。<strong>由于不同层之间存在参数互联，因此我们设计压缩神经网络作为递归神经网络，能够全局共享冗余信息并逐层生成dropout概率</strong>。</p><p><strong>压缩机神经网络</strong>与原神经网络<strong>协同优化</strong>，通过<strong>compressor-critic框架</strong>进行压缩，<strong>尽量减小原始传感应用程序的损失功能</strong>。actor-critic框架模拟了著名的基于增强学习的actor-critic算法的思想，以<strong>迭代的方式</strong>优化了两个网络。</p><p>评估实验。</p><p>1、首先由三个任务组成，这三个任务使嵌入式系统能够以基本模式（包括<strong>手写文本</strong>，<strong>视觉</strong>和<strong>语音</strong>）与人类进行交互，与其他类似尺寸的神经网络相比，我们生成的神经网络具有更高的准确性。</p><p>2、第二组提供了两个应用压缩神经网络来解决<strong>以人为中心的情境感知任务</strong>的例子;即资源受限情景中的<strong>人类活动识别</strong>和<strong>用户识别</strong>。</p><p>DeepIOT特性：</p><ul><li>由于压缩过程是迭代进行的，<strong>必须具有恢复能力</strong>以提高最终性能。</li><li>以前的方法主要依赖于一些特定的压缩度量，我们希望DeepIoT<strong>基于参数冗余进行压缩</strong>。</li><li>深度神经网络是一种深层结构，因此深度神经网络应该具有<strong>全局性</strong>，<strong>必须了解全局冗余度</strong>。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12654931-30483f2f5494237f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图我们使用一个压缩3层全连接神经网络结构的例子来说明DeepIoT的整个流程。 （绿色方框表示原始神经网络的参数。橙色代表dropout操作）所示。使用DeepIoT压缩传感应用的神经网络结构的基本步骤可概括如下：</p><p>（1）   <strong>插入操作</strong>。将概率$p^{(l)}$随机置零的隐藏元素(图1中的红色方框)插入到原始神经网络的内部层中。  </p><p>（2）   <strong>构建压缩神经网络</strong>。它将图层中的<strong>原始神经网络权重矩阵$W^{l}​$ </strong>（图1中的绿框）<strong>作为输入进行压缩</strong>，<strong>在不同层之间学习和共享参数冗余，并生成最优dropout概率$p^{(l)}​$</strong>，<strong>然后送回到原始神经网络中的dropout操作</strong>。</p><p>（3）  用<strong>compressor-critic框架对压缩神经网络和原始神经网络进行</strong>迭代优化<strong>。 </strong>对压缩神经网络进行迭代优化，使其产生更好的退出概率，从而为原神经网络生成更有效的网络结构。 </p><p>​    </p><p>​    <strong><em>学习参数冗余 </em></strong>（橙色）<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3a5db6cbaa29bc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    基于参数冗余的DeepIOT。在理想的情况下，DeepIoT可以学习一个带参数的最优压缩机$\mu$，函数从神经网络中获取权重矩阵W。学习参数冗余，并生成可用于压缩的隐藏神经元的最优Dropout概率 。</p><p>​    <strong><em>参数冗余的全局视图</em></strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-59f84a197fb5b9a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    但我们如何设计这个最优压缩函数与参数冗余的全局视图。我们知道深神经网络本身就是完美函数逼近器。只要有足够的容量，它就可以逼近所有已有的连续函数。因此，我们将<strong>压缩函数设计成一种递归神经网络。</strong>它<strong>从原始神经网络中逐层提取权重矩阵，了解全局冗余信息，生成压缩dropout概率</strong>。这里我们称压缩函数、压缩器和要压缩的原始神经网络为“critic”，因为critic向压缩器提供反馈，让它知道根据“监督”得出的dropout概率是好是坏 。</p><p><strong>Compressor-Critic Framework</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-53bd25e684eb5f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    DeepIoT的目标函数是根据compressor学习到的损失概率来学习压缩模型的期望损失。我们反复训练，这意味着当训练compressor时，我们把所有的东西都固定在critic，反之亦然 。</p><p>​    对原神经网络和压缩神经网络进行迭代优化，使压缩神经网络以<strong>软删除</strong>的方式逐渐压缩原神经网络。 </p><p>​    我们把最初的神经网络称为$F_{W}(x|z)$，我们称之为Critic。它将x作为输入，并基于二进制dropout 记为Z和模型参数w生成预测，这些参数w指的是一组权重$W=w^{(l)}$。 。我们假设$F_{W}(x|z)$是一个预先训练好的模型。$z~\mu_{\phi}(W)$表示压缩神经网络。它将Critic的权重作为输入，并根据其自身参数生成mask向量Z的概率分布。为了优化压缩器，使其在Critic中去掉隐藏元素，DeepIoT遵循了上图的目标函数。</p><p>​    其中$l$是Critic的目标函数。目标函数可以解释为原始神经网络的期望损失乘以压缩机产生的dropout概率。</p><p>​    DeeploT以迭代的方式优化Compressor和Critic。通过对Compressor采用梯度下降法，迭代求解，降低了目标函数中定义的期望损失。如何去做？由于存在<strong>离散采样操作</strong>，在计算图中，反向传播不直接适用。因此，我们使用<strong>无偏似然比估计量</strong>来计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- DeepIoT: Compressing Deep Neural Network Structures for Sensing Systems with a Compressor-Critic Framework

Shuochao Yao
University of Illinois Urbana Champaign
Yiran Zhao
University of Illinois Urbana Champaign
Aston Zhang
University of Illinois Urbana Champaign
Lu Su
State University of New York at Bualo
Tarek Abdelzaher
University of Illinois Urbana Champaign
 --&gt;
&lt;p&gt;​    物联网在我们的日常感知场景中越来越受欢迎，有很多应用，比如智能家居/城市，在我们的日常生活中有大量的嵌入式/移动设备，下一个自然的步骤是构建能够集体学习的智能感知系统 。另一方面，DL最近在复杂的传感和识别任务上取得了很大进展 。&lt;/p&gt;
&lt;p&gt;​    然而,挑战仍然存在,当我们部署先进的dl模型在低端很多设备参考这个数字从一篇分析先进的图像识别cnn模型,这些模型通常需要大约10 Giga-operations和100 mb的大小会导致记忆的问题,时间,能量消耗物联网设备上部署这些模型时。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="神经网络压缩" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>HAN</title>
    <link href="http://yoursite.com/2018/08/24/HAN/"/>
    <id>http://yoursite.com/2018/08/24/HAN/</id>
    <published>2018-08-24T08:03:04.000Z</published>
    <updated>2018-08-24T09:33:30.288Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文：</strong>Hierarchical Attention Networks for Document Classification</p><p><strong>发表会议：*</strong>NAACL2016*</p><p><strong>前言：</strong>本文针对文本分类任务提出了一个层次化attention机制模型(<strong>HAN</strong>)，有两个显著的特点：(1)采用“词-句子-文章”的层次化结构来表示一篇文本。(2)该模型有两个层次的attention机制，分别存在于词层次(word level)和句子层次(sentence level)。从而使该模型具有对文本中重要性不同的句子和词的能力给予不同“注意力”的能力。作者在6个数据集合上进行了测试，并且相较以往的模型效果提升显著。最后，通过可视化说明该模型可以选择出含有丰富信息的词语和句子。 </p><a id="more"></a><p><strong>一 、写作动机</strong></p><p>​    文本分类是一项基础的NLP任务，在主题分类，情感分析，垃圾邮件检测等应用上有广泛地应用。其目标是给每篇文本分配一个类别标签。本文中模型的直觉是，不同的词和句子对文本信息的表达有不同的影响，词和句子的重要性是严重依赖于上下文的，即使是相同的词和句子，在不同的上下文中重要性也不一样。就像人在阅读一篇文本时，对文本不同的内容是有着不同的注意度的。而本文在attention机制的基础上，联想到文本是一个层次化的结构，提出用词向量来表示句子向量，再由句子向量表示文档向量，并且在词层次和句子层次分别引入attention操作的模型。</p><p>​    分层构建只不过加上了两个Attention层，用于分别对句子和文档中的单词、句子的重要性进行建模。其主要思想是，首先考虑文档的分层结构：单词构成句子，句子构成文档，所以建模时也分这两部分进行。其次，不同的单词和句子具有不同的信息量，不能单纯的统一对待所以引入Attention机制。而且引入Attention机制除了提高模型的精确度之外还可以进行单词、句子重要性的分析和可视化，让我们对文本分类的内部有一定了解。模型主要可以分为下面四个部分，如下图所示：</p><ol><li>a word sequence encoder,</li><li>a word-level attention layer,</li><li>a sentence encoder</li><li>a sentence-level attention layer.<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4eff2296d8389ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p>这里对Attention机制进行一个补充介绍，可以参考论文“FEED-FORWARD NETWORKS WITH ATTENTION CAN SOLVE SOME LONG -TERM MEMORY PROBLEMS”里面的插图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-0feab3f9a475bb34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>1. 基于GRU的词序列编码器</strong></p><p>GRU是RNN的一个变种，使用门机制来记录序列当前的状态。隐藏层有两个门(gate)，重置门(reset gate)rt和更新门(update gate)!zt。这两个门一起来控制当前状态有多少信息要更新。在时刻t，隐藏层状态的计算公式：</p><p> $h_{t} =(1-z_{t})\odot h_{t-1} +z_{t}\odot  \tilde{h_t }$</p><p>更新门(update gate)zt是用来决定有多少过去的信息被保留，以及有多少新信息被加进来：</p><p> $z_{t} =\sigma (W_{z}x_{t} +U_{z}h_{t-1} +b_{z}  )$</p><p>这里xt是在时刻t输入的单词的词向量，候选状态ht~的计算方法和普通的RNN相似： </p><p>$\tilde{h_{t} }=tanh(W_{h}x_{t}+r_{t}\odot (U_{h}h_{t-1}  ) +b_{h}   ) $</p><p>重置门rt决定有多少过去的信息作用于候选状态，如果rt是0，即忘记之前的所有状态： </p><p>$r_{t}=\sigma(W_{r}x_{t}+U_{r}h_{t-1}+b_{r} )$</p><p><strong>2 层次化attention</strong></p><p><strong>2.1 词编码器（Word Encoder）</strong></p><p>由词序列组成$w_{it}$,$t\in [0,T]$组成的句子,首先把词转化成词向量，$x_{it}=W_{e}w_{it}$,然后用双向的GRU网络,可以将正向和反向的上下文信息结合起来，获得隐藏层输出。</p><p>$x_{it}=W_{e}w_{it},t\in[1,T]$</p><p> $\overrightarrow{h_{it}}=\overrightarrow{GRU}({x_{it}})$</p><p>$\overleftarrow{h_{it}}=\overleftarrow{GRU}({x_{it}})$</p><p>对于一个给定的词语$w_{it}$,经过GRU网络后，我们获得了一种新的表示：$h_{it}=[\overrightarrow{h_{it}},\overleftarrow{h_{it}}]$</p><p>$h_{it}$包含了$w_{it}$周围两个方向的信息。</p><p><strong>2.2 词级别的attention机制</strong></p><p>attention机制的目的是要把一个句子中，对句子的含义最重要，贡献最大的词语找出来。我们通过将$h_{it}$输入到一个单层的感知机(MLP)中得到的结果$u_{it}$作为$h_{it}$的隐含表示。</p><p> $u_{it}=tanh(W_{w}h_{it}+b_{w})$</p><p>为了衡量单词的重要性,我们用$u_{it}$和一个随机初始化的上下文向量$u_{w}$的相似度来表示，然后经过softmax操作获得了一个归一化的attention权重矩阵$\alpha _{it}$，代表句子i中第t个词的权重。</p><p> $\alpha_{i}=\frac{exp\left( u_{i}^\top u_{s} \right) }{\sum_{t}^{}{exp\left( u_{t}^\top u_{s} \right) } } $</p><p>有了attention权重矩阵以后，我们可以将句子向量$s_{i}$看作组成这些句子的词向量的加权求和。这里的上下文向量$u_{w}$是在训练网络的过程中学习获得的。我们可以把$u_{w}$当作一种询问的高级表示，比如“哪些词含有比较重要的信息？”</p><p>$s_{i}=\sum_{t}{\alpha_{it}h_{it}} $</p><p><strong>2.3 语句编码器(Sentence Encoder)</strong></p><p>得到了句子向量表示$s_{i}$以后，我们用类似的办法获得文档向量：</p><p>  $\overrightarrow{h_{i}}=\overrightarrow{GRU}(s_{i}),i\in[1,L]$</p><p> $\overleftarrow{h_{i}}=\overleftarrow{GRU}(s_{i}),i\in[L,1]$</p><p>对于给定的句子$s_{i}$我们得到了相应的句子表示$h_{i}=[\overrightarrow{h_{i}},\overleftarrow{h_{i}}]$。这样获得的表示可以包含两个方向的上下文信息。</p><p><strong>2.4 句子级别的attention</strong></p><p>和词级别的attention类似，我们也提出了一个句子级别的上下文向量$u_{s}$,来衡量一个句子在整篇文本的重要性。</p><p>$u_{i}=tanh(W_{s}h_{i}+b_{s})$</p><p> $\alpha_{i}=\frac{exp\left( u_{i}^\top u_{s} \right) }{\sum_{t}^{}{exp\left( u_{t}^\top u_{s} \right) } } $</p><p> $v=\sum_{i}{\alpha_{i}h_{i}}$</p><p>我们获得了整篇文章的向量表示v,最后可以使用全链接的softmax层进行分类。 </p><p><strong>总结</strong></p><p>​    本文提出了一种基于层次化attention的文本分类模型，可以利用attention机制识别出一句话中比较重要的词语，利用重要的词语形成句子的表示，同样识别出重要的句子，利用重要句子表示来形成整篇文本的表示。实验证明，该模型确实比基准模型获得了更好的效果，可视化分析也表明，该模型能很好地识别出重要的句子和词语。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;论文：&lt;/strong&gt;Hierarchical Attention Networks for Document Classification&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发表会议：*&lt;/strong&gt;NAACL2016*&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;本文针对文本分类任务提出了一个层次化attention机制模型(&lt;strong&gt;HAN&lt;/strong&gt;)，有两个显著的特点：(1)采用“词-句子-文章”的层次化结构来表示一篇文本。(2)该模型有两个层次的attention机制，分别存在于词层次(word level)和句子层次(sentence level)。从而使该模型具有对文本中重要性不同的句子和词的能力给予不同“注意力”的能力。作者在6个数据集合上进行了测试，并且相较以往的模型效果提升显著。最后，通过可视化说明该模型可以选择出含有丰富信息的词语和句子。 &lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Attention" scheme="http://yoursite.com/tags/Attention/"/>
    
      <category term="Hierarchical Attention Networks" scheme="http://yoursite.com/tags/Hierarchical-Attention-Networks/"/>
    
  </entry>
  
  <entry>
    <title>深度学习中Attention注意力机制</title>
    <link href="http://yoursite.com/2018/08/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADAttention%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/24/深度学习中Attention注意力机制/</id>
    <published>2018-08-24T04:55:45.000Z</published>
    <updated>2018-08-24T07:42:32.197Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近两年，注意力模型（Attention Model）被广泛使用在<strong>自然语言处理</strong>、<strong>图像识别</strong>及<strong>语音识别</strong>等各种不同类型的深度学习任务中，是深度学习技术中最值得关注与深入了解的核心技术之一。</p><p>​    本文以机器翻译为例，深入浅出地介绍了深度学习中注意力机制的原理及关键计算机制，同时也抽象出其本质思想，并介绍了注意力模型在图像及语音等领域的典型应用场景。</p><p>​    注意力模型最近几年在深度学习各个领域被广泛使用，无论是图像处理、语音识别还是自然语言处理的各种不同类型的任务中，都很容易遇到注意力模型的身影。所以，了解注意力机制的工作原理对于关注深度学习技术发展的技术人员来说有很大的必要。</p><a id="more"></a><p><strong>人类的视觉注意力</strong></p><p>​    从注意力模型的命名方式看，很明显其借鉴了人类的注意力机制，因此，我们首先简单介绍人类视觉的选择性注意力机制。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fb4da1bea0bf6c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图1 人类的视觉注意力 </p><p>​    视觉注意力机制是人类视觉所特有的大脑信号处理机制。人类视觉通过快速扫描全局图像，获得需要重点关注的目标区域，也就是一般所说的注意力焦点，而后对这一区域投入更多注意力资源，以获取更多所需要关注目标的细节信息，而抑制其他无用信息。</p><p>​    这是人类利用有限的注意力资源从大量信息中快速筛选出高价值信息的手段，是人类在长期进化中形成的一种生存机制，人类视觉注意力机制极大地提高了视觉信息处理的效率与准确性。</p><p>​    图1形象化展示了人类在看到一副图像时是如何高效分配有限的注意力资源的，其中红色区域表明视觉系统更关注的目标，很明显对于图1所示的场景，人们会把注意力更多投入到人的脸部，文本的标题以及文章首句等位置。</p><p>​    深度学习中的注意力机制从本质上讲和人类的选择性视觉注意力机制类似，核心目标也是从众多信息中选择出对当前任务目标更关键的信息。</p><p><strong>Encoder-Decoder框架</strong></p><p>​    要了解深度学习中的注意力模型，就不得不先谈Encoder-Decoder框架，因为目前大多数注意力模型附着在Encoder-Decoder框架下，当然，其实注意力模型可以看作一种通用的思想，本身并不依赖于特定框架，这点需要注意。</p><p>​    Encoder-Decoder框架可以看作是一种深度学习领域的研究模式，应用场景异常广泛。图2是文本处理领域里常用的Encoder-Decoder框架最抽象的一种表示。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-673d1e3c89384f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图2 抽象的文本处理领域的Encoder-Decoder框架</p><p>​    文本处理领域的Encoder-Decoder框架可以这么直观地去理解：可以把它看作适合处理由一个句子（或篇章）生成另外一个句子（或篇章）的通用处理模型。对于句子对&lt;Source,Target&gt;，我们的目标是给定输入句子Source，期待通过Encoder-Decoder框架来生成目标句子Target。Source和Target可以是同一种语言，也可以是两种不同的语言。而Source和Target分别由各自的单词序列构成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-b81ce17f917e41ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Encoder顾名思义就是对输入句子Source进行编码，将输入句子通过非线性变换转化为中间语义表示C： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-18ac98f85ce18c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于解码器Decoder来说，其任务是根据句子Source的中间语义表示C和之前已经生成的历史信息y1,y2,……,y i-1!来生成i时刻要生成的单词yi：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-07e7143d8889b113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    每个yi都依次这么产生，那么看起来就是整个系统根据输入句子Source生成了目标句子Target。如果Source是中文句子，Target是英文句子，那么这就是解决机器翻译问题的Encoder-Decoder框架；如果Source是一篇文章，Target是概括性的几句描述语句，那么这是文本摘要的Encoder-Decoder框架；如果Source是一句问句，Target是一句回答，那么这是问答系统或者对话机器人的Encoder-Decoder框架。由此可见，在文本处理领域，Encoder-Decoder的应用领域相当广泛。</p><p>​    Encoder-Decoder框架不仅仅在文本领域广泛使用，在语音识别、图像处理等领域也经常使用。比如对于语音识别来说，图2所示的框架完全适用，区别无非是Encoder部分的输入是语音流，输出是对应的文本信息；而对于“图像描述”任务来说，Encoder部分的输入是一副图片，Decoder的输出是能够描述图片语义内容的一句描述语。一般而言，文本处理和语音识别的Encoder部分通常采用RNN模型，图像处理的Encoder一般采用CNN模型。</p><p><strong>Attention模型</strong></p><p>​    本节先以机器翻译作为例子讲解最常见的Soft Attention模型的基本原理，之后抛离Encoder-Decoder框架抽象出了注意力机制的本质思想，然后简单介绍最近广为使用的Self Attention的基本思路。</p><p><strong>Soft Attention模型</strong></p><p>​    图2中展示的Encoder-Decoder框架是没有体现出“注意力模型”的，所以可以把它看作是注意力不集中的分心模型。为什么说它注意力不集中呢？请观察下目标句子Target中每个单词的生成过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4a14bb2ebaae352b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中f是Decoder的非线性变换函数。从这里可以看出，在生成目标句子的单词时，不论生成哪个单词，它们使用的输入句子Source的语义编码C都是一样的，没有任何区别。</p><p>​    而语义编码C是由句子Source的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词y1,y2还是y3，其实句子Source中任意单词对生成某个目标单词yi来说影响力都是相同的，这是为何说这个模型没有体现出注意力的缘由。这类似于人类看到眼前的画面，但是眼中却没有注意焦点一样。</p><p>​    如果拿机器翻译来解释这个分心模型的Encoder-Decoder框架更好理解，比如输入的是英文句子：Tom chase Jerry，Encoder-Decoder框架逐步生成中文单词：“汤姆”，“追逐”，“杰瑞”。</p><p>​    在翻译“杰瑞”这个中文单词的时候，分心模型里面的每个英文单词对于翻译目标单词“杰瑞”贡献是相同的，很明显这里不太合理，显然“Jerry”对于翻译成“杰瑞”更重要，但是分心模型是无法体现这一点的，这就是为何说它没有引入注意力的原因。</p><p>​    没有引入注意力的模型在输入句子比较短的时候问题不大，但是如果输入句子比较长，此时所有语义完全通过一个中间语义向量来表示，单词自身的信息已经消失，可想而知会丢失很多细节信息，这也是为何要引入注意力模型的重要原因。</p><p>​    上面的例子中，如果引入Attention模型的话，应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：</p><p>（Tom,0.3）(Chase,0.2) (Jerry,0.5)</p><p>​    每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。</p><p>​    同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词yi的时候，原先都是相同的中间语义表示C会被替换成根据当前生成单词而不断变化的Ci。理解Attention模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的Ci。增加了注意力模型的Encoder-Decoder框架理解起来如图3所示。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-87bc6ecb6c37d755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图3 引入注意力模型的Encoder-Decoder框架</p><p>即生成目标句子单词的过程成了下面的形式：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-758accd42659461c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    而每个Ci可能对应着不同的源语句子单词的注意力分配概率分布，比如对于上面的英汉翻译来说，其对应的信息可能如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-22d97a1a2eb5c5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中，f2函数代表Encoder对输入英文单词的某种变换函数，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入Xi后隐层节点的状态值；g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般的做法中，g函数就是对构成元素加权求和，即下列公式： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-07cda8310b043204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中，Lx代表输入句子Source的长度，aij代表在Target输出第i个单词时Source输入句子中第j个单词的注意力分配系数，而hj则是Source输入句子中第j个单词的语义编码。假设Ci下标i就是上面例子所说的“ 汤姆” ，那么Lx就是3，h1=f(“Tom”)，h2=f(“Chase”),h3=f(“Jerry”)分别是输入句子每个单词的语义编码，对应的注意力模型权值则分别是0.6,0.2,0.2，所以g函数本质上就是个加权求和函数。如果形象表示的话，翻译中文单词“汤姆”的时候，数学公式对应的中间语义表示Ci的形成过程类似图4。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b7b36d1a95dd63e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    这里还有一个问题：生成目标句子某个单词，比如“汤姆”的时候，如何知道Attention模型所需要的输入句子单词注意力分配概率分布值呢？就是说“汤姆”对应的输入句子Source中各个单词的概率分布：(Tom,0.6)(Chase,0.2) (Jerry,0.2) 是如何得到的呢？</p><p>​    为了便于说明，我们假设对图2的非Attention模型的Encoder-Decoder框架进行细化，Encoder采用RNN模型，Decoder也采用RNN模型，这是比较常见的一种模型配置，则图2的框架转换为图5。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-9dad02d0e28ad036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图5 RNN作为具体模型的Encoder-Decoder框架</p><p>那么用图6可以较为便捷地说明注意力分配概率分布值的通用计算过程。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-443c9b6cca038058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    图6 注意力分配概率计算</p><p>​    对于采用RNN的Decoder来说，在时刻i，如果要生成yi单词，我们是可以知道Target在生成yi之前的时刻i-1时，隐层节点i-1时刻的输出值Hi-1的，而我们的目的是要计算生成yj时输入句子中的单词“Tom”、“Chase”、“Jerry”对yi来说的注意力分配概率分布，那么可以用Target输出句子i-1时刻的隐层节点状态Hi-1去一一和输入句子Source中每个单词对应的RNN隐层节点状态hj进行对比，即通过函数F(hj,Hi-1)来获得目标单词yi和每个输入单词对应的对齐可能性，这个F函数在不同论文里可能会采取不同的方法，然后函数F的输出经过Softmax进行归一化就得到了符合概率分布取值区间的注意力分配概率分布数值。</p><p>​    绝大多数Attention模型都是采取上述的计算框架来计算注意力分配概率分布信息，区别只是在F的定义上可能有所不同。图7可视化地展示了在英语-德语翻译系统中加入Attention机制后，Source和Target两个句子每个单词对应的注意力分配概率分布。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-9f0d5e50c90d7165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图7 英语-德语翻译的注意力概率分布</p><p>上述内容就是经典的Soft Attention模型的基本思想，那么怎么理解Attention模型的物理含义呢？一般在自然语言处理应用里会把Attention模型看作是输出Target句子中某个单词和输入Source句子每个单词的对齐模型，这是非常有道理的。</p><p>​    目标句子生成的每个单词对应输入句子单词的概率分布可以理解为输入句子单词和这个目标生成单词的对齐概率，这在机器翻译语境下是非常直观的：传统的统计机器翻译一般在做的过程中会专门有一个短语对齐的</p><p>步骤，而注意力模型其实起的是相同的作用。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-181c0ac7d346c4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图8 Google 神经网络机器翻译系统结构图</p><p>​    图8所示即为Google于2016年部署到线上的基于神经网络的机器翻译系统，相对传统模型翻译效果有大幅提升，翻译错误率降低了60%，其架构就是上文所述的加上Attention机制的Encoder-Decoder框架，主要区别无非是其Encoder和Decoder使用了8层叠加的LSTM模型。</p><p><strong>Attention机制的本质思想</strong></p><p>​    如果把Attention机制从上文讲述例子中的Encoder-Decoder框架中剥离，并进一步做抽象，可以更容易看懂Attention机制的本质思想。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-59f1d669793d5f88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图9 Attention机制的本质思想</p><p>​    我们可以这样来看待Attention机制（参考图9）：将Source中的构成元素想象成是由一系列的&lt;Key,Value&gt;数据对构成，此时给定Target中的某个元素Query，通过计算Query和各个Key的相似性或者相关性，得到每个Key对应Value的权重系数，然后对Value进行加权求和，即得到了最终的Attention数值。所以本质上Attention机制是对Source中元素的Value值进行加权求和，而Query和Key用来计算对应Value的权重系数。即可以将其本质思想改写为如下公式：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-665dfe15e5428ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中，Lx=||Source||代表Source的长度，公式含义即如上所述。上文所举的机器翻译的例子里，因为在计算Attention的过程中，Source中的Key和Value合二为一，指向的是同一个东西，也即输入句子中每个单词对应的语义编码，所以可能不容易看出这种能够体现本质思想的结构。</p><p>​    当然，从概念上理解，把Attention仍然理解为从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略大多不重要的信息，这种思路仍然成立。聚焦的过程体现在权重系数的计算上，权重越大越聚焦于其对应的Value值上，即权重代表了信息的重要性，而Value是其对应的信息。</p><p>​    从图9可以引出另外一种理解，也可以将Attention机制看作一种软寻址（Soft Addressing）:Source可以看作存储器内存储的内容，元素由地址Key和值Value组成，当前有个Key=Query的查询，目的是取出存储器中对应的Value值，即Attention数值。通过Query和存储器内元素Key的地址进行相似性比较来寻址，之所以说是软寻址，指的不像一般寻址只从存储内容里面找出一条内容，而是可能从每个Key地址都会取出内容，取出内容的重要性根据Query和Key的相似性来决定，之后对Value进行加权求和，这样就可以取出最终的Value值，也即Attention值。所以不少研究人员将Attention机制看作软寻址的一种特例，这也是非常有道理的。</p><p>​    至于Attention机制的具体计算过程，如果对目前大多数方法进行抽象的话，可以将其归纳为两个过程：第一个过程是根据Query和Key计算权重系数，第二个过程根据权重系数对Value进行加权求和。而第一个过程又可以细分为两个阶段：第一个阶段根据Query和Key计算两者的相似性或者相关性；第二个阶段对第一阶段的原始分值进行归一化处理；这样，可以将Attention的计算过程抽象为如图10展示的三个阶段。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a4b0e1012e5bd916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图10 三阶段计算Attention过程</p><p>​    在第一个阶段，可以引入不同的函数和计算机制，根据Query和某个Keyi，计算两者的相似性或者相关性，最常见的方法包括：求两者的向量点积、求两者的向量Cosine相似性或者通过再引入额外的神经网络来求值，即如下方式：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c93d879ffaca8c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    第一阶段产生的分值根据具体产生的方法不同其数值取值范围也不一样，第二阶段引入类似SoftMax的计算方式对第一阶段的得分进行数值转换，一方面可以进行归一化，将原始计算分值整理成所有元素权重之和为1的概率分布；另一方面也可以通过SoftMax的内在机制更加突出重要元素的权重。即一般采用如下公式计算：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e0e5d2da5ca0ec70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    第二阶段的计算结果!ai即为Valuei对应的权重系数，然后进行加权求和即可得到Attention数值：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e99ce9f941c56f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    通过如上三个阶段的计算，即可求出针对Query的Attention数值，目前绝大多数具体的注意力机制计算方法都符合上述的三阶段抽象计算过程。 </p><p><strong>Self Attention模型</strong></p><p>​    通过上述对Attention本质思想的梳理，我们可以更容易理解本节介绍的Self Attention模型。Self Attention也经常被称为intra Attention（内部Attention），最近一年也获得了比较广泛的使用，比如Google最新的机器翻译模型内部大量采用了Self Attention模型。</p><p>​    在一般任务的Encoder-Decoder框架中，输入Source和输出Target内容是不一样的，比如对于英-中机器翻译来说，Source是英文句子，Target是对应的翻译出的中文句子，Attention机制发生在Target的元素Query和Source中的所有元素之间。而Self Attention顾名思义，指的不是Target和Source之间的Attention机制，而是Source内部元素之间或者Target内部元素之间发生的Attention机制，也可以理解为Target=Source这种特殊情况下的注意力计算机制。其具体计算过程是一样的，只是计算对象发生了变化而已，所以此处不再赘述其计算过程细节。</p><p>​    如果是常规的Target不等于Source情形下的注意力计算，其物理含义正如上文所讲，比如对于机器翻译来说，本质上是目标语单词和源语单词之间的一种单词对齐机制。那么如果是Self Attention机制，一个很自然的问题是：通过Self Attention到底学到了哪些规律或者抽取出了哪些特征呢？或者说引入Self Attention有什么增益或者好处呢？我们仍然以机器翻译中的Self Attention来说明，图11和图12是可视化地表示Self Attention在同一个英语句子内单词间产生的联系。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a3ec94c5bab0da8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图11 可视化Self Attention实例<br><img src="https://upload-images.jianshu.io/upload_images/12654931-c06b7b882ea54e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图12 可视化Self Attention实例</p><p>​    从两张图（图11、图12）可以看出，Self Attention可以捕获同一个句子中单词之间的一些句法特征（比如图11展示的有一定距离的短语结构）或者语义特征（比如图12展示的its的指代对象Law）。</p><p>​    很明显，引入Self Attention后会更容易捕获句子中长距离的相互依赖的特征，因为如果是RNN或者LSTM，需要依次序序列计算，对于远距离的相互依赖的特征，要经过若干时间步步骤的信息累积才能将两者联系起来，而距离越远，有效捕获的可能性越小。</p><p>​    但是Self Attention在计算过程中会直接将句子中任意两个单词的联系通过一个计算步骤直接联系起来，所以远距离依赖特征之间的距离被极大缩短，有利于有效地利用这些特征。除此外，Self Attention对于增加计算的并行性也有直接帮助作用。这是为何Self Attention逐渐被广泛使用的主要原因。</p><p><strong>Attention机制的应用</strong></p><p>​    前文有述，Attention机制在深度学习的各种应用领域都有广泛的使用场景。上文在介绍过程中我们主要以<strong>自然语言处理</strong>中的<strong>机器翻译</strong>任务作为例子，下面分别再从<strong>图像处理</strong>领域和<strong>语音识别</strong>选择典型应用实例来对其应用做简单说明。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f85fefd11ac30319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图13 图片-描述任务的Encoder-Decoder框架</p><p><strong>图片描述（Image-Caption）</strong>是一种典型的图文结合的深度学习应用，输入一张图片，人工智能系统输出一句描述句子，语义等价地描述图片所示内容。很明显这种应用场景也可以使用Encoder-Decoder框架来解决任务目标，此时Encoder输入部分是一张图片，一般会用CNN来对图片进行特征抽取，Decoder部分使用RNN或者LSTM来输出自然语言句子（参考图13）。</p><p>​    此时如果加入Attention机制能够明显改善系统输出效果，Attention模型在这里起到了类似人类视觉选择性注意的机制，在输出某个实体单词的时候会将注意力焦点聚焦在图片中相应的区域上。图14给出了根据给定图片生成句子“A person is standing on a beach with a surfboard.”过程时每个单词对应图片中的注意力聚焦区域。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f037cc39c3734b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图14 图片生成句子中每个单词时的注意力聚焦区域</p><p>​    图15给出了另外四个例子形象地展示了这种过程，每个例子上方左侧是输入的原图，下方句子是人工智能系统自动产生的描述语句，上方右侧图展示了当AI系统产生语句中划横线单词的时候，对应图片中聚焦的位置区域。比如当输出单词dog的时候，AI系统会将注意力更多地分配给图片中小狗对应的位置。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-171a7bb3b3837e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图15 图像描述任务中Attention机制的聚焦作用<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f7f34eccc3a8c2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>图16 语音识别中音频序列和输出字符之间的Attention</p><p>​    语音识别的任务目标是将语音流信号转换成文字，所以也是Encoder-Decoder的典型应用场景。Encoder部分的Source输入是语音流信号，Decoder部分输出语音对应的字符串流。</p><p>​    图16可视化地展示了在Encoder-Decoder框架中加入Attention机制后，当用户用语音说句子 how much would a woodchuck chuck 时，输入部分的声音特征信号和输出字符之间的注意力分配概率分布情况，颜色越深代表分配到的注意力概率越高。从图中可以看出，在这个场景下，Attention机制起到了将输出字符和输入语音信号进行对齐的功能。</p><p>​    上述内容仅仅选取了不同AI领域的几个典型Attention机制应用实例，Encoder-Decoder加Attention架构由于其卓越的实际效果，目前在深度学习领域里得到了广泛的使用，了解并熟练使用这一架构对于解决实际问题会有极大帮助。    </p><p><strong>目前主流attention主流方法</strong></p><ol><li><p>首先是Object Recognition。</p></li><li><p>然后是Image Caption。</p></li><li><p>NLP中的Machine Translation.</p></li><li><p>不使用RNN结构。在特征图上生成空间分布的权重，然后再对特征图加权求和，试图让网络学出来对不同物体区域加以不同关注度。</p></li><li><p>总结与泛化。划重点：attention机制听起来高达上，其实就是学出一个权重分布，再拿这个权重分布施加在原来的特征之上，就可以叫做attention。</p><p>简单来说：</p><p>（1）这个加权可以是保留所有分量均做加权（即soft attention）；也可以是在分布中以某种采样策略选取部分分量（即hard attention）。</p><p>（2）这个加权可以作用在原图上，也就是RAM和DRAM；也可以作用在特征图上，如后续的好多文章（例如image caption)。</p><p>（3）这个加权可以作用在空间尺度上，给不同空间区域加权；也可以作用在channel尺度上，给不同通道特征加权；甚至特征图上每个元素加权。</p><p>（4）这个加权还可以作用在不同时刻历史特征上，如Machine Translation，以及我前段时间做的视频相关的工作。</p><p>所以说，Attention是啥啊？就是一个权重分布！</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    最近两年，注意力模型（Attention Model）被广泛使用在&lt;strong&gt;自然语言处理&lt;/strong&gt;、&lt;strong&gt;图像识别&lt;/strong&gt;及&lt;strong&gt;语音识别&lt;/strong&gt;等各种不同类型的深度学习任务中，是深度学习技术中最值得关注与深入了解的核心技术之一。&lt;/p&gt;
&lt;p&gt;​    本文以机器翻译为例，深入浅出地介绍了深度学习中注意力机制的原理及关键计算机制，同时也抽象出其本质思想，并介绍了注意力模型在图像及语音等领域的典型应用场景。&lt;/p&gt;
&lt;p&gt;​    注意力模型最近几年在深度学习各个领域被广泛使用，无论是图像处理、语音识别还是自然语言处理的各种不同类型的任务中，都很容易遇到注意力模型的身影。所以，了解注意力机制的工作原理对于关注深度学习技术发展的技术人员来说有很大的必要。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Attention" scheme="http://yoursite.com/tags/Attention/"/>
    
      <category term="注意力机制" scheme="http://yoursite.com/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LSTM原理与实现</title>
    <link href="http://yoursite.com/2018/08/24/LSTM%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/08/24/LSTM原理与实现/</id>
    <published>2018-08-24T02:54:25.000Z</published>
    <updated>2018-08-24T04:56:23.188Z</updated>
    
    <content type="html"><![CDATA[<ul><li>[RNN]</li><li>[LSTM网络]</li><li>[LSTM核心思想]</li><li>[逐步理解LSTM]<ul><li>[遗忘门]</li><li>[输入门]</li><li>[输出门]</li></ul></li><li>[LSTM变体]</li><li>[多层LSTM]</li><li>LSTM实现手写数字<ul><li>[设置LSTM参数]</li><li>[初始化权值参数]</li></ul></li></ul><a id="more"></a> <h2 id="Recurrent-Neural-Networks"><a href="#Recurrent-Neural-Networks" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h2><p>​    人类并不是每时每刻都从一片空白的大脑开始他们的思考。在你阅读这篇文章时候，你都是基于自己已经拥有的对先前所见词的理解来推断当前词的真实含义。我们不会将所有的东西都全部丢弃，然后用空白的大脑进行思考。我们的思想拥有持久性。<br>    传统的神经网络并不能做到这点，看起来也像是一种巨大的弊端。例如，假设你希望对电影中的每个时间点的时间类型进行分类。传统的神经网络应该很难来处理这个问题——使用电影中先前的事件推断后续的事件。<br>    RNN 解决了这个问题。RNN 是包含循环的网络，允许信息的持久化。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-db35984a77cb0f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>RNN 包含循环</em></p><p>​    在上面的示例图中，神经网络的模块，A，正在读取某个输入 x_i，并输出一个值 h_i。循环可以使得信息可以从当前步传递到下一步。<br>    这些循环使得 RNN 看起来非常神秘。然而，如果你仔细想想，这样也不比一个正常的神经网络难于理解。RNN 可以被看做是同一神经网络的多次复制，每个神经网络模块会把消息传递给下一个。所以，如果我们将这个循环展开：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5afb587b1e3aaf95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>展开的 RNN</em></p><p>​    链式的特征揭示了 RNN 本质上是与序列和列表相关的。他们是对于这类数据的最自然的神经网络架构。<br>    并且 RNN 也已经被人们应用了！在过去几年中，应用 RNN 在语音识别，语言建模，翻译，图片描述等问题上已经取得一定成功，并且这个列表还在增长。建议参考 Andrej Karpathy 的博客文章——<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks</a> 来看看更丰富有趣的 RNN 的成功应用。<br>    而这些成功应用的关键之处就是 LSTM 的使用，这是一种特别的 RNN，比标准的 RNN 在很多的任务上都表现得更好。几乎所有的令人振奋的关于 RNN 的结果都是通过 LSTM 达到的。</p><h2 id="长期依赖（Long-Term-Dependencies）问题"><a href="#长期依赖（Long-Term-Dependencies）问题" class="headerlink" title="长期依赖（Long-Term Dependencies）问题"></a>长期依赖（Long-Term Dependencies）问题</h2><p>​    RNN 的关键点之一就是他们可以用来连接先前的信息到当前的任务上，例如使用过去的视频段来推测对当前段的理解。如果 RNN 可以做到这个，他们就变得非常有用。但是真的可以么？答案是，还有很多依赖因素。<br>    有时候，我们仅仅需要知道先前的信息来执行当前的任务。例如，我们有一个语言模型用来基于先前的词来预测下一个词。如果我们试着预测 “the clouds are in the sky” 最后的词，我们并不需要任何其他的上下文 —— 因此下一个词很显然就应该是 sky。在这样的场景中，相关的信息和预测的词位置之间的间隔是非常小的，RNN 可以学会使用先前的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-bffa58cf1e08bf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​                                不太长的相关信息和位置间隔</p><p>​    但是同样会有一些更加复杂的场景。假设我们试着去预测“I grew up in France… I speak fluent French”最后的词。当前的信息建议下一个词可能是一种语言的名字，但是如果我们需要弄清楚是什么语言，我们是需要先前提到的离当前位置很远的 France 的上下文的。这说明相关信息和当前预测位置之间的间隔就肯定变得相当的大。<br>    不幸的是，在这个间隔不断增大时，RNN 会丧失学习到连接如此远的信息的能力。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-7cf6762040d5918c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>相当长的相关信息和位置间隔*</p><p>​    在理论上，RNN 绝对可以处理这样的 长期依赖 问题。人们可以仔细挑选参数来解决这类问题中的最初级形式，但在实践中，RNN 肯定不能够成功学习到这些知识。<a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf" target="_blank" rel="noopener">Bengio, et al. (1994)</a>等人对该问题进行了深入的研究，他们发现一些使训练 RNN 变得非常困难的相当根本的原因。<br>    然而，幸运的是，LSTM 并没有这个问题！</p><h2 id="LSTM-网络"><a href="#LSTM-网络" class="headerlink" title="LSTM 网络"></a>LSTM 网络</h2><p>​    Long Short Term Memory 网络—— 一般就叫做 LSTM ——是一种 RNN 特殊的类型，可以学习长期依赖信息。LSTM 由<a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber (1997)</a>提出，并在近期被<a href="https://scholar.google.com/citations?user=DaFHynwAAAAJ&amp;hl=en" target="_blank" rel="noopener">Alex Graves</a>进行了改良和推广。在很多问题，LSTM 都取得相当巨大的成功，并得到了广泛的使用。<br>    LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力！<br>    所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-13bc1a955ebc6668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>标准 RNN 中的重复模块包含单一的层</em></p><p>​    LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于 单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-421311f51e09bc2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>LSTM 中的重复模块包含四个交互的层</em></p><p>​    不必担心这里的细节。我们会一步一步地剖析 LSTM 解析图。现在，我们先来熟悉一下图中使用的各种元素的图标。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-a7fd4db3a625cbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>LSTM 中的图标</em></p><p>​    在上面的图例中，每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表 pointwise 的操作，诸如向量的和，而黄色的矩阵就是学习到的神经网络层。合在一起的线表示向量的连接，分开的线表示内容被复制，然后分发到不同的位置。</p><h2 id="LSTM-的核心思想"><a href="#LSTM-的核心思想" class="headerlink" title="LSTM 的核心思想"></a>LSTM 的核心思想</h2><p>​    LSTM 的关键就是细胞状态，水平线在图上方贯穿运行。<br>    细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-cac54fa82daf1acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 sigmoid 神经网络层和一个 pointwise 乘法操作(向量或者矩阵的pointwise 乘法指按元素相乘,点乘（不改变向量长度、大小）</p><p>a = [a1 a2 a3]</p><p>b = [b1 b2 b3]</p><p>a和b的pointwise product</p><p>a • b = a1<strong><em>b1+a2\</em></strong>b2+a3*b3 )。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-faccc7bf241aa8b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    Sigmoid 层输出 0 到 1 之间的数值，描述每个部分有多少量可以通过。0 代表“不许任何量通过”，1 就指“允许任意量通过”！</p><p>​    LSTM 拥有三个门，来保护和控制细胞状态。这三个门分别输入门、遗忘门和输出门。 LSTM通过三个这样的本结构来实现信息的保护和控制。</p><h2 id="逐步理解LSTM"><a href="#逐步理解LSTM" class="headerlink" title="逐步理解LSTM"></a>逐步理解LSTM</h2><p>现在我们就开始通过三个门逐步的了解LSTM的原理</p><h3 id="遗忘门"><a href="#遗忘门" class="headerlink" title="遗忘门"></a>遗忘门</h3><p>​    在我们 LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为<strong>忘记门层</strong>完成。该门会读取<code>h_{t-1}</code>和<code>x_t</code>，输出一个在 0 到 1 之间的数值给每个在细胞状态<code>C_{t-1}</code>中的数字。1 表示“完全保留”，0 表示“完全舍弃”。 </p><p>​    让我们回到语言模型的例子中来基于已经看到的预测下一个词。在这个问题中，细胞状态可能包含当前<strong>主语</strong>的性别，因此正确的<strong>代词</strong>可以被选择出来。当我们看到新的<strong>主语</strong>，我们希望忘记旧的<strong>主语</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-06ffb4507903c13d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>决定丢弃信息</em> </p><p>其中ht−1表示的是上一个cell的输出，xt表示的是当前细胞的输入。σ表示sigmod函数。</p><h3 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h3><p>​    下一步是确定什么样的新信息被存放在细胞状态中。这里包含两个部分。第一，sigmoid 层称 “输入门层” 决定什么值我们将要更新。然后，一个 tanh 层创建一个新的候选值向量，C^t，会被加入到状态中。下一步，我们会讲这两个信息来产生对状态的更新。 在我们语言模型的例子中，我们希望增加新的主语的性别到细胞状态中，来替代旧的需要忘记的主语。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0bed48af76b88e10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>确定更新的信息</em> </p><p>​    现在是更新旧细胞状态的时间了，Ct−1更新为Ct。前面的步骤已经决定了将会做什么，我们现在就是实际去完成。</p><p>​    我们把旧状态与ft相乘，丢弃掉我们确定需要丢弃的信息。接着加上it∗C~t。这就是新的候选值，根据我们决定更新每个状态的程度进行变化。</p><p>​    在语言模型的例子中，这就是我们实际根据前面确定的目标，丢弃旧代词的性别信息并添加新的信息的地方。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e18424a8c9c39b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>更新细胞状态</em> </p><h3 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h3><p>​    最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p><p>​    在语言模型的例子中，因为他就看到了一个 <strong>代词</strong>，可能需要输出与一个 <strong>动词 </strong>相关的信息。例如，可能输出是否代词是单数还是负数，这样如果是动词的话，我们也知道动词需要进行的词形变化。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-d5f6c68ccc9245c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><em>输出信息</em> </p><h2 id="LSTM-的变体"><a href="#LSTM-的变体" class="headerlink" title="LSTM 的变体"></a>LSTM 的变体</h2><p>​    我们到目前为止都还在介绍正常的 LSTM。但是不是所有的 LSTM 都长成一个样子的。实际上，几乎所有包含 LSTM 的论文都采用了微小的变体。差异非常小，但是也值得拿出来讲一下。<br>    其中一个流形的 LSTM 变体，就是由 <a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf" target="_blank" rel="noopener">Gers &amp; Schmidhuber (2000)</a> 提出的，增加了 “peephole connection”。是说，我们让 门层 也会接受细胞状态的输入。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-7e38dcfe1cc7b575.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong><em>peephole 连接</em></strong></p><p>​    上面的图例中，我们增加了 peephole 到每个门上，但是许多论文会加入部分的 peephole 而非所有都加。</p><p>​    另一个变体是通过使用 coupled 忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。我们仅仅会当我们将要输入在当前位置时忘记。我们仅仅输入新的值到那些我们已经忘记旧的信息的那些状态 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6c6982add34f8466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong><em>coupled 忘记门和输入门</em></strong></p><p>​    另一个改动较大的变体是 Gated Recurrent Unit (GRU)，这是由 <a href="http://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">Cho, et al. (2014)</a> 提出。它将忘记门和输入门合成了一个单一的 更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-050d4d229257b73f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    其中， rt表示重置门，zt表示更新门。重置门决定是否将之前的状态忘记。(作用相当于合并了 LSTM 中的遗忘门和传入门）当rt趋于0的时候，前一个时刻的状态信息ht−1会被忘掉，隐藏状态h^t会被重置为当前输入的信息。更新门决定是否要将隐藏状态更新为新的状态h^t（作用相当于 LSTM 中的输出门） 。</p><p>​    和 LSTM 比较一下：<br>- GRU 少一个门，同时少了细胞状态Ct。<br>- 在 LSTM 中，通过遗忘门和传入门控制信息的保留和传入；GRU 则通过重置门来控制是否要保留原来隐藏状态的信息，但是不再限制当前信息的传入。<br>- 在 LSTM 中，虽然得到了新的细胞状态 Ct，但是还不能直接输出，而是需要经过一个过滤的处理:ht=ot∗tanh(Ct)；同样，在 GRU 中, 虽然我们也得到了新的隐藏状态h^t， 但是还不能直接输出，而是通过更新门来控制最后的输出：ht=(1−zt)∗ht−1+zt∗h^t。</p><h2 id="多层LSTM"><a href="#多层LSTM" class="headerlink" title="多层LSTM"></a>多层LSTM</h2><p><strong>多层LSTM是将LSTM进行叠加，其优点是能够在高层更抽象的表达特征，并且减少神经元的个数，增加识别准确率并且降低训练时间。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    LSTM 是我们在 RNN 中获得的重要成功。很自然地，我们也会考虑：哪里会有更加重大的突破呢？在研究人员间普遍的观点是：“Yes! 下一步已经有了——那就是<strong>注意力</strong>！” 这个想法是让 RNN 的每一步都从更加大的信息集中挑选信息。例如，如果你使用 RNN 来产生一个图片的描述，可能会选择图片的一个部分，根据这部分信息来产生输出的词。实际上，<a href="http://arxiv.org/pdf/1502.03044v2.pdf" target="_blank" rel="noopener">Xu, et al.(2015)</a>已经这么做了——如果你希望深入探索<strong>注意力</strong>可能这就是一个有趣的起点！还有一些使用注意力的相当振奋人心的研究成果，看起来有更多的东西亟待探索……<br>    注意力也不是 RNN 研究领域中唯一的发展方向。例如，<a href="http://arxiv.org/pdf/1507.01526v1.pdf" target="_blank" rel="noopener">Kalchbrenner, et al. (2015)</a> 提出的 Grid LSTM 看起来也是很有前途。使用生成模型的 RNN，诸如<a href="http://arxiv.org/pdf/1502.04623.pdf" target="_blank" rel="noopener">Gregor, et al. (2015)</a> <a href="http://arxiv.org/pdf/1506.02216v3.pdf" target="_blank" rel="noopener">Chung, et al. (2015)</a> 和 <a href="http://arxiv.org/pdf/1411.7610v3.pdf" target="_blank" rel="noopener">Bayer &amp; Osendorfer (2015)</a> 提出的模型同样很有趣。在过去几年中，RNN 的研究已经相当的燃，而研究成果当然也会更加丰富！</p><h2 id="LSTM实现手写数字"><a href="#LSTM实现手写数字" class="headerlink" title="LSTM实现手写数字"></a>LSTM实现手写数字</h2><p>这里我们利用的数据集是tensorflow提供的一个手写数字数据集。该数据集是一个包含n张28*28的数据集。</p><h3 id="设置LSTM参数"><a href="#设置LSTM参数" class="headerlink" title="设置LSTM参数"></a>设置LSTM参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.contrib <span class="keyword">import</span> rnn</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration</span></span><br><span class="line"><span class="comment">#                        O * W + b -&gt; 10 labels for each image, O[? 28], W[28 10], B[10]</span></span><br><span class="line"><span class="comment">#                       ^ (O: output 28 vec from 28 vec input)</span></span><br><span class="line"><span class="comment">#                       |</span></span><br><span class="line"><span class="comment">#      +-+  +-+       +--+</span></span><br><span class="line"><span class="comment">#      |1|-&gt;|2|-&gt; ... |28| time_step_size = 28</span></span><br><span class="line"><span class="comment">#      +-+  +-+       +--+</span></span><br><span class="line"><span class="comment">#       ^    ^    ...  ^</span></span><br><span class="line"><span class="comment">#       |    |         |</span></span><br><span class="line"><span class="comment"># img1:[28] [28]  ... [28]</span></span><br><span class="line"><span class="comment"># img2:[28] [28]  ... [28]</span></span><br><span class="line"><span class="comment"># img3:[28] [28]  ... [28]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># img128 or img256 (batch_size or test_size 256)</span></span><br><span class="line"><span class="comment">#      each input size = input_vec_size=lstm_size=28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration variables</span></span><br><span class="line">input_vec_size = lstm_size = <span class="number">28</span> <span class="comment"># 输入向量的维度</span></span><br><span class="line">time_step_size = <span class="number">28</span> <span class="comment"># 循环层长度</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">test_size = <span class="number">256</span></span><br></pre></td></tr></table></figure><p>这里设置将batch_size设置为128，time_step_size表示的是lstm神经元的个数，这里设置为28个，input_vec_size表示一次输入的像素数。 </p><h3 id="初始化权值参数"><a href="#初始化权值参数" class="headerlink" title="初始化权值参数"></a>初始化权值参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.Variable(tf.random_normal(shape, stddev=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X, W, B, lstm_size)</span>:</span></span><br><span class="line">    <span class="comment"># X, input shape: (batch_size, time_step_size, input_vec_size)</span></span><br><span class="line">    <span class="comment"># XT shape: (time_step_size, batch_size, input_vec_size)</span></span><br><span class="line">    <span class="comment">#对这一步操作还不是太理解，为什么需要将第一行和第二行置换</span></span><br><span class="line">    XT = tf.transpose(X, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])  <span class="comment"># permute time_step_size and batch_size,[28, 128, 28]</span></span><br><span class="line">    <span class="comment"># XR shape: (time_step_size * batch_size, input_vec_size)</span></span><br><span class="line">    XR = tf.reshape(XT, [<span class="number">-1</span>, lstm_size]) <span class="comment"># each row has input for each lstm cell (lstm_size=input_vec_size)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Each array shape: (batch_size, input_vec_size)</span></span><br><span class="line">    X_split = tf.split(XR, time_step_size, <span class="number">0</span>) <span class="comment"># split them to time_step_size (28 arrays),shape = [(128, 28),(128, 28)...]</span></span><br><span class="line">    <span class="comment"># Make lstm with lstm_size (each input vector size). num_units=lstm_size; forget_bias=1.0</span></span><br><span class="line">    lstm = rnn.BasicLSTMCell(lstm_size, forget_bias=<span class="number">1.0</span>, state_is_tuple=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get lstm cell output, time_step_size (28) arrays with lstm_size output: (batch_size, lstm_size)</span></span><br><span class="line">    <span class="comment"># rnn..static_rnn()的输出对应于每一个timestep，如果只关心最后一步的输出，取outputs[-1]即可</span></span><br><span class="line">    outputs, _states = rnn.static_rnn(lstm, X_split, dtype=tf.float32)  <span class="comment"># 时间序列上每个Cell的输出:[... shape=(128, 28)..]</span></span><br><span class="line">    <span class="comment"># tanh activation</span></span><br><span class="line">    <span class="comment"># Get the last output</span></span><br><span class="line">    <span class="keyword">return</span> tf.matmul(outputs[<span class="number">-1</span>], W) + B, lstm.state_size <span class="comment"># State size to initialize the state</span></span><br></pre></td></tr></table></figure><p>​    init_weigths函数利用正态分布随机生成参数的初始值，model的四个参数分别为：X为输入的数据，W表示的是28<em>10的权值(标签为0-9)，B表示的是偏置，维度和W一样。这里首先将一批128</em>（28*28）的图片放进神经网络。然后进行相关的操作(注释已经写得很明白了，这里就不再赘述)，然后利用WX+B求出预测结果，同时返回lstm的尺寸</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">py_x, state_size = model(X, W, B, lstm_size)</span><br><span class="line"></span><br><span class="line">cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=py_x, labels=Y))</span><br><span class="line">train_op = tf.train.RMSPropOptimizer(<span class="number">0.001</span>, <span class="number">0.9</span>).minimize(cost)</span><br></pre></td></tr></table></figure><p>然后通过交叉熵计算误差，反复训练得到最优值。 </p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;[RNN]&lt;/li&gt;
&lt;li&gt;[LSTM网络]&lt;/li&gt;
&lt;li&gt;[LSTM核心思想]&lt;/li&gt;
&lt;li&gt;[逐步理解LSTM]&lt;ul&gt;
&lt;li&gt;[遗忘门]&lt;/li&gt;
&lt;li&gt;[输入门]&lt;/li&gt;
&lt;li&gt;[输出门]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;[LSTM变体]&lt;/li&gt;
&lt;li&gt;[多层LSTM]&lt;/li&gt;
&lt;li&gt;LSTM实现手写数字&lt;ul&gt;
&lt;li&gt;[设置LSTM参数]&lt;/li&gt;
&lt;li&gt;[初始化权值参数]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="LSTM" scheme="http://yoursite.com/tags/LSTM/"/>
    
      <category term="RNN" scheme="http://yoursite.com/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>树表查找</title>
    <link href="http://yoursite.com/2018/08/23/%E6%A0%91%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/08/23/树表查找/</id>
    <published>2018-08-23T12:58:25.000Z</published>
    <updated>2018-08-23T14:25:09.428Z</updated>
    
    <content type="html"><![CDATA[<p>​    线性表的查找的顺序查找和折半查找作为查找表的组织形式，其中折半查找效率较高。但由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此当表的插入或删除操作频繁时，为维护表的有序性，需要移动表中很多记录。这种由移动记录引用的额外时间开销，就会抵消折半查找的优点。</p><p>​    所以，线性表的查找更适用于静态查找表，<strong>若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。</strong></p><a id="more"></a><p><strong>一、二叉排序树</strong> </p><p>​        <strong>二叉查找树</strong>（BinarySearch Tree，也叫二叉搜索树，或称<strong>二叉排序树Binary Sort Tree</strong>）或者是一棵空树，或者是具有下列性质的二叉树：</p><p>　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>　　3）任意节点的左、右子树也分别为二叉查找树。</p><p>　　<strong>二叉查找树性质</strong>：<strong>对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p><p>在讨论二叉排序树上的运算之前,定义其节点的类型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">​   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>        //记录类型</span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">KeyType key;            <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;          <span class="comment">//其他数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line"></span><br><span class="line">   &#125; BSTNode;</span><br></pre></td></tr></table></figure></p><p>不同形态的二叉查找树如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3e8f2ba9f32bbc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如下图，这个是普通的二叉树：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e719c23df7ce1943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在此基础上，加上节点之间的大小关系，就是二叉查找树：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b305e8bfd1851c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>1. 二叉排序树上的查找</strong></p><p>因为二叉排序树可看做是一个有序表，所以在二叉排序树上进行查找，和二分查找类似，也是一个逐步缩小查找范围的过程。</p><p>递归查找算法SearchBST()如下（在二叉排序树bt上查找关键字为k的记录,成功时返回该节点指针，否则返回NULL）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span> || bt-&gt;key==k) <span class="comment">//递归终结条件</span></span><br><span class="line">​       <span class="keyword">return</span> bt;</span><br><span class="line">​    <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line"> ​    　 <span class="keyword">return</span> SearchBST(bt-&gt;lchild,k); <span class="comment">//在左子树中递归查找</span></span><br><span class="line"> ​    <span class="keyword">else</span></span><br><span class="line">     　 <span class="keyword">return</span> SearchBST(bt-&gt;rchild,k); <span class="comment">//在右子树中递归查找</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>也可以采用如下非递归算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">SearchBST1</span><span class="params">(BSTNode *bt,KeyType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">while</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (k==bt-&gt;key)</span><br><span class="line">          <span class="keyword">return</span> bt;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line">          bt=bt-&gt;lchild;  <span class="comment">//在左子树中查找</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          bt=bt-&gt;rchild;  <span class="comment">//在左子树中查找</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>                   <span class="comment">//没有找到返回NULL</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. 二叉排序树的插入和生成</strong></p><p>​    在二叉排序树中插入一个关键字为k的新记录，要保证插入后仍满足BST性质。</p><p>插入过程：</p><p>（1）若二叉排序树T为空，则创建一个key域为k的节点，将它作为根节点；</p><p>（2）否则将k和根节点的关键字比较，若两者相等，则说明树中已有此关键字k，无须插入，直接返回0；</p><p>（3）若k 小于T-&gt;key，则将k插入根节点的左子树中。</p><p>（4）否则将它插入右子树中。</p><p>对应的递归算法InsertBST()如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertBST</span><span class="params">(BSTNode *&amp;p,KeyType k)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在以*p为根节点的BST中插入一个关键字为k的节点。插入成功返回1,否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//原树为空, 新插入的记录为根节点</span></span><br><span class="line">   &#123;   p=(BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">       p-&gt;key=k;p-&gt;lchild=p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>  (k==p-&gt;key) <span class="comment">//存在相同关键字的节点,返回0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;p-&gt;key) </span><br><span class="line">      <span class="keyword">return</span> InsertBST(p-&gt;lchild,k);　<span class="comment">//插入到左子树中</span></span><br><span class="line">   <span class="keyword">else</span>  </span><br><span class="line">      <span class="keyword">return</span> InsertBST(p-&gt;rchild,k);  <span class="comment">//插入到右子树中</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p> 插入操作图示如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-5b7b81dcdaab7ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>最大最小值</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-27f59ee44dba32d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>二叉排序树的生成</strong>，是从一个空树开始，每插入一个关键字，就调用一次插入算法将它插入到当前已生成的二叉排序树中。</p><p>从关键字数组A[0..n-1]生成二叉排序树的算法CreatBST()如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">CreatBST</span><span class="params">(KeyType A[],<span class="keyword">int</span> n)</span> <span class="comment">//返回树根指针</span></span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">BSTNode *bt=<span class="literal">NULL</span>;    <span class="comment">//初始时bt为空树</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n) </span><br><span class="line">    &#123;  </span><br><span class="line">InsertBST(bt,A[i]);  <span class="comment">//将A[i]插入二叉排序树T中</span></span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;       <span class="comment">//返回建立的二叉排序树的根指针</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>3. 二叉排序树的节点删除</strong></p><p>（1）被删除的节点是叶子节点：<strong>直接删去该节点</strong>。</p><p>（2）被删除的节点只有左子树或者只有右子树，用其<strong>左子树或者右子树代替它</strong>。</p><p>（3）被删除的节点既有左子树，也有右子树：<strong>以其前驱替代之</strong>，然后再删除该前驱节点。前驱是左子树中最大的节点。<strong>也可以用其后继替代之</strong>，然后再删除该后继节点。后继是右子树中最小的节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteBST</span><span class="params">(BSTNode *&amp;bt,KeyType k)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在bt中删除关键字为k的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">if</span> (bt==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树删除失败</span></span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">   &#123; <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> DeleteBST(bt-&gt;lchild,k); <span class="comment">//递归在左子树中删除为k的节点</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;bt-&gt;key)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> DeleteBST(bt-&gt;rchild,k); <span class="comment">//递归在右子树中删除为k的节点</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">     &#123;</span><br><span class="line"> Delete(bt);    <span class="comment">//调用Delete(bt)函数删除*bt节点</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BSTNode *&amp;p)</span>    <span class="comment">//从二叉排序树中删除*p节点</span></span></span><br><span class="line"><span class="function"></span>&#123;  BSTNode *q;</span><br><span class="line">   <span class="keyword">if</span> (p-&gt;rchild==<span class="literal">NULL</span>)      <span class="comment">//*p节点没有右子树的情况</span></span><br><span class="line">   &#123;   q=p; p=p-&gt;lchild;</span><br><span class="line">            <span class="comment">//其右子树的根节点放在被删节点的位置上</span></span><br><span class="line">       <span class="built_in">free</span>(q);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>)    <span class="comment">//*p节点没有左子树</span></span><br><span class="line">   &#123;   q=p; p=p-&gt;rchild;</span><br><span class="line">            <span class="comment">//将*p节点的右子树作为双亲节点的相应子树/</span></span><br><span class="line">       <span class="built_in">free</span>(q);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> Delete1(p,p-&gt;lchild);</span><br><span class="line">           <span class="comment">//*p节点既没有左子树又没有右子树的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除二叉排序树节点的算法DeleteBST()如下（指针变量p指向待删除的节点，指针变量q指向待删除节点*p的双亲节点）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete1</span><span class="params">(BSTNode *p,BSTNode *&amp;r)</span></span></span><br><span class="line"><span class="function">  <span class="comment">//当被删*p节点有左右子树时的删除过程</span></span></span><br><span class="line"><span class="function">  </span>&#123;  BSTNode *q;</span><br><span class="line">     <span class="keyword">if</span> (r-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">   Delete1(p,r-&gt;rchild);<span class="comment">//递归找最右下节点</span></span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//找到了最右下节点*r</span></span><br><span class="line">     &#123;   p-&gt;key=r-&gt;key;            <span class="comment">//将*r的关键字值赋给*p</span></span><br><span class="line">   q=r; r=r-&gt;lchild;</span><br><span class="line">           <span class="comment">//将左子树的根节点放在被删节点的位置上</span></span><br><span class="line">   <span class="built_in">free</span>(q); <span class="comment">//释放原*r的空间</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>  当删除的节点有2个子节点时，问题就变复杂了。</p><p>​    假设我们删除的节点t具有两个子节点。因为t具有右子节点，所以我们需要找到其右子节点中的最小节点，替换t节点的位置。这里有四个步骤：</p><ol><li>保存带删除的节点到临时变量t</li><li>将t的右节点的最小节点min(t.right)保存到临时节点x</li><li>将x的右节点设置为deleteMin(t.right)，该右节点是删除后，所有比x.key最大的节点。</li><li>将x的做节点设置为t的左节点。</li></ol><p>整个过程如下图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f43822ca7e9c93e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>分析</strong></p><p>​    二叉查找树的运行时间和树的形状有关，树的形状又和插入元素的顺序有关。在最好的情况下，节点完全平衡，从根节点到最底层叶子节点只有lgN个节点。在最差的情况下，根节点到最底层叶子节点会有N各节点。在一般情况下，树的形状和最好的情况接近。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-3c78991c7658a11d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    在分析二叉查找树的时候，我们通常会假设插入的元素顺序是随机的。对BST的分析类似与快速排序中的查找。</p><p><strong>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</strong></p><p>　　下图为二叉树查找和顺序查找以及二分查找性能的对比图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dd064ab9226e60e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>二、平衡二叉树(AVL)</strong></p><p>​    若一棵二叉树中每个节点的左、右子树的高度至多相差1，则称此二叉树为平衡二叉树。</p><p>​    在算法中，通过平衡因子（balancd factor，用bf表示）来具体实现上述平衡二叉树的定义。</p><p>​    平衡因子：平衡二叉树中每个节点有一个平衡因子域，每个节点的平衡因子是该节点左子树的高度减去右子树的高度。从平衡因子的角度可以说，若一棵二叉树中所有节点的平衡因子的绝对值小于或等于1，即<strong>平衡因子取值为1、0或-1</strong>，则该二叉树称为平衡二叉树。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-613b10b01cdb4d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义AVL树的节点的类型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>     //记录类型</span></span><br><span class="line"><span class="class">&#123;</span>　KeyType key;    <span class="comment">//关键字项</span></span><br><span class="line">   <span class="keyword">int</span> bf;<span class="comment">//增加的平衡因子</span></span><br><span class="line">   InfoType data;     <span class="comment">//其他数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    线性表的查找的顺序查找和折半查找作为查找表的组织形式，其中折半查找效率较高。但由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此当表的插入或删除操作频繁时，为维护表的有序性，需要移动表中很多记录。这种由移动记录引用的额外时间开销，就会抵消折半查找的优点。&lt;/p&gt;
&lt;p&gt;​    所以，线性表的查找更适用于静态查找表，&lt;strong&gt;若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="查找算法" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
      <category term="树表查找，二叉树" scheme="http://yoursite.com/tags/%E6%A0%91%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>常见查找算法总结</title>
    <link href="http://yoursite.com/2018/08/22/%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/22/常见查找算法总结/</id>
    <published>2018-08-22T02:04:59.000Z</published>
    <updated>2018-08-23T12:47:49.145Z</updated>
    
    <content type="html"><![CDATA[<p>阅读目录</p><ol><li>顺序查找</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li><li>树表查找</li><li>分块查找</li><li>哈希查找</li></ol><a id="more"></a><p>​    查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。</p><p>　　<strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><p>　　<strong>查找算法分类：</strong></p><p>　　1）静态查找和动态查找；</p><p>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</p><p>　　2）无序查找和有序查找。</p><p>　　　　无序查找：被查找数列有序无序均可；</p><p>　　　　有序查找：被查找数列必须为有序数列。</p><p>　　<strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>　　Pi：查找表中第i个数据元素的概率。<br>　　Ci：找到第i个数据元素时已经比较过的次数。</p><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p>　　<strong>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</strong></p><p>　　<strong>基本思想：</strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p>　　<strong>复杂度分析：</strong>　</p><p>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p><p>　　所以，<strong>顺序查找的时间复杂度为O(n)。</strong></p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequence_Search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sequence_Search</span><span class="params">(nums, target)</span>:</span>   </span><br><span class="line">     <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):     </span><br><span class="line">        <span class="keyword">if</span> nums[i]==target:          </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="2-二分查找-折半查找"><a href="#2-二分查找-折半查找" class="headerlink" title="2. 二分查找/折半查找"></a>2. 二分查找/折半查找</h3><p>　　<strong>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p><p>　　<strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p>　　<strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且<strong>期望时间复杂度为O(log2n)</strong>；</p><p>　　注：<strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要</strong>频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找（折半查找），非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2） python版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----------------递归二分查找------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_Search</span><span class="params">(nums,target,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    mid=(left+right)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="keyword">return</span> binary_Search(nums, target, left, mid<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> binary_Search(nums, target, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    low=<span class="number">0</span></span><br><span class="line">    high=len(list)<span class="number">-1</span></span><br><span class="line">    result = binary_Search(list,<span class="number">444</span>,low,high)</span><br><span class="line">    print(result)</span><br><span class="line"><span class="comment">#-------------------非递归查找------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_Search</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low+high)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    result = binary_Search(list,<span class="number">444</span>)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure></p><p>​    时间复杂度分析    最坏情况下，关键词比较次数为⌊log2n⌋+1，最好情况就是1，所以二分查找的时间复杂度为O(logn)。它显然好于顺序查找的O(n)。 </p><h3 id="3-插值查找"><a href="#3-插值查找" class="headerlink" title="3. 插值查找"></a>3. 插值查找</h3><p>　　在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p><p>　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p><p>　　同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p><p>　　经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p><p>　　mid=(low+high)/2, 即mid=low+1/2*(high-low);</p><p>　　通过类比，我们可以将查找的点改进为如下：</p><p>　　mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，</p><p>　　也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p><p>　　<strong>基本思想：</strong>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p><p>　　注：<strong>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</strong></p><p>　　<strong>复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</strong></p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）python代码 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插值查找算法</span></span><br><span class="line"><span class="comment"># 时间复杂度O(log(n))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_search</span><span class="params">(lis, key)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(lis) - <span class="number">1</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        time += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">        mid = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">        print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (mid, low, high))</span><br><span class="line">        <span class="keyword">if</span> key &lt; lis[mid]:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &gt; lis[mid]:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 打印查找的次数</span></span><br><span class="line">            print(<span class="string">"times: %s"</span> % time)</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    print(<span class="string">"times: %s"</span> % time)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    result = insert_search(LIST, <span class="number">444</span>)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>​    时间复杂度分析    </p><p>​    它的时间复杂度跟二分查找的时间复杂度一样，为O(logn)。需要注意的是对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 </p><h3 id="4-斐波那契查找"><a href="#4-斐波那契查找" class="headerlink" title="4. 斐波那契查找"></a>4. 斐波那契查找</h3><p>　　在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</p><p>　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p><p>　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</p><p>　　大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b0cb1d3f2022502c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>基本思想：</strong>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p><p>　　相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1;</p><p>​    3）&lt;，high=mid-1。</p><p>　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p><p> 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1,k-=2;</p><p>　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</p><p>　　3）&lt;，high=mid-1,k-=1。</p><p>　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p><p>　　<strong>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</strong></p><p>（1）C++实现 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契查找</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> * F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> F[max_size];</span><br><span class="line">  Fibonacci(F);<span class="comment">//构造一个斐波那契数组F </span></span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">      ++k;</span><br><span class="line">  <span class="keyword">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></span><br><span class="line">  temp=<span class="keyword">new</span> <span class="keyword">int</span> [F[k]<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</span><br><span class="line">     temp[i]=a[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid<span class="number">-1</span>;</span><br><span class="line">      k-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+<span class="number">1</span>;</span><br><span class="line">     k-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(mid&lt;n)</span><br><span class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">delete</span> [] temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> index=FibonacciSearch(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),key);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">" is located at:"</span>&lt;&lt;index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#source为待查找数组，key为要查找的数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacciSearch</span><span class="params">(source,key)</span>:</span></span><br><span class="line">    <span class="comment">#生成裴波那契数列</span></span><br><span class="line">    fib = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">36</span>):</span><br><span class="line">        fib.append(fib[<span class="number">-1</span>]+fib[<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#确定待查找数组在裴波那契数列的位置</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    n = len(source)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#此处 n&gt;fib[k]-1 也是别有深意的</span></span><br><span class="line">    <span class="comment">#若n恰好是裴波那契数列上某一项，且要查找的元素正好在最后一位，此时必须将数组长度填充到数列下一项的数字</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; fib[k]<span class="number">-1</span>):</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="comment">#将待查找数组填充到指定的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n,fib[k]):</span><br><span class="line">        a.append(a[<span class="number">-1</span>])</span><br><span class="line">    low,high = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">        <span class="comment">#获取黄金分割位置元素下标</span></span><br><span class="line">        mid = low + fib[k<span class="number">-1</span>] - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span>(key &lt; a[mid]):</span><br><span class="line">            <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">            k = k <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span>(key &gt; a[mid]):</span><br><span class="line">            <span class="comment">#若key比这个元素大,则key至应该在mid+1至high之间，剩下的元素个数为F(k)-F(k-1)-1=F(k-2)-1</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">            k = k - <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; n):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 函数测试 ###</span></span><br><span class="line"><span class="comment">#生成待查找的数组</span></span><br><span class="line">a = [random.randint(<span class="number">1</span>,<span class="number">100000</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">33</span>)]</span><br><span class="line">a.append(<span class="number">673990</span>)</span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment">#待查找的数</span></span><br><span class="line">key = <span class="number">673990</span></span><br><span class="line"><span class="comment">#输出查找到的位置下标</span></span><br><span class="line">print(fibonacciSearch(a,key))</span><br></pre></td></tr></table></figure></p><p> 时间复杂度分析    </p><p>​    斐波那契查找的整体时间复杂度也为O(log(n))。但就平均性能，要优于二分查找。但是在最坏情况下，比如这里如果key为1，则始终处于左侧半区查找，此时其效率要低于二分查找。 </p><ul><li><p><strong>总结  </strong>  </p><p>​    二分查找的mid运算是加法与除法，插值查找则是复杂的四则运算，而斐波那契查找只是最简单的加减运算。在海量数据的查找中，这种细微的差别可能会影响最终的查找效率。因此，三种有序表的查找方法本质上是分割点的选择不同，各有优劣，应根据实际情况进行选择。 </p></li></ul><h3 id="5-树表查找"><a href="#5-树表查找" class="headerlink" title="5. 树表查找"></a><strong>5. 树表查找</strong></h3><h3 id="6-线性索引查找"><a href="#6-线性索引查找" class="headerlink" title="6. 线性索引查找"></a><strong>6. 线性索引查找</strong></h3><p><strong>6.1 简介</strong>    </p><p>​    前面讲的几种比较高效的查找方法是基于有序的基础之上的，而事实上，数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据都是按先后顺序存储的。    </p><p>​    对于这样的查找表，我们如何能够快速查找到需要的数据呢？常常使用的方法就是—-<strong>索引</strong>。<strong>索引是为了加快查找速度而设计的一种数据结构。</strong>它是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。    </p><p>​    索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三个线性索引：稠密索引、分块索引、和倒排索引。 </p><p><strong>6.2 稠密索引 </strong></p><p>​    稠密索引如下图所示，它是指在线性索引中，将数据集中的每个记录对应一个索引项。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b3fda93316d6cb9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    上图中，左边的图像为索引序列，它是是按照关键码有序排列的。索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高效率。比如查找上表中的18。如果不用索引表，需要6次。而用左侧的索引表，折半两次就可以找到18对应的指针。    </p><p>​    这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。  </p><p><strong>6.3 分块索引 </strong>   </p><p>​    稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引的个数，我们可以<strong>对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 </strong></p><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 　　</p><p><strong>算法思想：</strong>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 　　</p><p><strong>算法流程：</strong> 　　<br>step1 先选取各块中的最大关键字构成一个索引表； 　　<br>step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><p>​    分块有序，是把数据集的记录分成若干块，并且这些块需要满足两个条件：    </p><p>​    （1）块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间代价，因此通常我们不要求块内有序    <br>​    （2）块间有序，例如要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字….因为只有块间有序，才有可能在查找时带来效率。   <br> <br>    对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。我们定义的分块索引项由三个数据项组成，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-639d103f90fa4d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    这三个数据项分别为最大关键码（它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中最小关键字也能比这一块最大的关键字要大）、存储了块中的记录个数（以便于循环时使用）和指向块首数据元素的指针（便于开始对这一块中的记录进行遍历）。   </p><p>​    由上面的分析我们可以大概明白分块索引的步骤：    </p><p>​    （1）在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。    </p><p>​    （2） 根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查获。  </p><p><strong>6.4 倒排索引 </strong></p><p>​    不知道你对搜索引擎好奇过没，无论你查找什么样的信息，它都可以在极短的时间内给你一些结果，是什么算法技术达到这样的高效查找呢？这里介绍一种最基础的搜索技术—-倒排索引。    </p><p>​    我们来看一个例子，假设有以下两篇文章：    </p><p>​    (1) Books and friends should be few but good .    </p><p>​    (2) A good book is a good friend.    </p><p>​    假设我们忽略掉如“books”，“friends”中的复数”s”以及如“A”这样的大小写差异。我们可以整理出这样一张单词表，如下图所示，并将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中，比如“good”它在两篇文章中都有出现，而is只有在文章2中才有。  </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6a8b0164b26616ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    在这里这张单词表就是索引表，索引项的通用结构是次关键码和记录号表。 其中记录号表存储具有相同次字关键字的所有记录的记录号（可以指向记录的指针或者是该记录的主关键字）。因为这种查找方法是通过属性值来确定记录的位置，而不是通过记录来确定属性值，所以我们称其为倒排索引。 </p><p>​    </p><h3 id="7-哈希查找"><a href="#7-哈希查找" class="headerlink" title="7. 哈希查找"></a>7. 哈希查找</h3><p>　　<strong>什么是哈希表（Hash）？</strong></p><p>​    散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>    给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>    中文名  哈希表 </p><p>​    外文名  Hash table </p><p>​    别    名 散列表 </p><p>​    作    用  直接进行访问的数据结构</p><p>　　我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f71ff9ef346899db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　<strong>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</strong></p><p>　　<strong>什么是哈希函数？</strong></p><p>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p><p>　　<strong>算法思想：</strong>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><p>　　<strong>算法流程：</strong></p><p>　　1）用给定的哈希函数构造哈希表；</p><p>　　2）根据选择的冲突处理方法解决地址冲突；</p><p>　　　　常见的解决冲突的方法：拉链法和线性探测法。</p><p>　　3）在哈希表的基础上执行哈希查找。</p><p>　　<strong>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</strong></p><p>　　<strong>复杂度分析</strong>：</p><p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><p>　　<strong>使用Hash，我们付出了什么？</strong><br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV(key value) pair，经常使用Python可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？</p><p>　　Hash是一种典型<strong>以空间换时间</strong>的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p><p>　　Hash算法和其他查找算法的性能对比：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4fad334deb8aaa01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序查找&lt;/li&gt;
&lt;li&gt;二分查找&lt;/li&gt;
&lt;li&gt;插值查找&lt;/li&gt;
&lt;li&gt;斐波那契查找&lt;/li&gt;
&lt;li&gt;树表查找&lt;/li&gt;
&lt;li&gt;分块查找&lt;/li&gt;
&lt;li&gt;哈希查找&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="查找算法" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>10大经典排序算法总结</title>
    <link href="http://yoursite.com/2018/08/21/10%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/10大经典排序算法总结/</id>
    <published>2018-08-21T07:11:36.000Z</published>
    <updated>2018-08-29T11:19:11.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h3><h4 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h4><p>①：十种常见排序算法可以分为两大类：</p><blockquote><p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d74f1bf29b3a2413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></blockquote><p>②：另外一种分类排序方法——我们通常所说的排序算法往往指的是<strong>内部排序算法</strong>，即数据记录在内存中进行排序。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-006deb9355dbd7e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　排序算法大体可分为两种：</p><p>　　　　一种是<strong>比较排序</strong>，时间复杂度O(nlogn) ~ O(n^2)，主要有：<strong>冒泡排序</strong>，<strong>选择排序</strong>，<strong>插入排序</strong>，<strong>归并排序</strong>，<strong>堆排序</strong>，<strong>快速排序</strong>等。</p><p>　　　　另一种是<strong>非比较排序</strong>，时间复杂度可以达到O(n)，主要有：<strong>计数排序</strong>，<strong>基数排序</strong>，<strong>桶排序</strong>等。</p><h4 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fc56705ae801148b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h4><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p><p><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p></blockquote><p>​    </p><p>​    对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p><p>　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p><p>　　其次，说一下排序算法稳定性的好处。<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</strong>基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p><h4 id="0-4-技巧"><a href="#0-4-技巧" class="headerlink" title="0.4 技巧"></a>0.4 技巧</h4><p>记忆<strong>口诀</strong>：</p><p><strong>不稳定</strong>排序算法口诀：<strong>快些选队（快希选堆）</strong><br>其余为稳定的。</p><p><strong>算法复杂度和关键字顺序无关的有：</strong></p><p>顺口溜：<strong>一堆</strong>（堆排序）<strong>海龟</strong>（归并排序）<strong>选</strong>（选择排序）<strong>基</strong>（基数排序）<strong>友</strong></p><p>快些以 nlog2 n  的速度归队</p><p>快=快速排序，些=希尔排序，归=归并排序，队=堆排序</p><p>这四种排序算法，时间都是 n log2 n 的，除了这四个之外，其他的排序算法平均时间都为 n^2</p><blockquote><p>一趟排序，保证一个元素为最终位置的有两类排序算法：<strong>交换</strong>类（冒泡和快速）排序和<strong>选择</strong>类排序（简单和堆）</p><p>元素比较次数和<strong>原始序列无关</strong>的算法：<strong>简单选择</strong>排序，<strong>折半插入</strong>排序</p><p>排序趟数和原序列有关的算法：<strong>交换类</strong>，其余类无关</p><p>借助于比较进行排序的算法，在最坏的时候，最好的时间复杂度为 n log2 n</p><p>堆排序和简单选择排序的时间复杂度和初始序列无关</p></blockquote><h4 id="0-5-总结："><a href="#0-5-总结：" class="headerlink" title="0.5 总结："></a>0.5 总结：</h4><p>（1）在比较类排序中，<strong>归并排序</strong>号称最快，其次是<strong>快速排序</strong>和<strong>堆排序</strong>，两者不相伯仲，但是有一点需要注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。</p><p>（2）<strong>线性时间非比较类排序</strong>一般要优于非线性时间比较类排序，但前者对待排序元素的要求较为严格，比如计数排序要求待排序数的最大值不能太大，桶排序要求元素按照hash分桶后桶内元素的数量要均匀。线性时间非比较类排序的典型特点是以空间换时间。</p><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-b05dac2a52600907.gif?imageMogr2/auto-orient/strip" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-ee6aeca39cd369d7.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(RecordType arr[])</span> </span>&#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    change = TRUE;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; len - <span class="number">1</span> &amp;&amp; change; i++) &#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        <span class="keyword">for</span> (var j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;<span class="comment">// 依次比较相邻的两个元素,使较大的那个向后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j].key &gt; arr[j+<span class="number">1</span>].key) &#123; <span class="comment">// 相邻元素两两对比。  如果条件改成arr[j].key &gt;= arr[j+1].key,则变为不稳定的排序算法</span></span><br><span class="line">                var temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                change = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    假如说上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序，则实现过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dfc34c06eb7f0c29.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    使用冒泡排序为一列数字进行排序的过程如右图所示:<img src="https://upload-images.jianshu.io/upload_images/12654931-561723951d8105b0.gif?imageMogr2/auto-orient/strip" alt=""></p><p>尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。</p><h3 id="1-1、冒泡排序的改进：鸡尾酒排序（定向-双向冒泡排序）"><a href="#1-1、冒泡排序的改进：鸡尾酒排序（定向-双向冒泡排序）" class="headerlink" title="1.1、冒泡排序的改进：鸡尾酒排序（定向/双向冒泡排序）"></a>1.1、冒泡排序的改进：鸡尾酒排序（定向/双向冒泡排序）</h3><p>​    鸡尾酒排序，也叫<strong>定向冒泡排序</strong>，是冒泡排序的一种改进，即排序过程中交替改变扫描方向。<br>    先从底向上冒一个最小元素，再从上向低冒一个最大元素。<br>    此算法与冒泡排序的不同处在于<strong>从低到高然后从高到低</strong>，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</p><p>　　鸡尾酒排序的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;    <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = TRUE;</span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = FLASE;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)   <span class="comment">// 前半轮,从左到右扫描，将最大元素放到最右边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i, i + <span class="number">1</span>);</span><br><span class="line">flag = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--)   <span class="comment">// 后半轮,从右到左扫描,将最小元素放到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i - <span class="number">1</span>, i);</span><br><span class="line">                flag = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;   <span class="comment">// 从小到大定向冒泡排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    CocktailSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"鸡尾酒排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用鸡尾酒排序为一列数字进行排序的过程如右图所示：　<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8f1eec1a3a56306b.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p><h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-d342a82e64a688f7.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)         <span class="comment">// i为已排序序列的末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)     <span class="comment">// 未排序序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])              <span class="comment">// 找出未排序序列中的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, min, i);    <span class="comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span> &#125;; <span class="comment">// 从小到大选择排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    SelectionSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"选择排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图:<img src="https://upload-images.jianshu.io/upload_images/12654931-5cb815f3948e9fac.gif?imageMogr2/auto-orient/strip" alt=""></p><p>使用选择排序为一列数字进行排序的宏观过程：　<img src="https://upload-images.jianshu.io/upload_images/12654931-d75968339d73d7f4.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</strong></p><p>　　比如序列：{ <strong>5</strong>, 8, <strong>5</strong>, <strong>2</strong>, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p><h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>​    插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。它的工作原理非常类似于我们抓扑克牌 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6604e5ddad02bbb9.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p><p>　　插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-50e91fd39b1ef7b8.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)         <span class="comment">// 类似抓扑克牌排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 拿在左手上的牌总是排序好的</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)    <span class="comment">// 将抓到的牌与手牌从右向左进行比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];            <span class="comment">// 如果该手牌比抓到的牌大，就将其右移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get; <span class="comment">// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;<span class="comment">// 从小到大插入排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    InsertionSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下<br><img src="https://upload-images.jianshu.io/upload_images/12654931-877826e57ce08dd3.gif?imageMogr2/auto-orient/strip" alt="">　　　　</p><p>　　使用插入排序为一列数字进行排序的宏观过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-26ffc967098b75c3.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　插入排序<strong>不适合对于数据量比较大的排序应用</strong>。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p><h3 id="3-1、插入排序的改进：二分插入排序"><a href="#3-1、插入排序的改进：二分插入排序" class="headerlink" title="3.1、插入排序的改进：二分插入排序"></a>3.1、插入排序的改进：二分插入排序</h3><p>​    对于插入排序，如果比较操作的代价比交换操作大的话，可以采用<strong>二分查找法</strong>来减少比较操作的次数，我们称为<strong>二分插入排序</strong>，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                    <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;                <span class="comment">// 手牌左右边界进行初始化</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; get)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[left] = get;                    <span class="comment">// 将抓到的牌插入手牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大二分插入排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    InsertionSortDichotomy(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二分插入排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p><h3 id="4、希尔排序（Shell-Sort）-插入排序的更高效改进"><a href="#4、希尔排序（Shell-Sort）-插入排序的更高效改进" class="headerlink" title="4、希尔排序（Shell Sort）-插入排序的更高效改进"></a>4、希尔排序（Shell Sort）-插入排序的更高效改进</h3><p>​    1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>递减增量排序</strong>。希尔排序是<strong>不稳定</strong>的排序算法。 </p><p>​    希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-447cc5d14ac11f21.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-4d822a983a919056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= n)   <span class="comment">// 生成初始增量</span></span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - h;</span><br><span class="line">            <span class="keyword">int</span> get = A[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)</span><br><span class="line">            &#123;</span><br><span class="line">                A[j + h] = A[j];</span><br><span class="line">                j = j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + h] = get;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;   <span class="comment">// 递减增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    ShellSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"希尔排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>以23, 10, 4, 1的步长序列进行希尔排序：<img src="https://upload-images.jianshu.io/upload_images/12654931-b7107d90df31827c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>希尔排序是不稳定的排序算法，</strong>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。</p><p>　　比如序列：{ 3, 5, 10, <strong>8</strong>, 7, 2, <strong>8</strong>, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, <strong>8</strong>, 20 } 和  { 5, <strong>8</strong>, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, <strong>8</strong>, 10, 20 } 和 { 1, 2, 5, 6, <strong>8</strong> } ，即 { 3, 1, 7, 2, <strong>8</strong>, 5, 10, 6, 20, <strong>8</strong> } ，两个8的相对次序发生了改变。    </p><p>​    希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><p>​    归并排序的实现分为<strong>递归实现</strong>与<strong>非递归(迭代)实现</strong>。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。</p><p>　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，<strong>归并操作</strong>步骤如下：</p><ol><li><strong>申请空间</strong>，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2a2beb4de1e6acdd.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5ab9457322e8103c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><span class="comment">// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];       <span class="comment">// 辅助空间O(n)</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left;                   <span class="comment">// 前一数组的起始元素</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;                <span class="comment">// 后一数组的起始元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++];  <span class="comment">// 带等号保证归并排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)  <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)  <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[left++] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursion</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>    <span class="comment">// 递归实现的归并排序(自顶向下)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right)    <span class="comment">// 当待排序的序列长度为1时，递归开始回溯，进行merge操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    MergeSortRecursion(A, left, mid);</span><br><span class="line">    MergeSortRecursion(A, mid + <span class="number">1</span>, right);</span><br><span class="line">    Merge(A, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span>    <span class="comment">// 非递归(迭代)实现的归并排序(自底向上)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, mid, right;<span class="comment">// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)        <span class="comment">// 子数组的大小i初始为1，每轮翻倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + i &lt; len)              <span class="comment">// 后一个子数组存在(需要归并)</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + i - <span class="number">1</span>;</span><br><span class="line">            right = mid + i &lt; len ? mid + i : len - <span class="number">1</span>;<span class="comment">// 后一个子数组大小可能不够</span></span><br><span class="line">            Merge(A, left, mid, right);</span><br><span class="line">            left = right + <span class="number">1</span>;               <span class="comment">// 前一个子数组索引向后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A1[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;      <span class="comment">// 从小到大归并排序</span></span><br><span class="line">    <span class="keyword">int</span> A2[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="keyword">sizeof</span>(A1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="keyword">sizeof</span>(A2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    MergeSortRecursion(A1, <span class="number">0</span>, n1 - <span class="number">1</span>);          <span class="comment">// 递归实现</span></span><br><span class="line">    MergeSortIteration(A2, n2);                 <span class="comment">// 非递归实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"递归实现的归并排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"非递归实现的归并排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下　<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e11598fb16f7f974.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　使用归并排序为一列数字进行排序的宏观过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-7d7eedbdc4d069fb.gif?imageMogr2/auto-orient/strip" alt="">　　　</p><p>　　归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对。</p><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>​    快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>​    选择一个基准，小于放左边，大于放右边。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-36a8debf59ae72e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    上图是每次将基准交换。</p><p>​    或者如下，最后再将基准交换。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-911998967362a076.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b636bd935bdaad63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（<strong>请自己想一想为什么</strong>）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-ce981ae61870643f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-da606f1c2f2ff958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p><p>​    6  1  2  <strong>5</strong>  9 3  4  <strong>7</strong>  10  8<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f2d90739a4b43360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3ca3d01aacd4865f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p><p>6  1  2 5  <strong>4</strong>  3  <strong>9</strong>  7 10  8</p><p>​    第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：</p><p><strong>3</strong>  1 2  5  4  <strong>6</strong>  9 7  10  8</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe14873d59f52f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-546ac3dfcf16c905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-ab5bf0dbddeb3081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。 </p><p><strong>注：最好的是设置一个临时变量，做覆盖操作而不是一直做交换操作。</strong></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------ 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       </span></span><br><span class="line"><span class="comment">// 稳定性 ---------- 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">// 划分函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[right];               <span class="comment">// 这里每次都选择最后一个元素作为基准</span></span><br><span class="line">    <span class="keyword">int</span> tail = left - <span class="number">1</span>;                <span class="comment">// tail为小于基准的子数组最后一个元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)  <span class="comment">// 遍历基准以外的其他元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= pivot)              <span class="comment">// 把小于等于基准的元素放到前一个子数组末尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, ++tail, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(A, tail + <span class="number">1</span>, right);           <span class="comment">// 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组</span></span><br><span class="line">                                        <span class="comment">// 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</span></span><br><span class="line">    <span class="keyword">return</span> tail + <span class="number">1</span>;                    <span class="comment">// 返回基准的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot_index = Partition(A, left, right); <span class="comment">// 基准的索引</span></span><br><span class="line">    QuickSort(A, left, pivot_index - <span class="number">1</span>);</span><br><span class="line">    QuickSort(A, pivot_index + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;; <span class="comment">// 从小到大快速排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"快速排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用快速排序法对一列数字进行排序的过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-865ae2a394b9cdbe.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong></p><p>　　比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p><blockquote><p>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？</p></blockquote><p>　　答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 </p><h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>​    堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-c45011903132bb45.gif?imageMogr2/auto-orient/strip" alt=""></p><p><strong>构建初始堆</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-e4276f7e11ad285d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>整体排序流程</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d926646825213d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span>  <span class="comment">// 从A[i]向下进行堆调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;         <span class="comment">// 左孩子索引</span></span><br><span class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;        <span class="comment">// 右孩子索引</span></span><br><span class="line">    <span class="keyword">int</span> max = i;                        <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max])</span><br><span class="line">        max = left_child;</span><br><span class="line">    <span class="keyword">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max])</span><br><span class="line">        max = right_child;</span><br><span class="line">    <span class="keyword">if</span> (max != i)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(A, i, max);                <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></span><br><span class="line">        Heapify(A, max, size);          <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>           <span class="comment">// 建堆，时间复杂度O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></span><br><span class="line">Heapify(A, i, heap_size);</span><br><span class="line">    <span class="keyword">return</span> heap_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);    <span class="comment">// 建立一个最大堆</span></span><br><span class="line">    <span class="keyword">while</span> (heap_size &gt; <span class="number">1</span>)    　　　　　　 <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></span><br><span class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></span><br><span class="line">        Swap(A, <span class="number">0</span>, --heap_size);</span><br><span class="line">        Heapify(A, <span class="number">0</span>, heap_size);     <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大堆排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序算法的演示：<img src="https://upload-images.jianshu.io/upload_images/12654931-181d10fdf3848485.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。</p><p>　　<strong>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</strong></p><p>　　比如序列：{ 9, <strong>5</strong>, 7, <strong>5</strong> }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { <strong>5</strong>, <strong>5</strong>, 7, 9 }，再进行堆调整得到{ 7, <strong>5</strong>, <strong>5</strong>, 9 }，重复之前的操作最后得到{ <strong>5</strong>, <strong>5</strong>, 7, 9 }从而改变了两个5的相对次序。</p><hr><p>以上为比较排序。</p><p>以下为非比较排序。</p><hr><h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>​    计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>​    通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-eca87818bb0a14c5.gif?imageMogr2/auto-orient/strip" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------ 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + k)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">100</span>;   <span class="comment">// 基数为100，排序[0,99]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];            <span class="comment">// 计数数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)   <span class="comment">// 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 使C[i]保存着等于i的元素个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)   <span class="comment">// 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">// 分配临时空间,长度为n，用来暂存中间数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        B[--C[A[i]]] = A[i];      <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                  <span class="comment">// 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 把临时空间B中的数据拷贝回A</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);    <span class="comment">// 释放临时空间 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">15</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">46</span>, <span class="number">27</span>, <span class="number">73</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">8</span> &#125;;  <span class="comment">// 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    CountingSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"计数排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此<strong>对于数据范围很大的数组，计数排序需要大量时间和内存。</strong></p><p>　　例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，<strong>将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。</strong></p><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>​    计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>​    桶排序也叫箱排序。桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。 </p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-d3e2e9d08a403961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)，每个元素占一个桶</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + bn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本程序用数组模拟桶 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bn = <span class="number">5</span>;    <span class="comment">// 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量</span></span><br><span class="line"><span class="keyword">int</span> C[bn];           <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++)  <span class="comment">// 从第二张牌开始抓，直到最后一张牌</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; A[j] &gt; get)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">10</span>;    <span class="comment">// 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)     <span class="comment">// 使C[i]保存着i号桶中元素的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[MapToBucket(A[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bn; i++)    <span class="comment">// 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = MapToBucket(A[i]);  <span class="comment">// 元素A[i]位于b号桶</span></span><br><span class="line">        B[--C[b]] = A[i];           <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                    <span class="comment">// 桶的边界被更新：C[b]为b号桶第一个元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CountingSort(A, n);          <span class="comment">// 利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++) <span class="comment">// 对每一个桶中的元素应用插入排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = C[i];         <span class="comment">// C[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (i == bn - <span class="number">1</span> ? n - <span class="number">1</span> : C[i + <span class="number">1</span>] - <span class="number">1</span>);<span class="comment">// C[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)        <span class="comment">// 对元素个数大于1的桶进行桶内插入排序</span></span><br><span class="line">InsertionSort(A, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">29</span>, <span class="number">25</span>, <span class="number">3</span>, <span class="number">49</span>, <span class="number">9</span>, <span class="number">37</span>, <span class="number">21</span>, <span class="number">43</span> &#125;;<span class="comment">// 针对桶排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    BucketSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"桶排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1e18e317393c2f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。 </p><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>​    桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>​    基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe46e1ab43534fd1.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n * dn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dn = <span class="number">3</span>;                <span class="comment">// 待排序的元素为三位数及以下</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;                <span class="comment">// 基数为10，每一位的数字都是[0,9]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span>          <span class="comment">// 获得元素x的第d位数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span> &#125;;<span class="comment">// 最大为三位数，所以这里只要到百位就满足了</span></span><br><span class="line">    <span class="keyword">return</span> (x / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> d)</span><span class="comment">// 依据元素的第d位数字，对A数组进行计数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[GetDigit(A[i], d)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dight = GetDigit(A[i], d);  <span class="comment">// 元素A[i]当前位数字为dight   </span></span><br><span class="line">        B[--C[dight]] = A[i];           <span class="comment">// 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">        <span class="comment">// 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LsdRadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>     <span class="comment">// 最低位优先基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; d++)     <span class="comment">// 从低位到高位</span></span><br><span class="line">    CountingSort(A, n, d);        <span class="comment">// 依据第d位数字对A进行计数排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">20</span>, <span class="number">90</span>, <span class="number">64</span>, <span class="number">289</span>, <span class="number">998</span>, <span class="number">365</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">789</span>, <span class="number">456</span> &#125;;<span class="comment">// 针对基数排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    LsdRadixSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"基数排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程<br><img src="https://upload-images.jianshu.io/upload_images/12654931-463067e0a4b82c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。</p><p>　　如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。</p><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>​    基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>​    基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0、算法概述&quot;&gt;&lt;a href=&quot;#0、算法概述&quot; class=&quot;headerlink&quot; title=&quot;0、算法概述&quot;&gt;&lt;/a&gt;0、算法概述&lt;/h3&gt;&lt;h4 id=&quot;0-1-算法分类&quot;&gt;&lt;a href=&quot;#0-1-算法分类&quot; class=&quot;headerlink&quot; title=&quot;0.1 算法分类&quot;&gt;&lt;/a&gt;0.1 算法分类&lt;/h4&gt;&lt;p&gt;①：十种常见排序算法可以分为两大类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;非线性时间比较类排序&lt;/strong&gt;：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性时间非比较类排序&lt;/strong&gt;：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（一）：二维数组中的查找</title>
    <link href="http://yoursite.com/2018/07/12/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/07/12/剑指Offer（一）：二维数组中的查找/</id>
    <published>2018-07-12T13:10:43.000Z</published>
    <updated>2018-08-27T01:47:10.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer（一）：二维数组中的查找"><a href="#剑指Offer（一）：二维数组中的查找" class="headerlink" title="剑指Offer（一）：二维数组中的查找"></a>剑指Offer（一）：二维数组中的查找</h1><p>摘要</p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>​    首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><p>如果在一个二维数组中找到数字7，则返回true，如果没有找到，则返回false。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-e1ac5d9f3a6d3567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>查找过程如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-43cb8ecc339b728c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3、编程实现"><a href="#3、编程实现" class="headerlink" title="3、编程实现"></a>3、编程实现</h3><p><strong>C++：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* 04 二维数组中的查找*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    bool fun(vector&lt;vector&lt;int&gt;&gt; arr,int target)</span><br><span class="line">    &#123;</span><br><span class="line">        // 特殊输入</span><br><span class="line">        if(!arr.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            // 行列个数</span><br><span class="line">            int row = arr.size();</span><br><span class="line">            int col = arr[0].size();</span><br><span class="line"> </span><br><span class="line">            // 右上角坐标</span><br><span class="line">            int a = 0;</span><br><span class="line">            int b = col-1;</span><br><span class="line"> </span><br><span class="line">            while(a&lt;row &amp;&amp; b&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                // 找到</span><br><span class="line">                if(arr[a][b] == target)</span><br><span class="line">                    return true;</span><br><span class="line"> </span><br><span class="line">                // 未找到</span><br><span class="line">                if(arr[a][b] &lt; target)</span><br><span class="line">                    ++a;</span><br><span class="line">                else</span><br><span class="line">                    --b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"> </span><br><span class="line">    // 特殊输入</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; arr1;</span><br><span class="line">    int target1 = 11;</span><br><span class="line">    cout&lt;&lt;solution.fun(arr1,target1)&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    // 正常输入</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; arr2 = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;;</span><br><span class="line">    int target2 = 11;</span><br><span class="line">    cout&lt;&lt;solution.fun(arr2,target2)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Python2.7：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> rows &gt; <span class="number">0</span> <span class="keyword">and</span> cols &gt; <span class="number">0</span>:</span><br><span class="line">            row = <span class="number">0</span></span><br><span class="line">            col = cols - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> target == array[row][col]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer（一）：二维数组中的查找&quot;&gt;&lt;a href=&quot;#剑指Offer（一）：二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer（一）：二维数组中的查找&quot;&gt;&lt;/a&gt;剑指Offer（一）：二维数组中的查找&lt;/h1&gt;&lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>理解朴素贝叶斯</title>
    <link href="http://yoursite.com/2018/07/06/%E7%90%86%E8%A7%A3%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://yoursite.com/2018/07/06/理解朴素贝叶斯/</id>
    <published>2018-07-06T03:08:42.000Z</published>
    <updated>2018-07-06T03:26:01.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解朴素贝叶斯"><a href="#理解朴素贝叶斯" class="headerlink" title="理解朴素贝叶斯"></a>理解朴素贝叶斯</h1><h4 id="（1）先验概率、后验概率、联合概率、全概率"><a href="#（1）先验概率、后验概率、联合概率、全概率" class="headerlink" title="（1）先验概率、后验概率、联合概率、全概率"></a>（1）<strong>先验概率、后验概率、联合概率、全概率</strong></h4><p>如果我对这个西瓜<strong>没有任何了解</strong>，包括瓜的颜色、形状、瓜蒂是否脱落。按常理来说，西瓜成熟的概率大概是 60%。那么，这个概率 P(瓜熟) 就被称为<strong>先验概率</strong>。</p><p>即，<strong>先验概率</strong>是<strong>根据以往经验和分析得到的概率，先验概率无需样本数据，不受任何条件的影响。</strong>就像<strong>只根据常识而不根据西瓜状态来判断西瓜是否熟，这就是先验概率</strong>。</p><p>一个判断西瓜是否成熟的常识，就是看瓜蒂是否脱落。一般来说，瓜蒂脱落的情况下，西瓜成熟的概率大一些，大概是 75%。如果<strong>把瓜蒂脱落当作一种结果，然后去推测西瓜成熟的概率</strong>，这个概率 P(瓜熟 | 瓜蒂脱落) 就被称为<strong>后验概率</strong>。后验概率类似于<strong>条件概率</strong>。</p><p>知道了先验概率和后验概率，我们再来看看什么是联合概率。<strong>P(瓜熟，瓜蒂脱落)</strong> 称之为<strong>联合分布</strong>，它表示<strong>瓜熟了且瓜蒂脱落的概率</strong>。关于联合概率，满足下列乘法等式：</p><a id="more"></a><p><strong>P(瓜熟，瓜蒂脱落)</strong> <strong>=</strong> <strong>P(瓜熟**</strong>|<strong>瓜蒂脱落)**</strong>·<strong>P(瓜蒂脱落)</strong>=<strong>P(瓜蒂脱落</strong>|<strong>瓜熟)</strong>·<strong>P(瓜熟)</strong></p><p>其中，P(瓜熟 | 瓜蒂脱落) 就是刚刚介绍的后验概率，表示在“瓜蒂脱落”的条件下，“瓜熟”的概率。P(瓜蒂脱落 | 瓜熟) 表示在“瓜熟”的情况下，“瓜蒂脱落”的概率。</p><p>如何计算瓜蒂脱落的概率呢？实际上可以分成两种情况：一种是<strong>瓜熟状态下瓜蒂脱落的概率</strong>，<strong>另一种是瓜生状态下瓜蒂脱落的概率</strong>。瓜蒂脱落的概率就是这两种情况之和。因此，我们就推导出了<strong>全概率公式</strong>：</p><p><strong>P(瓜蒂脱落)=P(瓜蒂脱落|瓜熟)·P(瓜熟)+P(瓜蒂脱落|瓜生)·P(瓜生)</strong></p><h4 id="（2）单个特征判断瓜熟"><a href="#（2）单个特征判断瓜熟" class="headerlink" title="（2）单个特征判断瓜熟"></a><strong>（2）单个特征判断瓜熟</strong></h4><p>好了，介绍完先验概率、后验概率、联合概率、全概率后，我们来看这样一个问题：西瓜的状态分成两种：瓜熟与瓜生，概率分别为 0.6 与 0.4，且瓜熟里面瓜蒂脱落的概率是 0.8，瓜生里面瓜蒂脱落的概率是 0.4。那么，如果我现在挑到了一个瓜蒂脱落的瓜，则该瓜是好瓜的概率多大？</p><p>显然，这是一个计算后验概率的问题，根据我们上面推导的联合概率和全概率公式，可以求出：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-582ca247f1f19977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一项一项来看：</p><p>条件概率 P(瓜蒂脱落 | 瓜熟) = 0.8</p><p>先验概率 P(瓜熟) = 0.6</p><p>条件概率 P(瓜蒂脱落 | 瓜生) = 0.4</p><p>先验概率 P(瓜生) = 0.4</p><p>将以上数值带入上式，得：<img src="https://upload-images.jianshu.io/upload_images/12654931-8e483547745003f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>注意，以上这种计算后验概率的公式就是利用贝叶斯定理。</p><h4 id="（3）多个特征判断瓜熟"><a href="#（3）多个特征判断瓜熟" class="headerlink" title="（3）多个特征判断瓜熟"></a><strong>（3）多个特征判断瓜熟</strong></h4><p>判断一个瓜是否熟了，除了要看瓜蒂是否脱落，还要看瓜的形状和颜色。形状有圆和尖之分，颜色有深绿、浅绿、青色之分。我们可以使用刚刚引入的贝叶斯定理思想来尝试解决这个问题。</p><p>现在，特征由原来的 1 个，变成现在的 3 个，我们用 X 表示特征，用 Y 表示瓜的类型（瓜熟还是瓜生）。则根据贝叶斯定理，后验概率 P(Y=ck | X=x) 的表达式为：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5cb90b8151c454a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>其中，ck 表示类别，k 为类别个数。本例中，k = 1，2，c1 表示瓜熟，c2 表示瓜生。上面的公式看似有点复杂，但其实与上一节单特征（瓜蒂是否脱落）的形式是一致的。</p><p>有一点需要注意，这里的特征 X 不再是单一的，而是包含了 3 个特征。因此，<strong>条件概率 P(X=x | Y=ck) 假设各个条件相互独立</strong>，也就是说<strong>假设不同特征之间是相互独立的</strong>。这样，P(X=x | Y=ck) 就可以写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-040af2fa8ac84376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>其中，n 为特征个数，j 表示当前所属特征。针对这个例子，P(X=x | Y=ck) 可以写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-4801526d4c60a531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>这种<strong>条件独立性的假设</strong>就是朴素贝叶斯法“<strong>朴素</strong>”二字的由来。<strong>这一假设让朴素贝叶斯法变得简单，但是有时候会牺牲一定的分类准确率</strong>。</p><p>​    利用朴素贝叶斯思想，我们就可以把后验概率写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-44bce97a4ade7d80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img">    上面的公式看上去比较复杂，其实只是<strong>样本特征增加</strong>了，形式上与上一节 P(瓜熟 | 瓜蒂脱落) 是一致的。</p><p>现在，一个西瓜，观察了它的瓜蒂、形状、颜色三个特征，就能根据上面的朴素贝叶斯公式，分别计算 c1（瓜熟）和 c2（瓜生）的概率，即 P(Y=c1 | X=x) 和 P(Y=c2 | X=x)。然后再比较 P(Y=c1 | X=x) 和 P(Y=c2 | X=x) 值的大小：</p><p>若 P(Y=c1 | X=x) &gt; P(Y=c2 | X=x)，则判断瓜熟；</p><p>若 P(Y=c1 | X=x) &lt; P(Y=c2 | X=x)，则判断瓜生。</p><p>值得注意的是上式中的分母部分，对于所有的 ck 来说，都是一样的。因此，分母可以省略，不同的 ck，仅比较 P(Y=ck | X=x) 的分子即可：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-57b7db79a57f0c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="（2）朴素贝叶斯分类"><a href="#（2）朴素贝叶斯分类" class="headerlink" title="（2）朴素贝叶斯分类"></a>（2）<strong>朴素贝叶斯分类</strong></h4><p>买瓜之前，还有一件事情要做，就是搜集样本数据。通过网上资料和查阅，获得了一组包含 10 组样本的数据。这组数据是不同瓜蒂、形状、颜色对应的西瓜是生是熟。我把这组数据当成是历史经验数据，以它为标准。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-8b395ed221dac1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"> </p><p>其中，瓜蒂分为脱落和未脱，形状分为圆形和尖形，颜色分为深绿、浅绿、青色。不同特征组合对应着瓜熟或者瓜生。</p><p>现在，挑了一个西瓜，它的瓜蒂脱落、形状圆形、颜色青色。这时候，就完全可以根据<strong>样本数据</strong>和<strong>朴素贝叶斯法</strong>来计算后验概率。</p><p>首先，对于瓜熟的情况：</p><p>瓜熟的先验概率： P(瓜熟) = 6 / 10 = 0.6。</p><p>条件概率： P(脱落 | 瓜熟) = 4 / 6 = 2 / 3。</p><p>条件概率： P(圆形 | 瓜熟) = 4 / 6 = 2 / 3。</p><p>条件概率： P(青色 | 瓜熟) = 2 / 6 = 1 / 3。</p><p>计算<strong>后验概率分子部分</strong>：P(瓜熟) × P(脱落 | 瓜熟) × P(圆形 | 瓜熟) × P(青色 | 瓜熟) = 0.6 × (2 / 3) × (2 / 3) × (1 / 3) = 4 / 45。</p><p>然后，对于瓜生的情况：</p><p>瓜生的先验概率： P(瓜生) = 4 / 10 = 0.4。</p><p>条件概率： P(脱落 | 瓜生) = 1 / 4 = 0.25。</p><p>条件概率： P(圆形 | 瓜生) = 1 / 4 = 0.25。</p><p>条件概率： P(青色 | 瓜生) = 1 / 4 = 0.25。</p><p>计算<strong>后验概率分子部分</strong>：P(瓜生) × P(脱落 | 瓜生) × P(圆形 | 瓜生) × P(青色 | 瓜生) = 0.4 × 0.25 × 0.25 × 0.25 = 1 / 160。</p><p>因为 4 / 45 &gt; 1 / 160，所以预测为瓜熟。终于计算完了，很肯定这个西瓜瓜蒂脱落、形状圆形、颜色青色，应该是熟瓜。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;理解朴素贝叶斯&quot;&gt;&lt;a href=&quot;#理解朴素贝叶斯&quot; class=&quot;headerlink&quot; title=&quot;理解朴素贝叶斯&quot;&gt;&lt;/a&gt;理解朴素贝叶斯&lt;/h1&gt;&lt;h4 id=&quot;（1）先验概率、后验概率、联合概率、全概率&quot;&gt;&lt;a href=&quot;#（1）先验概率、后验概率、联合概率、全概率&quot; class=&quot;headerlink&quot; title=&quot;（1）先验概率、后验概率、联合概率、全概率&quot;&gt;&lt;/a&gt;（1）&lt;strong&gt;先验概率、后验概率、联合概率、全概率&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;如果我对这个西瓜&lt;strong&gt;没有任何了解&lt;/strong&gt;，包括瓜的颜色、形状、瓜蒂是否脱落。按常理来说，西瓜成熟的概率大概是 60%。那么，这个概率 P(瓜熟) 就被称为&lt;strong&gt;先验概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即，&lt;strong&gt;先验概率&lt;/strong&gt;是&lt;strong&gt;根据以往经验和分析得到的概率，先验概率无需样本数据，不受任何条件的影响。&lt;/strong&gt;就像&lt;strong&gt;只根据常识而不根据西瓜状态来判断西瓜是否熟，这就是先验概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个判断西瓜是否成熟的常识，就是看瓜蒂是否脱落。一般来说，瓜蒂脱落的情况下，西瓜成熟的概率大一些，大概是 75%。如果&lt;strong&gt;把瓜蒂脱落当作一种结果，然后去推测西瓜成熟的概率&lt;/strong&gt;，这个概率 P(瓜熟 | 瓜蒂脱落) 就被称为&lt;strong&gt;后验概率&lt;/strong&gt;。后验概率类似于&lt;strong&gt;条件概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;知道了先验概率和后验概率，我们再来看看什么是联合概率。&lt;strong&gt;P(瓜熟，瓜蒂脱落)&lt;/strong&gt; 称之为&lt;strong&gt;联合分布&lt;/strong&gt;，它表示&lt;strong&gt;瓜熟了且瓜蒂脱落的概率&lt;/strong&gt;。关于联合概率，满足下列乘法等式：&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="朴素贝叶斯" scheme="http://yoursite.com/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="西瓜书" scheme="http://yoursite.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>域名解析</title>
    <link href="http://yoursite.com/2018/07/03/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/03/域名解析/</id>
    <published>2018-07-03T07:42:39.000Z</published>
    <updated>2018-07-03T08:02:59.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>域名有钱最好买.com的，不要买.cn的，我自己买的.cn的好多坑，.top的相对就比较便宜（low）。</p><p>此次在腾讯云买的dadavision.cn。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-7be4ec62010a4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p><p>之前.cn的一直要我备案，否则DNS解析不了，而且还证书审核失败。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5de7c90ec35f4b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3a445764853e3128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在github项目的setting里面设置域名</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6e54ef27bfdb1bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>添加域名解析</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-19d33afeda8ecd28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里注意</p><p>在添加绑定域名后需要注意以下问题（未绑定可以不用）</p><p>需要将github上CNAME里面内容在文件工程中GitBlog\source\CNAME</p><p>这里注意新建的CNAME不要有后缀名。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3eb1866b15f4f46d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2c825d1db371b855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;域名解析&quot;&gt;&lt;a href=&quot;#域名解析&quot; class=&quot;headerlink&quot; title=&quot;域名解析&quot;&gt;&lt;/a&gt;域名解析&lt;/h1&gt;&lt;p&gt;域名有钱最好买.com的，不要买.cn的，我自己买的.cn的好多坑，.top的相对就比较便宜（low）。&lt;/p&gt;
&lt;p&gt;此次在腾讯云买的dadavision.cn。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12654931-7be4ec62010a4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="域名解析" scheme="http://yoursite.com/categories/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="域名" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="域名解析" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
