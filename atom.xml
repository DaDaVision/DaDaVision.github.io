<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaDaVision</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-23T12:47:49.145Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tengda Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见查找算法总结</title>
    <link href="http://yoursite.com/2018/08/22/%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/22/常见查找算法总结/</id>
    <published>2018-08-22T02:04:59.000Z</published>
    <updated>2018-08-23T12:47:49.145Z</updated>
    
    <content type="html"><![CDATA[<p>阅读目录</p><ol><li>顺序查找</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li><li>树表查找</li><li>分块查找</li><li>哈希查找</li></ol><a id="more"></a><p>​    查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。</p><p>　　<strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><p>　　<strong>查找算法分类：</strong></p><p>　　1）静态查找和动态查找；</p><p>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</p><p>　　2）无序查找和有序查找。</p><p>　　　　无序查找：被查找数列有序无序均可；</p><p>　　　　有序查找：被查找数列必须为有序数列。</p><p>　　<strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>　　Pi：查找表中第i个数据元素的概率。<br>　　Ci：找到第i个数据元素时已经比较过的次数。</p><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p>　　<strong>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</strong></p><p>　　<strong>基本思想：</strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p>　　<strong>复杂度分析：</strong>　</p><p>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p><p>　　所以，<strong>顺序查找的时间复杂度为O(n)。</strong></p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequence_Search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sequence_Search</span><span class="params">(nums, target)</span>:</span>   </span><br><span class="line">     <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):     </span><br><span class="line">        <span class="keyword">if</span> nums[i]==target:          </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="2-二分查找-折半查找"><a href="#2-二分查找-折半查找" class="headerlink" title="2. 二分查找/折半查找"></a>2. 二分查找/折半查找</h3><p>　　<strong>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p><p>　　<strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p>　　<strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且<strong>期望时间复杂度为O(log2n)</strong>；</p><p>　　注：<strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要</strong>频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找（折半查找），非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2） python版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----------------递归二分查找------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_Search</span><span class="params">(nums,target,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    mid=(left+right)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="keyword">return</span> binary_Search(nums, target, left, mid<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> binary_Search(nums, target, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    low=<span class="number">0</span></span><br><span class="line">    high=len(list)<span class="number">-1</span></span><br><span class="line">    result = binary_Search(list,<span class="number">444</span>,low,high)</span><br><span class="line">    print(result)</span><br><span class="line"><span class="comment">#-------------------非递归查找------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_Search</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low+high)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    result = binary_Search(list,<span class="number">444</span>)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure></p><p>​    时间复杂度分析    最坏情况下，关键词比较次数为⌊log2n⌋+1，最好情况就是1，所以二分查找的时间复杂度为O(logn)。它显然好于顺序查找的O(n)。 </p><h3 id="3-插值查找"><a href="#3-插值查找" class="headerlink" title="3. 插值查找"></a>3. 插值查找</h3><p>　　在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p><p>　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p><p>　　同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p><p>　　经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p><p>　　mid=(low+high)/2, 即mid=low+1/2*(high-low);</p><p>　　通过类比，我们可以将查找的点改进为如下：</p><p>　　mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，</p><p>　　也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p><p>　　<strong>基本思想：</strong>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p><p>　　注：<strong>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</strong></p><p>　　<strong>复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</strong></p><p>（1） C++实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）python代码 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插值查找算法</span></span><br><span class="line"><span class="comment"># 时间复杂度O(log(n))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_search</span><span class="params">(lis, key)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(lis) - <span class="number">1</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        time += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">        mid = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">        print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (mid, low, high))</span><br><span class="line">        <span class="keyword">if</span> key &lt; lis[mid]:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &gt; lis[mid]:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 打印查找的次数</span></span><br><span class="line">            print(<span class="string">"times: %s"</span> % time)</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    print(<span class="string">"times: %s"</span> % time)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">    result = insert_search(LIST, <span class="number">444</span>)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>​    时间复杂度分析    </p><p>​    它的时间复杂度跟二分查找的时间复杂度一样，为O(logn)。需要注意的是对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 </p><h3 id="4-斐波那契查找"><a href="#4-斐波那契查找" class="headerlink" title="4. 斐波那契查找"></a>4. 斐波那契查找</h3><p>　　在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</p><p>　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p><p>　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</p><p>　　大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b0cb1d3f2022502c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>基本思想：</strong>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p><p>　　相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1;</p><p>​    3）&lt;，high=mid-1。</p><p>　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p><p> 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p><p>　　1）相等，mid位置的元素即为所求</p><p>　　2）&gt;，low=mid+1,k-=2;</p><p>　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</p><p>　　3）&lt;，high=mid-1,k-=1。</p><p>　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p><p>　　<strong>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</strong></p><p>（1）C++实现 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契查找</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> * F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> F[max_size];</span><br><span class="line">  Fibonacci(F);<span class="comment">//构造一个斐波那契数组F </span></span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">      ++k;</span><br><span class="line">  <span class="keyword">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></span><br><span class="line">  temp=<span class="keyword">new</span> <span class="keyword">int</span> [F[k]<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</span><br><span class="line">     temp[i]=a[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid<span class="number">-1</span>;</span><br><span class="line">      k-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+<span class="number">1</span>;</span><br><span class="line">     k-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(mid&lt;n)</span><br><span class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">delete</span> [] temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> index=FibonacciSearch(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),key);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">" is located at:"</span>&lt;&lt;index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#source为待查找数组，key为要查找的数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacciSearch</span><span class="params">(source,key)</span>:</span></span><br><span class="line">    <span class="comment">#生成裴波那契数列</span></span><br><span class="line">    fib = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">36</span>):</span><br><span class="line">        fib.append(fib[<span class="number">-1</span>]+fib[<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#确定待查找数组在裴波那契数列的位置</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    n = len(source)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#此处 n&gt;fib[k]-1 也是别有深意的</span></span><br><span class="line">    <span class="comment">#若n恰好是裴波那契数列上某一项，且要查找的元素正好在最后一位，此时必须将数组长度填充到数列下一项的数字</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; fib[k]<span class="number">-1</span>):</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="comment">#将待查找数组填充到指定的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n,fib[k]):</span><br><span class="line">        a.append(a[<span class="number">-1</span>])</span><br><span class="line">    low,high = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">        <span class="comment">#获取黄金分割位置元素下标</span></span><br><span class="line">        mid = low + fib[k<span class="number">-1</span>] - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span>(key &lt; a[mid]):</span><br><span class="line">            <span class="comment">#若key比这个元素小,则key值应该在low至mid-1之间，剩下的范围个数为F(k-1)-1</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">            k = k <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span>(key &gt; a[mid]):</span><br><span class="line">            <span class="comment">#若key比这个元素大,则key至应该在mid+1至high之间，剩下的元素个数为F(k)-F(k-1)-1=F(k-2)-1</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">            k = k - <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; n):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 函数测试 ###</span></span><br><span class="line"><span class="comment">#生成待查找的数组</span></span><br><span class="line">a = [random.randint(<span class="number">1</span>,<span class="number">100000</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">33</span>)]</span><br><span class="line">a.append(<span class="number">673990</span>)</span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment">#待查找的数</span></span><br><span class="line">key = <span class="number">673990</span></span><br><span class="line"><span class="comment">#输出查找到的位置下标</span></span><br><span class="line">print(fibonacciSearch(a,key))</span><br></pre></td></tr></table></figure></p><p> 时间复杂度分析    </p><p>​    斐波那契查找的整体时间复杂度也为O(log(n))。但就平均性能，要优于二分查找。但是在最坏情况下，比如这里如果key为1，则始终处于左侧半区查找，此时其效率要低于二分查找。 </p><ul><li><p><strong>总结  </strong>  </p><p>​    二分查找的mid运算是加法与除法，插值查找则是复杂的四则运算，而斐波那契查找只是最简单的加减运算。在海量数据的查找中，这种细微的差别可能会影响最终的查找效率。因此，三种有序表的查找方法本质上是分割点的选择不同，各有优劣，应根据实际情况进行选择。 </p></li></ul><h3 id="5-树表查找"><a href="#5-树表查找" class="headerlink" title="5. 树表查找"></a><strong>5. 树表查找</strong></h3><h3 id="6-线性索引查找"><a href="#6-线性索引查找" class="headerlink" title="6. 线性索引查找"></a><strong>6. 线性索引查找</strong></h3><p><strong>6.1 简介</strong>    </p><p>​    前面讲的几种比较高效的查找方法是基于有序的基础之上的，而事实上，数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据都是按先后顺序存储的。    </p><p>​    对于这样的查找表，我们如何能够快速查找到需要的数据呢？常常使用的方法就是—-<strong>索引</strong>。<strong>索引是为了加快查找速度而设计的一种数据结构。</strong>它是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。    </p><p>​    索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三个线性索引：稠密索引、分块索引、和倒排索引。 </p><p><strong>6.2 稠密索引 </strong></p><p>​    稠密索引如下图所示，它是指在线性索引中，将数据集中的每个记录对应一个索引项。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b3fda93316d6cb9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    上图中，左边的图像为索引序列，它是是按照关键码有序排列的。索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高效率。比如查找上表中的18。如果不用索引表，需要6次。而用左侧的索引表，折半两次就可以找到18对应的指针。    </p><p>​    这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。  </p><p><strong>6.3 分块索引 </strong>   </p><p>​    稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引的个数，我们可以<strong>对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 </strong></p><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 　　</p><p><strong>算法思想：</strong>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 　　</p><p><strong>算法流程：</strong> 　　<br>step1 先选取各块中的最大关键字构成一个索引表； 　　<br>step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><p>​    分块有序，是把数据集的记录分成若干块，并且这些块需要满足两个条件：    </p><p>​    （1）块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间代价，因此通常我们不要求块内有序    <br>​    （2）块间有序，例如要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字….因为只有块间有序，才有可能在查找时带来效率。   <br> <br>    对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。我们定义的分块索引项由三个数据项组成，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-639d103f90fa4d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    这三个数据项分别为最大关键码（它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中最小关键字也能比这一块最大的关键字要大）、存储了块中的记录个数（以便于循环时使用）和指向块首数据元素的指针（便于开始对这一块中的记录进行遍历）。   </p><p>​    由上面的分析我们可以大概明白分块索引的步骤：    </p><p>​    （1）在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。    </p><p>​    （2） 根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查获。  </p><p><strong>6.4 倒排索引 </strong></p><p>​    不知道你对搜索引擎好奇过没，无论你查找什么样的信息，它都可以在极短的时间内给你一些结果，是什么算法技术达到这样的高效查找呢？这里介绍一种最基础的搜索技术—-倒排索引。    </p><p>​    我们来看一个例子，假设有以下两篇文章：    </p><p>​    (1) Books and friends should be few but good .    </p><p>​    (2) A good book is a good friend.    </p><p>​    假设我们忽略掉如“books”，“friends”中的复数”s”以及如“A”这样的大小写差异。我们可以整理出这样一张单词表，如下图所示，并将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中，比如“good”它在两篇文章中都有出现，而is只有在文章2中才有。  </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6a8b0164b26616ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    在这里这张单词表就是索引表，索引项的通用结构是次关键码和记录号表。 其中记录号表存储具有相同次字关键字的所有记录的记录号（可以指向记录的指针或者是该记录的主关键字）。因为这种查找方法是通过属性值来确定记录的位置，而不是通过记录来确定属性值，所以我们称其为倒排索引。 </p><p>​    </p><h3 id="7-哈希查找"><a href="#7-哈希查找" class="headerlink" title="7. 哈希查找"></a>7. 哈希查找</h3><p>　　<strong>什么是哈希表（Hash）？</strong></p><p>​    散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>    给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>    中文名  哈希表 </p><p>​    外文名  Hash table </p><p>​    别    名 散列表 </p><p>​    作    用  直接进行访问的数据结构</p><p>　　我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f71ff9ef346899db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　<strong>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</strong></p><p>　　<strong>什么是哈希函数？</strong></p><p>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p><p>　　<strong>算法思想：</strong>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><p>　　<strong>算法流程：</strong></p><p>　　1）用给定的哈希函数构造哈希表；</p><p>　　2）根据选择的冲突处理方法解决地址冲突；</p><p>　　　　常见的解决冲突的方法：拉链法和线性探测法。</p><p>　　3）在哈希表的基础上执行哈希查找。</p><p>　　<strong>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</strong></p><p>　　<strong>复杂度分析</strong>：</p><p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><p>　　<strong>使用Hash，我们付出了什么？</strong><br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV(key value) pair，经常使用Python可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？</p><p>　　Hash是一种典型<strong>以空间换时间</strong>的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p><p>　　Hash算法和其他查找算法的性能对比：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-4fad334deb8aaa01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序查找&lt;/li&gt;
&lt;li&gt;二分查找&lt;/li&gt;
&lt;li&gt;插值查找&lt;/li&gt;
&lt;li&gt;斐波那契查找&lt;/li&gt;
&lt;li&gt;树表查找&lt;/li&gt;
&lt;li&gt;分块查找&lt;/li&gt;
&lt;li&gt;哈希查找&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="查找算法" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>10大经典排序算法总结</title>
    <link href="http://yoursite.com/2018/08/21/10%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/21/10大经典排序算法总结/</id>
    <published>2018-08-21T07:11:36.000Z</published>
    <updated>2018-08-22T02:05:12.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h3><h4 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h4><p>①：十种常见排序算法可以分为两大类：</p><blockquote><p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d74f1bf29b3a2413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></blockquote><p>②：另外一种分类排序方法——我们通常所说的排序算法往往指的是<strong>内部排序算法</strong>，即数据记录在内存中进行排序。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-006deb9355dbd7e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　排序算法大体可分为两种：</p><p>　　　　一种是<strong>比较排序</strong>，时间复杂度O(nlogn) ~ O(n^2)，主要有：<strong>冒泡排序</strong>，<strong>选择排序</strong>，<strong>插入排序</strong>，<strong>归并排序</strong>，<strong>堆排序</strong>，<strong>快速排序</strong>等。</p><p>　　　　另一种是<strong>非比较排序</strong>，时间复杂度可以达到O(n)，主要有：<strong>计数排序</strong>，<strong>基数排序</strong>，<strong>桶排序</strong>等。</p><h4 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fc56705ae801148b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h4><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p><p><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p></blockquote><p>​    </p><p>​    对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p><p>　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p><p>　　其次，说一下排序算法稳定性的好处。<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</strong>基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p><h4 id="0-4-技巧"><a href="#0-4-技巧" class="headerlink" title="0.4 技巧"></a>0.4 技巧</h4><p>记忆<strong>口诀</strong>：</p><p><strong>不稳定</strong>排序算法口诀：<strong>快些选队（快希选堆）</strong><br>其余为稳定的。</p><p><strong>算法复杂度和关键字顺序无关的有：</strong></p><p>顺口溜：<strong>一堆</strong>（堆排序）<strong>海龟</strong>（归并排序）<strong>选</strong>（选择排序）<strong>基</strong>（基数排序）<strong>友</strong></p><p>快些以 nlog2 n  的速度归队</p><p>快=快速排序，些=希尔排序，归=归并排序，队=堆排序</p><p>这四种排序算法，时间都是 n log2 n 的，除了这四个之外，其他的排序算法平均时间都为 n^2</p><blockquote><p>一趟排序，保证一个元素为最终位置的有两类排序算法：<strong>交换</strong>类（冒泡和快速）排序和<strong>选择</strong>类排序（简单和堆）</p><p>元素比较次数和<strong>原始序列无关</strong>的算法：<strong>简单选择</strong>排序，<strong>折半插入</strong>排序</p><p>排序趟数和原序列有关的算法：<strong>交换类</strong>，其余类无关</p><p>借助于比较进行排序的算法，在最坏的时候，最好的时间复杂度为 n log2 n</p><p>堆排序和简单选择排序的时间复杂度和初始序列无关</p></blockquote><h4 id="0-5-总结："><a href="#0-5-总结：" class="headerlink" title="0.5 总结："></a>0.5 总结：</h4><p>（1）在比较类排序中，<strong>归并排序</strong>号称最快，其次是<strong>快速排序</strong>和<strong>堆排序</strong>，两者不相伯仲，但是有一点需要注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。</p><p>（2）<strong>线性时间非比较类排序</strong>一般要优于非线性时间比较类排序，但前者对待排序元素的要求较为严格，比如计数排序要求待排序数的最大值不能太大，桶排序要求元素按照hash分桶后桶内元素的数量要均匀。线性时间非比较类排序的典型特点是以空间换时间。</p><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-b05dac2a52600907.gif?imageMogr2/auto-orient/strip" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-ee6aeca39cd369d7.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(RecordType arr[])</span> </span>&#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    change = TRUE;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; len - <span class="number">1</span> &amp;&amp; change; i++) &#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        <span class="keyword">for</span> (var j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;<span class="comment">// 依次比较相邻的两个元素,使较大的那个向后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j].key &gt; arr[j+<span class="number">1</span>].key) &#123; <span class="comment">// 相邻元素两两对比。  如果条件改成arr[j].key &gt;= arr[j+1].key,则变为不稳定的排序算法</span></span><br><span class="line">                var temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                change = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    假如说上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序，则实现过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-dfc34c06eb7f0c29.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    使用冒泡排序为一列数字进行排序的过程如右图所示:<img src="https://upload-images.jianshu.io/upload_images/12654931-561723951d8105b0.gif?imageMogr2/auto-orient/strip" alt=""></p><p>尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。</p><h3 id="1-1、冒泡排序的改进：鸡尾酒排序（定向-双向冒泡排序）"><a href="#1-1、冒泡排序的改进：鸡尾酒排序（定向-双向冒泡排序）" class="headerlink" title="1.1、冒泡排序的改进：鸡尾酒排序（定向/双向冒泡排序）"></a>1.1、冒泡排序的改进：鸡尾酒排序（定向/双向冒泡排序）</h3><p>​    鸡尾酒排序，也叫<strong>定向冒泡排序</strong>，是冒泡排序的一种改进，即排序过程中交替改变扫描方向。<br>    先从底向上冒一个最小元素，再从上向低冒一个最大元素。<br>    此算法与冒泡排序的不同处在于<strong>从低到高然后从高到低</strong>，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</p><p>　　鸡尾酒排序的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;    <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = TRUE;</span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = FLASE;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)   <span class="comment">// 前半轮,从左到右扫描，将最大元素放到最右边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i, i + <span class="number">1</span>);</span><br><span class="line">   flag = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--)   <span class="comment">// 后半轮,从右到左扫描,将最小元素放到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i - <span class="number">1</span>, i);</span><br><span class="line">                flag = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;   <span class="comment">// 从小到大定向冒泡排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    CocktailSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"鸡尾酒排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用鸡尾酒排序为一列数字进行排序的过程如右图所示：　<br><img src="https://upload-images.jianshu.io/upload_images/12654931-8f1eec1a3a56306b.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p><h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-d342a82e64a688f7.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)         <span class="comment">// i为已排序序列的末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)     <span class="comment">// 未排序序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])              <span class="comment">// 找出未排序序列中的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, min, i);    <span class="comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span> &#125;; <span class="comment">// 从小到大选择排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    SelectionSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"选择排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图:<img src="https://upload-images.jianshu.io/upload_images/12654931-5cb815f3948e9fac.gif?imageMogr2/auto-orient/strip" alt=""></p><p>使用选择排序为一列数字进行排序的宏观过程：　<img src="https://upload-images.jianshu.io/upload_images/12654931-d75968339d73d7f4.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</strong></p><p>　　比如序列：{ <strong>5</strong>, 8, <strong>5</strong>, <strong>2</strong>, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p><h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>​    插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。它的工作原理非常类似于我们抓扑克牌 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-6604e5ddad02bbb9.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p><p>　　插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-50e91fd39b1ef7b8.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)         <span class="comment">// 类似抓扑克牌排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 拿在左手上的牌总是排序好的</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)    <span class="comment">// 将抓到的牌与手牌从右向左进行比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];            <span class="comment">// 如果该手牌比抓到的牌大，就将其右移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get; <span class="comment">// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;<span class="comment">// 从小到大插入排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    InsertionSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下<br><img src="https://upload-images.jianshu.io/upload_images/12654931-877826e57ce08dd3.gif?imageMogr2/auto-orient/strip" alt="">　　　　</p><p>　　使用插入排序为一列数字进行排序的宏观过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-26ffc967098b75c3.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　插入排序<strong>不适合对于数据量比较大的排序应用</strong>。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p><h3 id="3-1、插入排序的改进：二分插入排序"><a href="#3-1、插入排序的改进：二分插入排序" class="headerlink" title="3.1、插入排序的改进：二分插入排序"></a>3.1、插入排序的改进：二分插入排序</h3><p>​    对于插入排序，如果比较操作的代价比交换操作大的话，可以采用<strong>二分查找法</strong>来减少比较操作的次数，我们称为<strong>二分插入排序</strong>，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                    <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;                <span class="comment">// 手牌左右边界进行初始化</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; get)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[left] = get;                    <span class="comment">// 将抓到的牌插入手牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大二分插入排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    InsertionSortDichotomy(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二分插入排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p><h3 id="4、希尔排序（Shell-Sort）-插入排序的更高效改进"><a href="#4、希尔排序（Shell-Sort）-插入排序的更高效改进" class="headerlink" title="4、希尔排序（Shell Sort）-插入排序的更高效改进"></a>4、希尔排序（Shell Sort）-插入排序的更高效改进</h3><p>​    1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>递减增量排序</strong>。希尔排序是<strong>不稳定</strong>的排序算法。 </p><p>​    希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-447cc5d14ac11f21.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-4d822a983a919056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= n)   <span class="comment">// 生成初始增量</span></span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - h;</span><br><span class="line">            <span class="keyword">int</span> get = A[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)</span><br><span class="line">            &#123;</span><br><span class="line">                A[j + h] = A[j];</span><br><span class="line">                j = j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + h] = get;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;   <span class="comment">// 递减增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    ShellSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"希尔排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>以23, 10, 4, 1的步长序列进行希尔排序：<img src="https://upload-images.jianshu.io/upload_images/12654931-b7107d90df31827c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>希尔排序是不稳定的排序算法，</strong>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。</p><p>　　比如序列：{ 3, 5, 10, <strong>8</strong>, 7, 2, <strong>8</strong>, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, <strong>8</strong>, 20 } 和  { 5, <strong>8</strong>, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, <strong>8</strong>, 10, 20 } 和 { 1, 2, 5, 6, <strong>8</strong> } ，即 { 3, 1, 7, 2, <strong>8</strong>, 5, 10, 6, 20, <strong>8</strong> } ，两个8的相对次序发生了改变。    </p><p>​    希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><p>​    归并排序的实现分为<strong>递归实现</strong>与<strong>非递归(迭代)实现</strong>。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。</p><p>　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，<strong>归并操作</strong>步骤如下：</p><ol><li><strong>申请空间</strong>，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2a2beb4de1e6acdd.gif?imageMogr2/auto-orient/strip" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5ab9457322e8103c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><span class="comment">// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];       <span class="comment">// 辅助空间O(n)</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left;                   <span class="comment">// 前一数组的起始元素</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;                <span class="comment">// 后一数组的起始元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++];  <span class="comment">// 带等号保证归并排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[left++] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursion</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>    <span class="comment">// 递归实现的归并排序(自顶向下)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right)    <span class="comment">// 当待排序的序列长度为1时，递归开始回溯，进行merge操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    MergeSortRecursion(A, left, mid);</span><br><span class="line">    MergeSortRecursion(A, mid + <span class="number">1</span>, right);</span><br><span class="line">    Merge(A, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span>    <span class="comment">// 非递归(迭代)实现的归并排序(自底向上)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, mid, right;<span class="comment">// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)        <span class="comment">// 子数组的大小i初始为1，每轮翻倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + i &lt; len)              <span class="comment">// 后一个子数组存在(需要归并)</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + i - <span class="number">1</span>;</span><br><span class="line">            right = mid + i &lt; len ? mid + i : len - <span class="number">1</span>;<span class="comment">// 后一个子数组大小可能不够</span></span><br><span class="line">            Merge(A, left, mid, right);</span><br><span class="line">            left = right + <span class="number">1</span>;               <span class="comment">// 前一个子数组索引向后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A1[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;      <span class="comment">// 从小到大归并排序</span></span><br><span class="line">    <span class="keyword">int</span> A2[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="keyword">sizeof</span>(A1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="keyword">sizeof</span>(A2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    MergeSortRecursion(A1, <span class="number">0</span>, n1 - <span class="number">1</span>);          <span class="comment">// 递归实现</span></span><br><span class="line">    MergeSortIteration(A2, n2);                 <span class="comment">// 非递归实现</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"递归实现的归并排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"非递归实现的归并排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下　<br><img src="https://upload-images.jianshu.io/upload_images/12654931-e11598fb16f7f974.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　使用归并排序为一列数字进行排序的宏观过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-7d7eedbdc4d069fb.gif?imageMogr2/auto-orient/strip" alt="">　　　</p><p>　　归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对。</p><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>​    快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>​    选择一个基准，小于放左边，大于放右边。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-36a8debf59ae72e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    上图是每次将基准交换。</p><p>​    或者如下，最后再将基准交换。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-911998967362a076.gif?imageMogr2/auto-orient/strip" alt=""></p><p>​    方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-b636bd935bdaad63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（<strong>请自己想一想为什么</strong>）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-ce981ae61870643f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-da606f1c2f2ff958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p><p>​    6  1  2  <strong>5</strong>  9 3  4  <strong>7</strong>  10  8<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f2d90739a4b43360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3ca3d01aacd4865f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p><p>6  1  2 5  <strong>4</strong>  3  <strong>9</strong>  7 10  8</p><p>​    第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：</p><p><strong>3</strong>  1 2  5  4  <strong>6</strong>  9 7  10  8</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe14873d59f52f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-546ac3dfcf16c905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-ab5bf0dbddeb3081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。 </p><p><strong>注：最好的是设置一个临时变量，做覆盖操作而不是一直做交换操作。</strong></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------ 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       </span></span><br><span class="line"><span class="comment">// 稳定性 ---------- 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  <span class="comment">// 划分函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[right];               <span class="comment">// 这里每次都选择最后一个元素作为基准</span></span><br><span class="line">    <span class="keyword">int</span> tail = left - <span class="number">1</span>;                <span class="comment">// tail为小于基准的子数组最后一个元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)  <span class="comment">// 遍历基准以外的其他元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= pivot)              <span class="comment">// 把小于等于基准的元素放到前一个子数组末尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, ++tail, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(A, tail + <span class="number">1</span>, right);           <span class="comment">// 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组</span></span><br><span class="line">                                        <span class="comment">// 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</span></span><br><span class="line">    <span class="keyword">return</span> tail + <span class="number">1</span>;                    <span class="comment">// 返回基准的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot_index = Partition(A, left, right); <span class="comment">// 基准的索引</span></span><br><span class="line">    QuickSort(A, left, pivot_index - <span class="number">1</span>);</span><br><span class="line">    QuickSort(A, pivot_index + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;; <span class="comment">// 从小到大快速排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"快速排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用快速排序法对一列数字进行排序的过程：<img src="https://upload-images.jianshu.io/upload_images/12654931-865ae2a394b9cdbe.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　<strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong></p><p>　　比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p><blockquote><p>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？</p></blockquote><p>　　答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 </p><h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>​    堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-c45011903132bb45.gif?imageMogr2/auto-orient/strip" alt=""></p><p><strong>构建初始堆</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-e4276f7e11ad285d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>整体排序流程</strong><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d926646825213d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span>  <span class="comment">// 从A[i]向下进行堆调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;         <span class="comment">// 左孩子索引</span></span><br><span class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;        <span class="comment">// 右孩子索引</span></span><br><span class="line">    <span class="keyword">int</span> max = i;                        <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max])</span><br><span class="line">        max = left_child;</span><br><span class="line">    <span class="keyword">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max])</span><br><span class="line">        max = right_child;</span><br><span class="line">    <span class="keyword">if</span> (max != i)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(A, i, max);                <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></span><br><span class="line">        Heapify(A, max, size);          <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>           <span class="comment">// 建堆，时间复杂度O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></span><br><span class="line">        Heapify(A, i, heap_size);</span><br><span class="line">    <span class="keyword">return</span> heap_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);    <span class="comment">// 建立一个最大堆</span></span><br><span class="line">    <span class="keyword">while</span> (heap_size &gt; <span class="number">1</span>)    　　　　　　 <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></span><br><span class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></span><br><span class="line">        Swap(A, <span class="number">0</span>, --heap_size);</span><br><span class="line">        Heapify(A, <span class="number">0</span>, heap_size);     <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> &#125;;<span class="comment">// 从小到大堆排序</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序算法的演示：<img src="https://upload-images.jianshu.io/upload_images/12654931-181d10fdf3848485.gif?imageMogr2/auto-orient/strip" alt=""></p><p>　　动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。</p><p>　　<strong>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</strong></p><p>　　比如序列：{ 9, <strong>5</strong>, 7, <strong>5</strong> }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { <strong>5</strong>, <strong>5</strong>, 7, 9 }，再进行堆调整得到{ 7, <strong>5</strong>, <strong>5</strong>, 9 }，重复之前的操作最后得到{ <strong>5</strong>, <strong>5</strong>, 7, 9 }从而改变了两个5的相对次序。</p><hr><p>以上为比较排序。</p><p>以下为非比较排序。</p><hr><h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>​    计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>​    通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-eca87818bb0a14c5.gif?imageMogr2/auto-orient/strip" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------ 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + k)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">100</span>;   <span class="comment">// 基数为100，排序[0,99]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];            <span class="comment">// 计数数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)   <span class="comment">// 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 使C[i]保存着等于i的元素个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)   <span class="comment">// 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">// 分配临时空间,长度为n，用来暂存中间数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        B[--C[A[i]]] = A[i];      <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                  <span class="comment">// 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 把临时空间B中的数据拷贝回A</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);    <span class="comment">// 释放临时空间 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">15</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">46</span>, <span class="number">27</span>, <span class="number">73</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">8</span> &#125;;  <span class="comment">// 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    CountingSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"计数排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此<strong>对于数据范围很大的数组，计数排序需要大量时间和内存。</strong></p><p>　　例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，<strong>将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。</strong></p><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>​    计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>​    桶排序也叫箱排序。桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。 </p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-d3e2e9d08a403961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)，每个元素占一个桶</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + bn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本程序用数组模拟桶 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bn = <span class="number">5</span>;    <span class="comment">// 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量</span></span><br><span class="line"><span class="keyword">int</span> C[bn];           <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++)  <span class="comment">// 从第二张牌开始抓，直到最后一张牌</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; A[j] &gt; get)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">10</span>;    <span class="comment">// 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)     <span class="comment">// 使C[i]保存着i号桶中元素的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[MapToBucket(A[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bn; i++)    <span class="comment">// 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = MapToBucket(A[i]);  <span class="comment">// 元素A[i]位于b号桶</span></span><br><span class="line">        B[--C[b]] = A[i];           <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                    <span class="comment">// 桶的边界被更新：C[b]为b号桶第一个元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CountingSort(A, n);          <span class="comment">// 利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++) <span class="comment">// 对每一个桶中的元素应用插入排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = C[i];         <span class="comment">// C[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (i == bn - <span class="number">1</span> ? n - <span class="number">1</span> : C[i + <span class="number">1</span>] - <span class="number">1</span>);<span class="comment">// C[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)        <span class="comment">// 对元素个数大于1的桶进行桶内插入排序</span></span><br><span class="line">            InsertionSort(A, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">29</span>, <span class="number">25</span>, <span class="number">3</span>, <span class="number">49</span>, <span class="number">9</span>, <span class="number">37</span>, <span class="number">21</span>, <span class="number">43</span> &#125;;<span class="comment">// 针对桶排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    BucketSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"桶排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程 。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-1e18e317393c2f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。 </p><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>​    桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>​    基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12654931-fe46e1ab43534fd1.gif?imageMogr2/auto-orient/strip" alt=""></p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n * dn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dn = <span class="number">3</span>;                <span class="comment">// 待排序的元素为三位数及以下</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;                <span class="comment">// 基数为10，每一位的数字都是[0,9]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span>          <span class="comment">// 获得元素x的第d位数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span> &#125;;<span class="comment">// 最大为三位数，所以这里只要到百位就满足了</span></span><br><span class="line">    <span class="keyword">return</span> (x / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> d)</span><span class="comment">// 依据元素的第d位数字，对A数组进行计数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[GetDigit(A[i], d)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dight = GetDigit(A[i], d);  <span class="comment">// 元素A[i]当前位数字为dight   </span></span><br><span class="line">        B[--C[dight]] = A[i];           <span class="comment">// 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">        <span class="comment">// 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LsdRadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>     <span class="comment">// 最低位优先基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; d++)     <span class="comment">// 从低位到高位</span></span><br><span class="line">        CountingSort(A, n, d);        <span class="comment">// 依据第d位数字对A进行计数排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">20</span>, <span class="number">90</span>, <span class="number">64</span>, <span class="number">289</span>, <span class="number">998</span>, <span class="number">365</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">789</span>, <span class="number">456</span> &#125;;<span class="comment">// 针对基数排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    LsdRadixSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"基数排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程<br><img src="https://upload-images.jianshu.io/upload_images/12654931-463067e0a4b82c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>​    基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。</p><p>　　如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。</p><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>​    基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>​    基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0、算法概述&quot;&gt;&lt;a href=&quot;#0、算法概述&quot; class=&quot;headerlink&quot; title=&quot;0、算法概述&quot;&gt;&lt;/a&gt;0、算法概述&lt;/h3&gt;&lt;h4 id=&quot;0-1-算法分类&quot;&gt;&lt;a href=&quot;#0-1-算法分类&quot; class=&quot;headerlink&quot; title=&quot;0.1 算法分类&quot;&gt;&lt;/a&gt;0.1 算法分类&lt;/h4&gt;&lt;p&gt;①：十种常见排序算法可以分为两大类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;非线性时间比较类排序&lt;/strong&gt;：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性时间非比较类排序&lt;/strong&gt;：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（一）：二维数组中的查找</title>
    <link href="http://yoursite.com/2018/07/12/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/07/12/剑指Offer（一）：二维数组中的查找/</id>
    <published>2018-07-12T13:10:43.000Z</published>
    <updated>2018-07-12T14:24:59.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer（一）：二维数组中的查找"><a href="#剑指Offer（一）：二维数组中的查找" class="headerlink" title="剑指Offer（一）：二维数组中的查找"></a>剑指Offer（一）：二维数组中的查找</h1><p>摘要</p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列文章为《剑指offer》刷题笔记。</p><p>刷题平台：牛客网</p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>​    首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><p>如果在一个二维数组中找到数字7，则返回true，如果没有找到，则返回false。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-e1ac5d9f3a6d3567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>查找过程如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-43cb8ecc339b728c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3、编程实现"><a href="#3、编程实现" class="headerlink" title="3、编程实现"></a>3、编程实现</h3><p><strong>C++：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">array</span>.empty() &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; cols &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> col = cols - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[row][col] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[row][col] &gt; target)&#123;</span><br><span class="line">                    --col;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ++row;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python2.7：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> rows &gt; <span class="number">0</span> <span class="keyword">and</span> cols &gt; <span class="number">0</span>:</span><br><span class="line">            row = <span class="number">0</span></span><br><span class="line">            col = cols - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> target == array[row][col]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer（一）：二维数组中的查找&quot;&gt;&lt;a href=&quot;#剑指Offer（一）：二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer（一）：二维数组中的查找&quot;&gt;&lt;/a&gt;剑指Offer（一）：二维数组中的查找&lt;/h1&gt;&lt;p&gt;摘要&lt;/p&gt;
&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本系列文章为《剑指offer》刷题笔记。&lt;/p&gt;
&lt;p&gt;刷题平台：牛客网&lt;/p&gt;
&lt;h2 id=&quot;二、题目&quot;&gt;&lt;a href=&quot;#二、题目&quot; class=&quot;headerlink&quot; title=&quot;二、题目&quot;&gt;&lt;/a&gt;二、题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>理解朴素贝叶斯</title>
    <link href="http://yoursite.com/2018/07/06/%E7%90%86%E8%A7%A3%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://yoursite.com/2018/07/06/理解朴素贝叶斯/</id>
    <published>2018-07-06T03:08:42.000Z</published>
    <updated>2018-07-06T03:26:01.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解朴素贝叶斯"><a href="#理解朴素贝叶斯" class="headerlink" title="理解朴素贝叶斯"></a>理解朴素贝叶斯</h1><h4 id="（1）先验概率、后验概率、联合概率、全概率"><a href="#（1）先验概率、后验概率、联合概率、全概率" class="headerlink" title="（1）先验概率、后验概率、联合概率、全概率"></a>（1）<strong>先验概率、后验概率、联合概率、全概率</strong></h4><p>如果我对这个西瓜<strong>没有任何了解</strong>，包括瓜的颜色、形状、瓜蒂是否脱落。按常理来说，西瓜成熟的概率大概是 60%。那么，这个概率 P(瓜熟) 就被称为<strong>先验概率</strong>。</p><p>即，<strong>先验概率</strong>是<strong>根据以往经验和分析得到的概率，先验概率无需样本数据，不受任何条件的影响。</strong>就像<strong>只根据常识而不根据西瓜状态来判断西瓜是否熟，这就是先验概率</strong>。</p><p>一个判断西瓜是否成熟的常识，就是看瓜蒂是否脱落。一般来说，瓜蒂脱落的情况下，西瓜成熟的概率大一些，大概是 75%。如果<strong>把瓜蒂脱落当作一种结果，然后去推测西瓜成熟的概率</strong>，这个概率 P(瓜熟 | 瓜蒂脱落) 就被称为<strong>后验概率</strong>。后验概率类似于<strong>条件概率</strong>。</p><p>知道了先验概率和后验概率，我们再来看看什么是联合概率。<strong>P(瓜熟，瓜蒂脱落)</strong> 称之为<strong>联合分布</strong>，它表示<strong>瓜熟了且瓜蒂脱落的概率</strong>。关于联合概率，满足下列乘法等式：</p><a id="more"></a><p><strong>P(瓜熟，瓜蒂脱落)</strong> <strong>=</strong> <strong>P(瓜熟**</strong>|<strong>瓜蒂脱落)**</strong>·<strong>P(瓜蒂脱落)</strong>=<strong>P(瓜蒂脱落</strong>|<strong>瓜熟)</strong>·<strong>P(瓜熟)</strong></p><p>其中，P(瓜熟 | 瓜蒂脱落) 就是刚刚介绍的后验概率，表示在“瓜蒂脱落”的条件下，“瓜熟”的概率。P(瓜蒂脱落 | 瓜熟) 表示在“瓜熟”的情况下，“瓜蒂脱落”的概率。</p><p>如何计算瓜蒂脱落的概率呢？实际上可以分成两种情况：一种是<strong>瓜熟状态下瓜蒂脱落的概率</strong>，<strong>另一种是瓜生状态下瓜蒂脱落的概率</strong>。瓜蒂脱落的概率就是这两种情况之和。因此，我们就推导出了<strong>全概率公式</strong>：</p><p><strong>P(瓜蒂脱落)=P(瓜蒂脱落|瓜熟)·P(瓜熟)+P(瓜蒂脱落|瓜生)·P(瓜生)</strong></p><h4 id="（2）单个特征判断瓜熟"><a href="#（2）单个特征判断瓜熟" class="headerlink" title="（2）单个特征判断瓜熟"></a><strong>（2）单个特征判断瓜熟</strong></h4><p>好了，介绍完先验概率、后验概率、联合概率、全概率后，我们来看这样一个问题：西瓜的状态分成两种：瓜熟与瓜生，概率分别为 0.6 与 0.4，且瓜熟里面瓜蒂脱落的概率是 0.8，瓜生里面瓜蒂脱落的概率是 0.4。那么，如果我现在挑到了一个瓜蒂脱落的瓜，则该瓜是好瓜的概率多大？</p><p>显然，这是一个计算后验概率的问题，根据我们上面推导的联合概率和全概率公式，可以求出：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-582ca247f1f19977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>一项一项来看：</p><p>条件概率 P(瓜蒂脱落 | 瓜熟) = 0.8</p><p>先验概率 P(瓜熟) = 0.6</p><p>条件概率 P(瓜蒂脱落 | 瓜生) = 0.4</p><p>先验概率 P(瓜生) = 0.4</p><p>将以上数值带入上式，得：<img src="https://upload-images.jianshu.io/upload_images/12654931-8e483547745003f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>注意，以上这种计算后验概率的公式就是利用贝叶斯定理。</p><h4 id="（3）多个特征判断瓜熟"><a href="#（3）多个特征判断瓜熟" class="headerlink" title="（3）多个特征判断瓜熟"></a><strong>（3）多个特征判断瓜熟</strong></h4><p>判断一个瓜是否熟了，除了要看瓜蒂是否脱落，还要看瓜的形状和颜色。形状有圆和尖之分，颜色有深绿、浅绿、青色之分。我们可以使用刚刚引入的贝叶斯定理思想来尝试解决这个问题。</p><p>现在，特征由原来的 1 个，变成现在的 3 个，我们用 X 表示特征，用 Y 表示瓜的类型（瓜熟还是瓜生）。则根据贝叶斯定理，后验概率 P(Y=ck | X=x) 的表达式为：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5cb90b8151c454a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>其中，ck 表示类别，k 为类别个数。本例中，k = 1，2，c1 表示瓜熟，c2 表示瓜生。上面的公式看似有点复杂，但其实与上一节单特征（瓜蒂是否脱落）的形式是一致的。</p><p>有一点需要注意，这里的特征 X 不再是单一的，而是包含了 3 个特征。因此，<strong>条件概率 P(X=x | Y=ck) 假设各个条件相互独立</strong>，也就是说<strong>假设不同特征之间是相互独立的</strong>。这样，P(X=x | Y=ck) 就可以写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-040af2fa8ac84376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>其中，n 为特征个数，j 表示当前所属特征。针对这个例子，P(X=x | Y=ck) 可以写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-4801526d4c60a531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>这种<strong>条件独立性的假设</strong>就是朴素贝叶斯法“<strong>朴素</strong>”二字的由来。<strong>这一假设让朴素贝叶斯法变得简单，但是有时候会牺牲一定的分类准确率</strong>。</p><p>​    利用朴素贝叶斯思想，我们就可以把后验概率写成：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-44bce97a4ade7d80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img">    上面的公式看上去比较复杂，其实只是<strong>样本特征增加</strong>了，形式上与上一节 P(瓜熟 | 瓜蒂脱落) 是一致的。</p><p>现在，一个西瓜，观察了它的瓜蒂、形状、颜色三个特征，就能根据上面的朴素贝叶斯公式，分别计算 c1（瓜熟）和 c2（瓜生）的概率，即 P(Y=c1 | X=x) 和 P(Y=c2 | X=x)。然后再比较 P(Y=c1 | X=x) 和 P(Y=c2 | X=x) 值的大小：</p><p>若 P(Y=c1 | X=x) &gt; P(Y=c2 | X=x)，则判断瓜熟；</p><p>若 P(Y=c1 | X=x) &lt; P(Y=c2 | X=x)，则判断瓜生。</p><p>值得注意的是上式中的分母部分，对于所有的 ck 来说，都是一样的。因此，分母可以省略，不同的 ck，仅比较 P(Y=ck | X=x) 的分子即可：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-57b7db79a57f0c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="（2）朴素贝叶斯分类"><a href="#（2）朴素贝叶斯分类" class="headerlink" title="（2）朴素贝叶斯分类"></a>（2）<strong>朴素贝叶斯分类</strong></h4><p>买瓜之前，还有一件事情要做，就是搜集样本数据。通过网上资料和查阅，获得了一组包含 10 组样本的数据。这组数据是不同瓜蒂、形状、颜色对应的西瓜是生是熟。我把这组数据当成是历史经验数据，以它为标准。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-8b395ed221dac1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"> </p><p>其中，瓜蒂分为脱落和未脱，形状分为圆形和尖形，颜色分为深绿、浅绿、青色。不同特征组合对应着瓜熟或者瓜生。</p><p>现在，挑了一个西瓜，它的瓜蒂脱落、形状圆形、颜色青色。这时候，就完全可以根据<strong>样本数据</strong>和<strong>朴素贝叶斯法</strong>来计算后验概率。</p><p>首先，对于瓜熟的情况：</p><p>瓜熟的先验概率： P(瓜熟) = 6 / 10 = 0.6。</p><p>条件概率： P(脱落 | 瓜熟) = 4 / 6 = 2 / 3。</p><p>条件概率： P(圆形 | 瓜熟) = 4 / 6 = 2 / 3。</p><p>条件概率： P(青色 | 瓜熟) = 2 / 6 = 1 / 3。</p><p>计算<strong>后验概率分子部分</strong>：P(瓜熟) × P(脱落 | 瓜熟) × P(圆形 | 瓜熟) × P(青色 | 瓜熟) = 0.6 × (2 / 3) × (2 / 3) × (1 / 3) = 4 / 45。</p><p>然后，对于瓜生的情况：</p><p>瓜生的先验概率： P(瓜生) = 4 / 10 = 0.4。</p><p>条件概率： P(脱落 | 瓜生) = 1 / 4 = 0.25。</p><p>条件概率： P(圆形 | 瓜生) = 1 / 4 = 0.25。</p><p>条件概率： P(青色 | 瓜生) = 1 / 4 = 0.25。</p><p>计算<strong>后验概率分子部分</strong>：P(瓜生) × P(脱落 | 瓜生) × P(圆形 | 瓜生) × P(青色 | 瓜生) = 0.4 × 0.25 × 0.25 × 0.25 = 1 / 160。</p><p>因为 4 / 45 &gt; 1 / 160，所以预测为瓜熟。终于计算完了，很肯定这个西瓜瓜蒂脱落、形状圆形、颜色青色，应该是熟瓜。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;理解朴素贝叶斯&quot;&gt;&lt;a href=&quot;#理解朴素贝叶斯&quot; class=&quot;headerlink&quot; title=&quot;理解朴素贝叶斯&quot;&gt;&lt;/a&gt;理解朴素贝叶斯&lt;/h1&gt;&lt;h4 id=&quot;（1）先验概率、后验概率、联合概率、全概率&quot;&gt;&lt;a href=&quot;#（1）先验概率、后验概率、联合概率、全概率&quot; class=&quot;headerlink&quot; title=&quot;（1）先验概率、后验概率、联合概率、全概率&quot;&gt;&lt;/a&gt;（1）&lt;strong&gt;先验概率、后验概率、联合概率、全概率&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;如果我对这个西瓜&lt;strong&gt;没有任何了解&lt;/strong&gt;，包括瓜的颜色、形状、瓜蒂是否脱落。按常理来说，西瓜成熟的概率大概是 60%。那么，这个概率 P(瓜熟) 就被称为&lt;strong&gt;先验概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即，&lt;strong&gt;先验概率&lt;/strong&gt;是&lt;strong&gt;根据以往经验和分析得到的概率，先验概率无需样本数据，不受任何条件的影响。&lt;/strong&gt;就像&lt;strong&gt;只根据常识而不根据西瓜状态来判断西瓜是否熟，这就是先验概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个判断西瓜是否成熟的常识，就是看瓜蒂是否脱落。一般来说，瓜蒂脱落的情况下，西瓜成熟的概率大一些，大概是 75%。如果&lt;strong&gt;把瓜蒂脱落当作一种结果，然后去推测西瓜成熟的概率&lt;/strong&gt;，这个概率 P(瓜熟 | 瓜蒂脱落) 就被称为&lt;strong&gt;后验概率&lt;/strong&gt;。后验概率类似于&lt;strong&gt;条件概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;知道了先验概率和后验概率，我们再来看看什么是联合概率。&lt;strong&gt;P(瓜熟，瓜蒂脱落)&lt;/strong&gt; 称之为&lt;strong&gt;联合分布&lt;/strong&gt;，它表示&lt;strong&gt;瓜熟了且瓜蒂脱落的概率&lt;/strong&gt;。关于联合概率，满足下列乘法等式：&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="朴素贝叶斯" scheme="http://yoursite.com/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="西瓜书" scheme="http://yoursite.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>域名解析</title>
    <link href="http://yoursite.com/2018/07/03/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/03/域名解析/</id>
    <published>2018-07-03T07:42:39.000Z</published>
    <updated>2018-07-03T08:02:59.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>域名有钱最好买.com的，不要买.cn的，我自己买的.cn的好多坑，.top的相对就比较便宜（low）。</p><p>此次在腾讯云买的dadavision.cn。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-7be4ec62010a4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p><p>之前.cn的一直要我备案，否则DNS解析不了，而且还证书审核失败。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-5de7c90ec35f4b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3a445764853e3128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在github项目的setting里面设置域名</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6e54ef27bfdb1bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>添加域名解析</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-19d33afeda8ecd28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里注意</p><p>在添加绑定域名后需要注意以下问题（未绑定可以不用）</p><p>需要将github上CNAME里面内容在文件工程中GitBlog\source\CNAME</p><p>这里注意新建的CNAME不要有后缀名。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3eb1866b15f4f46d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2c825d1db371b855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;域名解析&quot;&gt;&lt;a href=&quot;#域名解析&quot; class=&quot;headerlink&quot; title=&quot;域名解析&quot;&gt;&lt;/a&gt;域名解析&lt;/h1&gt;&lt;p&gt;域名有钱最好买.com的，不要买.cn的，我自己买的.cn的好多坑，.top的相对就比较便宜（low）。&lt;/p&gt;
&lt;p&gt;此次在腾讯云买的dadavision.cn。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12654931-7be4ec62010a4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="域名解析" scheme="http://yoursite.com/categories/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="域名" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="域名解析" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch0.4.0升级概述新手教程</title>
    <link href="http://yoursite.com/2018/06/20/Pytorch0-4-0%E5%8D%87%E7%BA%A7%E6%A6%82%E8%BF%B0%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/20/Pytorch0-4-0升级概述新手教程/</id>
    <published>2018-06-20T12:41:27.000Z</published>
    <updated>2018-06-20T13:01:19.114Z</updated>
    
    <content type="html"><![CDATA[<p>pytorch0.4支持了Windows系统的开发，在<a href="https://pytorch.org/" target="_blank" rel="noopener">首页</a>即可使用pip安装pytorch和torchvision。<br> 说白了，以下文字就是来自<a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" target="_blank" rel="noopener">官方文档60分钟入门的简要翻译</a>.</p><h2 id="pytorch是啥"><a href="#pytorch是啥" class="headerlink" title="pytorch是啥"></a>pytorch是啥</h2><p>python的科学计算库，使得NumPy可用于GPU计算，并提供了一个深度学习平台使得灵活性和速度最大化</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="Tensors-张量"><a href="#Tensors-张量" class="headerlink" title="Tensors(张量)"></a>Tensors(张量)</h4><a id="more"></a><p>Tensors与NumPy的ndarrays类似，另外可以使用GPU加速计算</p><p>未初始化的5*3的矩阵:<code>x = torch.empty(5, 3)</code><br> 随机初始化的矩阵:<code>x = torch.rand(5, 3)</code><br> 全零矩阵,定义数据类型:<code>x = torch.zeros(5, 3, dtype=torch.long)</code><br> 由数据构造矩阵:<code>x = torch.tensor([5.5, 3])</code><br> 由已存在张量构造矩阵，性质与之前张量一致:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x.new_ones(5, 3, dtype=torch.double) </span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)</span><br></pre></td></tr></table></figure><p>获取维度:<code>print(x.size())</code></p><h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><p>有多种operation的格式，这里考虑加法</p><ol><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = torch.rand(5, 3)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = torch.empty(5, 3)</span><br><span class="line">torch.add(x, y, out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># adds x to y</span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>operations中需要改变张量本身的值，可以在operation后加<em>,比如`x.copy</em>(y), x.t_()`</p><p>索引:<code>print(x[:, 1])</code><br> 改变维度:<code>x.view(-1, 8)</code></p><h3 id="和Numpy的联系"><a href="#和Numpy的联系" class="headerlink" title="和Numpy的联系"></a>和Numpy的联系</h3><p>torch tensor 和 numpy array之间可以进行相互转换，他们会共享内存位置，改变一个，另一个会跟着改变。</p><h4 id="tensor-to-array"><a href="#tensor-to-array" class="headerlink" title="tensor to array"></a>tensor to array</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(5)</span><br><span class="line">b = a.numpy()</span><br><span class="line">a.add_(1)</span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure><h4 id="array-to-tensor"><a href="#array-to-tensor" class="headerlink" title="array to tensor"></a>array to tensor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.ones(5)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, 1, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h3><p>tensor可以使用<code>.to</code>方法将其移动到任何设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># let us run this cell only if CUDA is available</span><br><span class="line"># We will use ``torch.device`` objects to move tensors in and out of GPU</span><br><span class="line">if torch.cuda.is_available():</span><br><span class="line">    device = torch.device(&quot;cuda&quot;)          # a CUDA device object</span><br><span class="line">    y = torch.ones_like(x, device=device)  # directly create a tensor on GPU</span><br><span class="line">    x = x.to(device)                       # or just use strings ``.to(&quot;cuda&quot;)``</span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(&quot;cpu&quot;, torch.double))       # ``.to`` can also change dtype together!</span><br></pre></td></tr></table></figure><h2 id="Autograd-自动求导"><a href="#Autograd-自动求导" class="headerlink" title="Autograd(自动求导)"></a>Autograd(自动求导)</h2><p>pytorch神经网络的核心模块就是autograd，autograd模块对Tensors上的所有operations提供了自动求导。</p><h3 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h3><p><code>torch.Tensor</code>是模块中的核心类，如果设置属性<code>.requires_grad = True</code>,开始追踪张量上的所有节点操作，指定其是否计算梯度。使用<code>.backward()</code>方法进行所有梯度的自动求导，张量的梯度会累积到<code>.grad</code>属性中。<br> <code>.detach()</code>停止张量的追踪，从梯度计算中分离出来；另外在评估模型时一般使用代码块<code>with torch.no_grad():</code>,因为模型中通常训练的参数也会有<code>.requires_grad = True</code>,这样写可以停止全部张量的梯度更新。<br> <code>Function</code>类是autograd的变体，<code>Tensor</code>和<code>Function</code>相互交错构建成无环图，编码了完整的计算过程，每个Variable(变量)都有<code>.grad_fn</code>属性，引用一个已经创建了的Tensor的Function.<br> 如上，使用<code>.backward()</code>计算梯度。如果张量是一个标量(只有一个元素),不需要对<code>.backward()</code>指定参数；如果张量不止一个元素，需要指定<code>.backward()</code>的参数，其匹配张量的维度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">x = torch.ones(2, 2, requires_grad=True)</span><br><span class="line">print(x)</span><br><span class="line">y = x + 2</span><br><span class="line">print(y)</span><br><span class="line">print(y.grad_fn)</span><br><span class="line">z = y * y * 3</span><br><span class="line">out = z.mean()</span><br><span class="line">print(z, out)</span><br><span class="line"></span><br><span class="line">a = torch.randn(2, 2)</span><br><span class="line">a = ((a * 3) / (a - 1))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(True) # 改变a张量内在的属性</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure><h3 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h3><p>反向传播时，由于<code>out</code>是一个标量，<code>out.backward()</code>等效于<code>out.backward(torch.tensor(1))</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">out.backward()</span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line">x = torch.randn(3, requires_grad=True)</span><br><span class="line"></span><br><span class="line">y = x * 2</span><br><span class="line">while y.data.norm() &lt; 1000:</span><br><span class="line">    y = y * 2</span><br><span class="line"></span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)</span><br><span class="line">y.backward(gradients)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** 2).requires_grad)</span><br><span class="line"></span><br><span class="line">with torch.no_grad():</span><br><span class="line">    print((x ** 2).requires_grad)</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经网络可以用<code>torch.nn</code>构建。<code>nn</code>依赖于<code>autograd</code>定义模型和求导，<code>nn.Module</code>定义网络层，方法<code>forward(input)</code>返回网络输出。</p><p>举例说明，如下是对数字图片分类的卷积网络架构。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fb68bfe5f7c4d22e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br> 这是一个简单的前馈神经网络，将输入数据依次通过几层网络层后最终得到输出。<br> 神经网络典型的训练步骤如下：</p><ul><li>定义神经网络及学习的参数(权重)</li><li>迭代输入数据</li><li>将输入数据输入到网络结构中</li><li>计算代价函数</li><li>误差向后传播</li><li>更新网络权重 <code>weight = weight - learning_rate * gradient</code> </li></ul><h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Net(nn.Module):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        # 1 input image channel, 6 output channels, 5x5 square convolution</span><br><span class="line">        # kernel</span><br><span class="line">        self.conv1 = nn.Conv2d(1, 6, 5)</span><br><span class="line">        self.conv2 = nn.Conv2d(6, 16, 5)</span><br><span class="line">        # an affine operation: y = Wx + b</span><br><span class="line">        self.fc1 = nn.Linear(16 * 5 * 5, 120)</span><br><span class="line">        self.fc2 = nn.Linear(120, 84)</span><br><span class="line">        self.fc3 = nn.Linear(84, 10)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        # Max pooling over a (2, 2) window</span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))</span><br><span class="line">        # If the size is a square you can only specify a single number</span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), 2)</span><br><span class="line">        x = x.view(-1, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">    def num_flat_features(self, x):</span><br><span class="line">        size = x.size()[1:]  # all dimensions except the batch dimension</span><br><span class="line">        num_features = 1</span><br><span class="line">        for s in size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        return num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">  (fc1): Linear(in_features=400, out_features=120, bias=True)</span><br><span class="line">  (fc2): Linear(in_features=120, out_features=84, bias=True)</span><br><span class="line">  (fc3): Linear(in_features=84, out_features=10, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以仅定义<code>forward()</code>函数，当使用<code>autograd</code>时<code>backward()</code>被自动定义。可以在<code>forward()</code>函数中使用任何operation操作。<br> <code>net.parameters()</code>返回模型中的可学习参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line">print(params[0].size())  # conv1&apos;s .weight</span><br></pre></td></tr></table></figure><p>使所有参数的梯度归零然后开始计算梯度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(1, 10))</span><br></pre></td></tr></table></figure><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>代价函数将(output,target)作为输入，计算output与target之间的距离。<br> nn模块中有几种不同的代价函数选择，最简单的是<code>nn.MSELoss</code>，计算均方误差<br> eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.arange(1, 11)  # a dummy target, for example</span><br><span class="line">target = target.view(1, -1)  # make it the same shape as output</span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure><p>按照向后传播的方向传播loss，使用<code>grad_fn</code>可以查看整个流程的计算图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure><p>使用<code>loss.backward()</code>，流程中所有<code>requres_grad=True</code>的张量累积它的梯度至<code>.grad</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(loss.grad_fn)  # MSELoss</span><br><span class="line">print(loss.grad_fn.next_functions[0][0])  # Linear</span><br><span class="line">print(loss.grad_fn.next_functions[0][0].next_functions[0][0])  # ReLU</span><br></pre></td></tr></table></figure><h3 id="向后传播"><a href="#向后传播" class="headerlink" title="向后传播"></a>向后传播</h3><p><code>loss.backward()</code>传播误差，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()     # zeroes the gradient buffers of all parameters</span><br><span class="line"></span><br><span class="line">print(&apos;conv1.bias.grad before backward&apos;)</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(&apos;conv1.bias.grad after backward&apos;)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure><h3 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h3><p>误差每次传播后，需要对权重进行更新，简单的更新方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = 0.01</span><br><span class="line">for f in net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure><p><code>torch.optim</code>实现了这一过程，并有着不同的更新规则GD, Nesterov-SGD, Adam, RMSProp，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import torch.optim as optim</span><br><span class="line"></span><br><span class="line"># create your optimizer</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=0.01)</span><br><span class="line"></span><br><span class="line"># in your training loop:</span><br><span class="line">optimizer.zero_grad()   # zero the gradient buffers</span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    # Does the update</span><br></pre></td></tr></table></figure><p>note: 每次迭代时由于梯度的累积，需要手动将梯度归零<code>optimizer.zero_grad()</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytorch0.4支持了Windows系统的开发，在&lt;a href=&quot;https://pytorch.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;首页&lt;/a&gt;即可使用pip安装pytorch和torchvision。&lt;br&gt; 说白了，以下文字就是来自&lt;a href=&quot;https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档60分钟入门的简要翻译&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;pytorch是啥&quot;&gt;&lt;a href=&quot;#pytorch是啥&quot; class=&quot;headerlink&quot; title=&quot;pytorch是啥&quot;&gt;&lt;/a&gt;pytorch是啥&lt;/h2&gt;&lt;p&gt;python的科学计算库，使得NumPy可用于GPU计算，并提供了一个深度学习平台使得灵活性和速度最大化&lt;/p&gt;
&lt;h3 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h3&gt;&lt;h4 id=&quot;Tensors-张量&quot;&gt;&lt;a href=&quot;#Tensors-张量&quot; class=&quot;headerlink&quot; title=&quot;Tensors(张量)&quot;&gt;&lt;/a&gt;Tensors(张量)&lt;/h4&gt;
    
    </summary>
    
      <category term="Pytorch" scheme="http://yoursite.com/categories/Pytorch/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
      <category term="Pytorch0.4.0" scheme="http://yoursite.com/tags/Pytorch0-4-0/"/>
    
  </entry>
  
  <entry>
    <title>唐老师研究生毕业演讲</title>
    <link href="http://yoursite.com/2018/06/20/%E5%94%90%E8%80%81%E5%B8%88%E7%A0%94%E7%A9%B6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%BC%94%E8%AE%B2/"/>
    <id>http://yoursite.com/2018/06/20/唐老师研究生毕业演讲/</id>
    <published>2018-06-20T07:32:21.000Z</published>
    <updated>2018-06-20T08:27:24.796Z</updated>
    
    <content type="html"><![CDATA[<p>尊敬的何院士、各位嘉宾、各位老师、同学们：</p><p>大家下午好！</p><a id="more"></a><!--我是计算机科学与软件工程学院2018届硕士毕业生唐益军。此刻我站在这里，除了感到兴奋和荣幸之外，其实更多的是不解。学院的张老师让我来做毕业生代表致辞，我其实一直以为只有优秀毕业生才可以来。我是说，即使真的是只有优秀毕业生才可以来，我也会不择手段地想尽各种办法上来说几句话。可是，母校的不拘一格和张老师的英明决定让我的那些“不择手段”竟然到现在都没有用武之地，我想这可能是我在毕业之际留下的唯一遗憾。Anyway, 今天我被委以“重任”站在了这里，我希望能和大家分享一下这几年从母校、学院以及学校的各位老师那里感受到的几点体会，希望能和大家共勉。并且我一厢情愿地以为这也是你们的体会，即使不是，希望大家今天在现场配合下我，假装这些是。好，那我们开始。**1. 在校期间学习“学习”**确切地说是，**在校期间一定要好好学习学习**，即使这样做的结果是注定要单身整个大学和研究生生涯也没有关系。学习的过程就是将我们从一个傻傻分不清楚的“学生”变成一个高富帅或者是白富美型的技能满点的社会精英。从这个结果看过去，具体地说，从我目前的身体状态看过去，我的学习过程基本就是失败的。对了，插一句，我要重新定义下“学习”的概念：“**不要停止投资自己的脑子和身子**”。我知道，很多同学和我一样都曾不断疑问：我学了这么多年的文化知识，可是去校门外一看几乎和社会上的企业机构所需要的技能是脱节的，我该咋办？拿我们软件专业来说，市面上普通需要的是做后台开发，前端设计，安卓IOS开发、大数据开发，甚至是机器学习人工智能，乃至最近比较火的区块链技术。可是，学校从来不教我们这些东西，至少是从来没有直接教给我们如何用这些技术开发项目。但事实上，学校的各位老师用心良苦，很多人都没有看出来。今天就让我来揭开这个惊天大秘密吧。注意听，学校教给我们的一直都是“**如何学习**”的能力。我刚刚说“在校期间学习学习”。第一个“学习”是动词，第二个“学习”是名词，意思就是：**我们要学习“如何学习”这件事儿**。走上你未来的工作岗位后，你可能会发现：光会后台开发（我是说软件专业的同学）不够用了，公司可能有个临时项目需要你会Python，可是老师没教过，不过好在我们有“如何学习”的能力，所以做到知识的快速迁移与学习一定，注意，是一定，一定没有问题。这一点，我无比自信，甚至是坚信，相信你们也一样。我小时候看过一部电影叫《神鞭》。故事情节不重要了，只记得影片结尾有一句台词：“**鞭没了，但神还在**。”这和我们的学校教育是不是很像，最后忘记了所有具体的知识技能，但是我们的“学习能力”留下来了。我想这才是未来我们在社会上一直能够无往不利的最强能力，至少也应该是之一吧。**2. 在用中学和学中用**软件专业当然也包括其他专业，很多老师也就是我们的研究生导师给我们提供了很多研究课题项目。对于软件专业的同学来说，要求动手能力很强，也就是大家常说的代码能力要很强。我记得刚开始的时候，很多同学，至少包括我，我们都觉得自己的能力不够来做项目，于是就想着再去找一些书系统看看前面的内容，来达到现在“具备做这个课题项目的能力”，也就是我们常说的“我想先学会了再去做”。这样的后果就是，你永远“学不够”、“学不会”。后来我们的师兄师姐告诉我们过来人的经验，说这种蠢事谁年轻的时候没干过呢，其实你们应该直接做课题做项目，在做的过程中遇到不会的去查，然后回来继续做，反复折腾，反复验证，项目也就被推进着做完了。简单地说**这个过程就是“在用中学和学中用”**。可是我觉得师兄师姐没有说清楚这件事儿，尽管从结果上看让人屡试不爽。但是，今天既然在这里演讲，我觉得非常有必要稍显专业地把这件事儿再稍微说明白一点。所以后来我总结道（其实也不是我总结的，你们就姑且当是我总结的吧）：**当你需要获取某项技能或者是搞定一件事儿的时候，一定要想办法在最短时间内弄清楚这个技能或搞定这件事儿需要哪些“最少必要知识”，然后迅速掌握它**。请大家记住了，在你掌握了这些“最少必要知识”的瞬间，其实你就已经入门了，你就走上了学习这项技能的快速路径或具备了搞定这件事儿的起码素质。剩下的部分，只需要你在“用中学和学中用”。而在研究生期间我们需要攻克的那些课题项目，其实大部分所需要的“最少必要知识”我们已经具备了，除非你在本科期间光顾着谈恋爱了，虽然我觉得从某种意义上来讲，没有什么比谈恋爱更重要的事儿了，如果真的有，你就再谈一个嘛。从这个角度看过去，从掌握“最少必要知识”再到“用中学和学中用”，其实这就是我刚刚说的第一点中的“如何学习的能力”。我不得不反复强调这件事儿，因为对学生来说，即使我们今天毕业了，学习还是一件非常重要的事儿，即使和谈恋爱相比，它不能成为最重要了，我想至少也应该是之一吧。**3. 有死磕到底的精神**刚刚说到很多研究课题项目，所以研究生期间晚上12点才准备回宿舍，其实一点都不值得炫耀，尽管我和很多同学一样，都喜欢在12点或者1点准备走的时候拍一张照片发到朋友圈。我印象比较深刻的是，大概是研一下学期有天晚上大概11点多了，实验室只剩下我和一位年轻的王老师。我已经准备收拾一下就撤了。当时我们那个王老师一看我要走，一把拿住我：“你干嘛去？”那个眼神就像在说，今晚程序调不出来不许走！我当时楞了一小会，你们要知道，对于一个资深的胖子来说，正常情况下，我什么都愿意吃，就是不愿意吃苦，尤其是这么大半夜的。可是，我当时看到王老师含情脉脉地盯着我，我们四目相对，那时那刻，我们都知道彼此心里在想什么：他知道我想走，我知道他不想让我走。最终我还是从了他，只好说：“我先去上个洗手间”。但是，回头想想我十分感谢王老师。从我踏入那个实验室开始，我几乎每天都能看到他至少工作到晚上11点以后，从未间断过。早上也来得很早，我为此还非常“不合常理”地起了好几个大早。可是不管我有多早，他都已经在了。不过，我也一直都没有好意思问他为什么这么拼命？就怕王老师告诉我：知道你为什么这么胖了吧？所以如果说，**我身上有那么一点点死磕到底，有那么一点点从来都不放过自己的精神，我想都是王老师日日夜夜对我以身作则的影响**，尽管我从来没有向他表白过，但今天我想借这个机会说一句：王老师，我爱你。没想到，我人生中第一次公开场合的表白献给了一位老男人。作为毕业生代表，刚刚那句“我爱你”，我其实也是替大家说给那些我们研究生生涯中的老师们听的。实在不好意思，没有经过大家同意，就这么把很多人的“第一次”送出去了。**4. 做一名终身学习者**毕业找工作的时候，我本来的打算是去那个浦发银行。因为大家都说来钱最快的是金融投资行业，所以我也十分天真，为了钱什么都干得出来。可是，有一天我的研究生导师王江涛老师找到我，十分中肯地说：“小唐啊，你看研究生这几年，你除了体重，其他的学习能力和工作能力，其实都没有得到多大的提升。我的意思是，你要不要毕业后在我这里再学习几年？反正你还年轻，而且你估计也找不到什么好工作的吧。”我当时一听，那个心里真不是滋味，心想：王老师的为人怎么这么好？为我考虑得如此周到。尤其是，他也觉得我还需要学习，并且即使我毕业了也愿意继续教我培养我。我当时感动得一塌糊涂，鼻涕泪水全下来了，头一扬，眼含泪水对着王老师说：那太好了。我愿意啊。我是想说，我们在场的每一个人都要做一名终身学习者，即使我们今天从母校毕业了，即使我们暂时脱离了理论意义上的“学生”身份。**尤其是当你觉得自己力有不逮，心有不余的时候，通过学习新的事物，不一定是我们的专业知识，总是会有一种让我们脚能够踩在地上的厚实感，对了，这个词叫“踏实”也叫“安全感”**。所以，**我一直愿意承认和告诉别人，我过去、现在和未来都是一个学生**，即使费尽千辛万苦地勉强拿到了学位，勉强从母校毕业了。但正如乔布斯曾经说过的那样：**stay foolish, stay hungry. 永远保持谦卑的心态，永远要如饥似渴地对待那些新的事物。**正是这样的一个空杯心态才是我们可以不断进步的基本条件，也是我们作为一个终身学习者的标配。**5. 身体是革命的本钱**前不久我们团队去浙江嘉兴南湖搞团建，我们当时要做一个叫“定向越野”的项目，总共有11个定点。但是游戏规则只需要走4个点，可是带我们小队的领队是一位跑过马拉松的老师。他决定带我们跑完11个定点，我们从8点半左右开始出发，一直到中午12点半才完成任务。本来走走停停中间歇歇，即使对我这样一个胖子，跑完全程也显得相对十分轻松。可是我们这位老师毕竟是跑过马松的，全程都是在小跑。刚开始我还受得了，时间长了，我的生理防线没有丝毫犹豫直接崩溃，整个人都在打摆。一向自诩心理强大的我，在那一刻我的心理防线也几乎临近崩溃边缘。所以后半场我几乎在众人拖着的情况下走完了。好，接下来是本次演讲中最励志的部分了。大家请听好了，非常励志的部分来了。团建回来以后，我做出了一个非常慎重的决定：我要减肥！注意，我要解释一下，在胖子界有头有脸且有过多年从业经验的我来说，我从来没想过要跨界转行。但是一想到这次团建我的糟糕表现，以及我觉得我未来是要干大事儿。你们知道，干大事一定要身体特别好，因为大事干成的时间周期一般有点长，工作强度也特别特别大。所以如果身体不好，基本我要干的“大事儿”也就黄了。因此，基于这样的考虑，我觉得我要减肥了。于是，我去报了一个健身房，还请了两个私教。基本上把我身上的那点积蓄和信用卡都刷爆了。当然，这不重要。我想说的是，**身体真的是革命的本钱**。这事儿实在太重要了，即使和谈恋爱相比也很重要，如果你能懂我的意思的话。好，现在请允许我代表2018届计算机科学与软件工程学院所有硕士毕业生，向我们的母校华东师范大学、向计算机科学与软件工程学院的何院士以及其他全体老师表示衷心的感谢。没有你们的教育与培养，光靠我们自己的努力，我们根本无法茁壮成长到现在，而且长势非常喜人，甚至还有点喜人过了头，比如说我。请大家和我一起把掌声送给所有所有的老师，感谢你们这些年不辞辛劳的付出，也祝愿何院士和全体老师在以后的日子里工作顺利！身体健康！同时，借此机会我想代表学院所有硕士毕业生同学向我们的父母表示感谢，感谢他们多年来的养育之恩。尤其是在我们20多岁血气方刚、风华正茂的年龄，本该承担起一部分家庭责任的时候，居然还一直支持我们求学读书，不管是精神上还是经济上。当然，最重要的还是经济上，因为我想对你们说，你们的儿子女儿已经在精神上坚强得让你们难以想象了。并且从今天开始，我们也有经济实力，可能只有软件专业的学生才敢说这种话，我们也有经济实力给予你们更多的报答。后天就是父亲节，大家可以想想能干点什么了。最后，也是最重要的部分，**Class of 2018, Congradulations. It is your big day, so stop thinking about anything today but enjoy it !  And rock to death.** 好，谢谢大家。我也最后代表一次大家，请允许我代表全体2018届研究生感谢母校，感谢计算机科学与软件工程学院，感谢所有老师的教导，感谢今天到场的咱爸咱妈们，并且祝福你们！谢谢！谢谢！-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尊敬的何院士、各位嘉宾、各位老师、同学们：&lt;/p&gt;
&lt;p&gt;大家下午好！&lt;/p&gt;
    
    </summary>
    
      <category term="毕业演讲" scheme="http://yoursite.com/categories/%E6%AF%95%E4%B8%9A%E6%BC%94%E8%AE%B2/"/>
    
    
      <category term="毕业演讲" scheme="http://yoursite.com/tags/%E6%AF%95%E4%B8%9A%E6%BC%94%E8%AE%B2/"/>
    
      <category term="唐老师" scheme="http://yoursite.com/tags/%E5%94%90%E8%80%81%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>win10+Anaconda+tensorflow1.8+pytorch0.4.0注意事项</title>
    <link href="http://yoursite.com/2018/06/12/win10-Anaconda-tensorflow1-8-pytorch0-4-0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yoursite.com/2018/06/12/win10-Anaconda-tensorflow1-8-pytorch0-4-0注意事项/</id>
    <published>2018-06-12T13:24:29.000Z</published>
    <updated>2018-06-12T14:32:57.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol><li><p>Anaconda会自带python3.6，所以为了避免环境配置乱套，删除本机独立安装的python。</p></li><li><p>不要按网上配置虚拟环境，比如TensorFlow配置一个虚拟环境，pytorch配置一个虚拟环境……keras……cafee……只要一个环境即可。</p></li><li><p>win10+Anaconda3-5.2.0+tensorflow1.8+pytorch0.4.0</p></li><li><p>在windows PowerShell中确定python环境在Anaconda中</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12654931-758686cac6661ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-0ef68ed1d7f3107a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a><strong>Anaconda</strong></h2><p>注意：自动添加到环境变量<br><img src="https://upload-images.jianshu.io/upload_images/12654931-f9601196db050179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>其它事项一路安装，普通套路。</p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a><strong>TensorFlow</strong></h2><p>1、TensorFlow或者pytorch，无论什么框架，越新越好，新的功能多bug少，这里用的TensorFlow1.8。</p><p>2、TensorFlow和pytorch最好都用conda装，但是这里conda install tensorflow只会给你比较低的版本，所以TensorFlow安装在这里使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --channel https://conda.anaconda.org/conda-forge tensorflow</span><br></pre></td></tr></table></figure></p><pre><code>可能会下载很慢，如果有部分下载未成功，重新执行命令即可，之前下载的会保留。</code></pre><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a><strong>Pytorch</strong></h2><p>同样遵循使用最新框架原则。<br>我自己电脑用的pytorch-CPU版本，所以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install conda install pytorch-cpu -c pytorch</span><br><span class="line">pip install torchvision</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0a411a96f06544e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在实验室服务器用的是cuda9.0版本<br><img src="https://upload-images.jianshu.io/upload_images/12654931-aa2b286afead2c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-win_amd64.whl </span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure></p><p>安装成功之后效果：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-91b167203217a037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-7240d3b7ee4ece2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="PyCharm注意事项"><a href="#PyCharm注意事项" class="headerlink" title="PyCharm注意事项"></a><strong>PyCharm注意事项</strong></h2><p>在不用虚拟幻境情况下，好处就是不用切换环境配置了，直接一个 Anaconda\python.exe全部搞定，如图：<br><img src="https://upload-images.jianshu.io/upload_images/12654931-402a57987fa606cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12654931-d5644c6b35f278bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>附录鄙视链：<br>caffe-pytorch-tensorflow-caffe2- caffe<br>torch-slim-tensorflow-keras</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Anaconda会自带python3.6，所以为了避免环境配置乱套，删除本机独立安装的python。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要按网上配置虚拟环境，比如TensorFlow配置一个虚拟环境，pytorch配置一个虚拟环境……keras……cafee……只要一个环境即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;win10+Anaconda3-5.2.0+tensorflow1.8+pytorch0.4.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在windows PowerShell中确定python环境在Anaconda中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12654931-758686cac6661ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12654931-0ef68ed1d7f3107a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Anaconda" scheme="http://yoursite.com/tags/Anaconda/"/>
    
      <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="环境配置" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch0.4.0重大更新</title>
    <link href="http://yoursite.com/2018/06/11/PyTorch0.4.0%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/06/11/PyTorch0.4.0重大更新/</id>
    <published>2018-06-11T10:32:02.000Z</published>
    <updated>2018-06-12T01:16:23.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、重大核心变化包括</strong></p><ul><li>Tensor/Variable 合并</li><li>零维张量</li><li>数据类型</li><li>迁移指南</li></ul><p><strong>二、现添加的新特征包括</strong></p><ul><li>Tensors：</li><li>全面支持高级索引</li><li>快速傅立叶变换</li><li>神经网络：</li><li>计算时的存储权衡</li><li>bottleneck-识别代码中热点（hotspots）的工具</li><li>torch.distributions</li><li>24 个基础的概率分布</li><li>增加cdf、方差、信息熵、困惑度等</li><li>分布式训练<a id="more"></a></li><li>易于使用的 Launcher utility</li><li>NCCL2 后端</li><li>C++拓展</li><li>Windows 支持</li><li>ONNX 改进</li><li>RNN 支持</li></ul><p><strong>三、性能改进</strong></p><p><strong>四、Bug 修复</strong></p><h3 id="五、torchvision的一些变化"><a href="#五、torchvision的一些变化" class="headerlink" title="五、torchvision的一些变化"></a><strong>五、torchvision的一些变化</strong></h3><p>1.torchvision.transform中函数<code>torchvision.transforms.`</code>Scale<code>(*args, **kwargs)即将被函数</code>torchvision.transforms.<code></code>Resize`(size, interpolation=2)代替。（参考官方文档：<a href="http://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.Resize" target="_blank" rel="noopener">点击打开链接</a>）</p><p>2.torchvision.transform中函数<code>torchvision.transforms.`</code>RandomSizedCrop<code>(*args, **kwargs)即将被函数</code>torchvision.transforms.<code></code>RandomResizedCrop`(size, scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333), interpolation=2)代替。（参考官方文档：<a href="http://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.RandomResizedCrop" target="_blank" rel="noopener">点击打开链接</a>）</p><h3 id="六、安装方式——Windows安装"><a href="#六、安装方式——Windows安装" class="headerlink" title="六、安装方式——Windows安装"></a><strong>六、安装方式——Windows安装</strong></h3><p>【方法一】pip直接安装。官网（<a href="http://pytorch.org/" target="_blank" rel="noopener">点击打开链接</a>）给出的安装步骤如下图所示（根据CUDA版本以及Python版本选择）。</p><p><img src="http://img0.ph.126.net/CToULoCCx_lmxB2-e1IPCg==/5717505544412384805.png" alt=""></p><p>Run this command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-win_amd64.whl </span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure><p>这里我是下载好torch-0.4.0-cp36-cp36m-win_amd64.whl文件到本地之后才安装的。<br>进入Anaconda Prompt，然后进入文件所在目录：</p><ol><li><p>打开cmd命令提示符，先利用anaconda创建一个虚拟环境，命名为pytorch4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch4 python=3.6</span><br></pre></td></tr></table></figure></li><li><p>激活刚才创建好的虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pytorch4</span><br></pre></td></tr></table></figure></li><li><p>安装pytorch0.4.0</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch-0.4.0-cp35-cp35m-win_amd64.whl</span><br></pre></td></tr></table></figure><p>注：根据自己的配置选择whl下载来链接</p><ol start="4"><li>安装torchvision<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torchvision</span><br></pre></td></tr></table></figure></li></ol><p>简单测试安装是否成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure></p><p>如果输出0.4.0，那么恭喜Windows下的PyTorch0.4.0安装成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一、重大核心变化包括&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tensor/Variable 合并&lt;/li&gt;
&lt;li&gt;零维张量&lt;/li&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;迁移指南&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二、现添加的新特征包括&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tensors：&lt;/li&gt;
&lt;li&gt;全面支持高级索引&lt;/li&gt;
&lt;li&gt;快速傅立叶变换&lt;/li&gt;
&lt;li&gt;神经网络：&lt;/li&gt;
&lt;li&gt;计算时的存储权衡&lt;/li&gt;
&lt;li&gt;bottleneck-识别代码中热点（hotspots）的工具&lt;/li&gt;
&lt;li&gt;torch.distributions&lt;/li&gt;
&lt;li&gt;24 个基础的概率分布&lt;/li&gt;
&lt;li&gt;增加cdf、方差、信息熵、困惑度等&lt;/li&gt;
&lt;li&gt;分布式训练
    
    </summary>
    
      <category term="PyTorch" scheme="http://yoursite.com/categories/PyTorch/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="PyTorch" scheme="http://yoursite.com/tags/PyTorch/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Mnist手写数字识别</title>
    <link href="http://yoursite.com/2018/06/09/Mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2018/06/09/Mnist手写数字识别/</id>
    <published>2018-06-09T10:32:05.000Z</published>
    <updated>2018-06-11T05:04:04.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="minist-mpl-py"><a href="#minist-mpl-py" class="headerlink" title="minist_mpl.py"></a><strong>minist_mpl.py</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Activation,Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adadelta</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> save_model</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">x_train = x_train.reshape(<span class="number">60000</span>,<span class="number">28</span>*<span class="number">28</span>).astype(<span class="string">'float32'</span>)  <span class="comment">#转换数据格式</span></span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>,<span class="number">28</span>*<span class="number">28</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">x_train /= <span class="number">255</span>   <span class="comment">#训练数据归一化</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"></span><br><span class="line">y_train = keras.utils.to_categorical(y_train,<span class="number">10</span>)    <span class="comment">#one-hot编码</span></span><br><span class="line">y_test = keras.utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(x_train.shape,y_train.shape,x_test.shape,y_test.shape)</span><br><span class="line">modle = Sequential()</span><br><span class="line"><span class="comment">#第一层隐层，64个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">256</span>,activation=<span class="string">'relu'</span>,input_dim=<span class="number">28</span>*<span class="number">28</span>))</span><br><span class="line"><span class="comment">#第二层隐层，64个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">256</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">modle.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#输出层，10个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">10</span>,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">sgd = SGD(lr=<span class="number">0.01</span>,decay=<span class="number">1e-6</span>,momentum=<span class="number">0.9</span>,nesterov=<span class="keyword">True</span>)</span><br><span class="line">modle.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adagrad'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">modle.fit(x_train,y_train,epochs=<span class="number">10</span>,batch_size=<span class="number">128</span>)</span><br><span class="line">score = modle.evaluate(x_test,y_test,batch_size=<span class="number">128</span>)</span><br><span class="line">print(score)</span><br><span class="line">modle.save(<span class="string">'MLP_minist.h5'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential,save_model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Dropout,Flatten,Conv2D,MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adadelta</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()   <span class="comment">#加载数据</span></span><br><span class="line">print(x_train.shape,x_test.shape)</span><br><span class="line">x_train = x_train.reshape(<span class="number">60000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">'float32'</span>)  <span class="comment">#二维数据</span></span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">x_train /= <span class="number">255</span>  <span class="comment">#训练数据归一化</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"></span><br><span class="line">y_train = keras.utils.to_categorical(y_train)    <span class="comment">#one-hot编码</span></span><br><span class="line">y_test = keras.utils.to_categorical(y_test)</span><br><span class="line">num_classes = y_test.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">model = Sequential()    <span class="comment">#创建序列模型</span></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,(<span class="number">3</span>,<span class="number">3</span>),activation=<span class="string">'relu'</span>,input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))  <span class="comment">#第一层卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))    <span class="comment">#池化层</span></span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,(<span class="number">3</span>,<span class="number">3</span>),activation=<span class="string">'relu'</span>))  <span class="comment">#第二层卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))    <span class="comment">#池化层</span></span><br><span class="line"></span><br><span class="line">model.add(Flatten())    <span class="comment">#铺平当前节点</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">128</span>,activation=<span class="string">'relu'</span>))     <span class="comment">#全连接层</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>)) <span class="comment">#随机失活</span></span><br><span class="line">model.add(Dense(num_classes,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])   <span class="comment">#编译模型</span></span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">128</span>,epochs=<span class="number">10</span>)     <span class="comment">#训练模型</span></span><br><span class="line">score = model.evaluate(x_test,y_test,batch_size=<span class="number">128</span>)    <span class="comment">#评价模型</span></span><br><span class="line"></span><br><span class="line">print(score)    <span class="comment">#打印分类准确率</span></span><br><span class="line"></span><br><span class="line">model.save(<span class="string">'CNN_minist.h5'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;minist-mpl-py&quot;&gt;&lt;a href=&quot;#minist-mpl-py&quot; class=&quot;headerlink&quot; title=&quot;minist_mpl.py&quot;&gt;&lt;/a&gt;&lt;strong&gt;minist_mpl.py&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;#encoding:utf-8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; keras&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.datasets &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; mnist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.models &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Sequential&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.layers &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Dense,Activation,Dropout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.optimizers &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; SGD,Adadelta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.models &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; save_model&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(x_train,y_train),(x_test,y_test) = mnist.load_data()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x_train = x_train.reshape(&lt;span class=&quot;number&quot;&gt;60000&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;).astype(&lt;span class=&quot;string&quot;&gt;&#39;float32&#39;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;#转换数据格式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x_test = x_test.reshape(&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;).astype(&lt;span class=&quot;string&quot;&gt;&#39;float32&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x_train /= &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;#训练数据归一化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x_test /= &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y_train = keras.utils.to_categorical(y_train,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;#one-hot编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y_test = keras.utils.to_categorical(y_test,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(x_train.shape,y_train.shape,x_test.shape,y_test.shape)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#第一层隐层，64个神经元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;,input_dim=&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#第二层隐层，64个神经元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#输出层，10个神经元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.add(Dense(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,activation=&lt;span class=&quot;string&quot;&gt;&#39;softmax&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sgd = SGD(lr=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;,decay=&lt;span class=&quot;number&quot;&gt;1e-6&lt;/span&gt;,momentum=&lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;,nesterov=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.compile(loss=&lt;span class=&quot;string&quot;&gt;&#39;categorical_crossentropy&#39;&lt;/span&gt;,optimizer=&lt;span class=&quot;string&quot;&gt;&#39;adagrad&#39;&lt;/span&gt;,metrics=[&lt;span class=&quot;string&quot;&gt;&#39;accuracy&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.fit(x_train,y_train,epochs=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,batch_size=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;score = modle.evaluate(x_test,y_test,batch_size=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(score)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modle.save(&lt;span class=&quot;string&quot;&gt;&#39;MLP_minist.h5&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Keras" scheme="http://yoursite.com/tags/Keras/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>交叉验证集、测试集</title>
    <link href="http://yoursite.com/2018/06/09/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E9%9B%86%E3%80%81%E6%B5%8B%E8%AF%95%E9%9B%86/"/>
    <id>http://yoursite.com/2018/06/09/交叉验证集、测试集/</id>
    <published>2018-06-09T10:32:04.000Z</published>
    <updated>2018-06-11T05:05:23.246Z</updated>
    
    <content type="html"><![CDATA[<p>什么有交叉验证：主要是<strong>因为训练集较小</strong>。无法直接像前面那样只分出训练集，验证集，测试就可以了（简单交叉验证）。</p><p>最佳的数据分类情况是把数据集分为三部分，分别为：<strong>训练集</strong>(train set)，<strong>验证集</strong>(validation set)和<strong>测试集</strong>(test set)</p><p>验证集和测试集两者的主要区别是：<strong>验证集</strong>用于<strong>进一步确定模型中的超参数</strong>(例如正则项系数、ANN{Artificial Neural Network}中隐含层的节点个数、网络层数、迭代次数、学习率)而<strong>测试集</strong>只是<strong>用于评估模型的精确度(即泛化能力)</strong>！</p><p>举个例子：假设建立一个BP神经网络，对于隐含层的节点数目，我们并没有很好的方法去确定。一般将节点数设定为某一具体的值，通过训练集训练出相应的参数后，再<strong>由交叉验证集去检测该模型的误差</strong>；<strong>然后再改变节点数，重复上述过程，直到交叉验证误差最小</strong>。此时的节点数可以认为是最优节点数，即该节点数(<strong>这个参数)是通过交叉验证集得到的</strong>。</p><p>而<strong>测试集</strong>是在<strong>确定了所有参数之后，根据测试误差来评判这个学习模型的；也可以说是用来评估模型的泛化能力</strong>。所以，<strong>验证集</strong>主要主要是<strong>用于模型的调参</strong>。</p><a id="more"></a><p>“<strong>交叉验证法</strong>“ (cross validation)先将数据集<strong>D</strong> <strong>划分为k 个大小相似的互斥子集</strong>， 即<strong>D = D**</strong>1<strong> </strong>∪<strong> </strong>D<strong>**2</strong> <strong>∪**</strong>…<strong> </strong>∪<strong> </strong>D<strong><strong>k</strong></strong>, Di<strong> </strong>∩<strong> </strong>Dj = ø (<strong><strong>i≠</strong></strong>j)<strong> . </strong>每个子集Di 都尽可能保持数据分布的一致性<strong>，即从D 中通过</strong>分层采样<strong>得到. 然后，每次用k-1 个子集的并集作为训练集，余下的那个子集作为测试集;这样就可获得k组训练/测试集，从而可进行k 次训练和测试，最终返回的是这</strong>k 个测试结果的均值<strong>**。</strong>显然，<strong>交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值</strong>，为强调这一点，通常把交叉验证法称为” <strong>k 折**</strong>/倍<strong>**交叉验证</strong>“ (k-fold cross validation). k 最常用的取值是<strong>10</strong> ，此时称为10折交叉验证; 其他常用的k 值有5、20 等.</p><p><img src="http://img0.ph.126.net/qb2MusthyyOYQcTgrg_hog==/1621295865953709417.png" alt=""></p><p>为了<strong>避免其他属性携带的信息被训练集中未出现的属性值”抹去</strong>”，在估计概率值时通常要进行”平滑” (smoothing) ，常用”<strong>拉普拉斯修正</strong>“，所以，P(c)和P(xi|c)修正为：</p><p>其中N 表示训练集D 中可能的类别数，Ni表示第</p><p>与留出法相似，将数据集D 划分为k 个子集同样存在多种划分方式.为<strong>减小因样本划分不同而引入的差别</strong>，<strong>k折交叉验证通常要随机使用不同的划分重复p 次</strong>。最终的评估结果是这<strong>p 次k 折交叉验证结果的均值</strong>，例如常见的有”10 次10 折交叉验证。</p><p>假定数据集D中包含m个样本，若令<strong>k=m</strong> ，则得到了<strong>交叉验证法的一个特例</strong>:<strong>留一法</strong>(Leave- One-Out比，简称LOO) . 显然，<strong>留一法不受随机样本划分方式的影响</strong>，因为m个样本只有唯一的方式划分为<strong>m个子集**</strong>—<strong>**每个子集包含一个样本</strong>;留一法使用的训练集与初始数据集相比只少了一个样本，这就使得在绝大多数情况下，<strong>留一法中被实际评估的模型与期望评估的用D 训练出的模型很相似</strong>.因此，<strong>留一法的评估结果往往被认为比较准确</strong>.然而，留一法也有其<strong>缺陷:在数据集比较大时</strong>，训练m个模型的计算开销可能是难以忍受的(例如数据集包含1 百万个样本，则需训练1 百万个模型)，而这还是在未考虑算法调参的情况下.另外，留一法的估计结果也未必永远比其他评估方法准确;”没有免费的午餐”定理对实验评估方法同样适用.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么有交叉验证：主要是&lt;strong&gt;因为训练集较小&lt;/strong&gt;。无法直接像前面那样只分出训练集，验证集，测试就可以了（简单交叉验证）。&lt;/p&gt;
&lt;p&gt;最佳的数据分类情况是把数据集分为三部分，分别为：&lt;strong&gt;训练集&lt;/strong&gt;(train set)，&lt;strong&gt;验证集&lt;/strong&gt;(validation set)和&lt;strong&gt;测试集&lt;/strong&gt;(test set)&lt;/p&gt;
&lt;p&gt;验证集和测试集两者的主要区别是：&lt;strong&gt;验证集&lt;/strong&gt;用于&lt;strong&gt;进一步确定模型中的超参数&lt;/strong&gt;(例如正则项系数、ANN{Artificial Neural Network}中隐含层的节点个数、网络层数、迭代次数、学习率)而&lt;strong&gt;测试集&lt;/strong&gt;只是&lt;strong&gt;用于评估模型的精确度(即泛化能力)&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;举个例子：假设建立一个BP神经网络，对于隐含层的节点数目，我们并没有很好的方法去确定。一般将节点数设定为某一具体的值，通过训练集训练出相应的参数后，再&lt;strong&gt;由交叉验证集去检测该模型的误差&lt;/strong&gt;；&lt;strong&gt;然后再改变节点数，重复上述过程，直到交叉验证误差最小&lt;/strong&gt;。此时的节点数可以认为是最优节点数，即该节点数(&lt;strong&gt;这个参数)是通过交叉验证集得到的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;测试集&lt;/strong&gt;是在&lt;strong&gt;确定了所有参数之后，根据测试误差来评判这个学习模型的；也可以说是用来评估模型的泛化能力&lt;/strong&gt;。所以，&lt;strong&gt;验证集&lt;/strong&gt;主要主要是&lt;strong&gt;用于模型的调参&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="模型评估" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>DP-单词拆分 I</title>
    <link href="http://yoursite.com/2018/06/09/DP-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20I/"/>
    <id>http://yoursite.com/2018/06/09/DP-单词拆分 I/</id>
    <published>2018-06-09T10:32:02.000Z</published>
    <updated>2018-06-11T05:04:33.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><a id="more"></a><p>示例 2：<br>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a><strong>算法思路</strong></h3><p>动态规划的思路：<br>将问题拆分成更小的子问题。用dp[i]表示0到i的子字符串是否可以拆分成满足条件的单词，在计算dp[i]的时候，我们已经知道dp[0],dp[1],…,dp[i-1],如果以i为结尾的j~i子串是满足条件的，并且0~j的子串也是在字典中的，那么dp[i]就是true。<br>用公式表示就是：</p><font color="red" size="5"><strong>dp[j]&amp;&amp;s.substring[j,i+1]∈dict</strong></font><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;;</span><br><span class="line">        <span class="keyword">boolean</span> [] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>]；</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS解法，超时"><a href="#DFS解法，超时" class="headerlink" title="DFS解法，超时"></a><strong>DFS解法，超时</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; wordDict, <span class="keyword">int</span> index)</span></span>&#123; <span class="comment">// 超时</span></span><br><span class="line">        String left = s.substring(index, s.length());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            String temp = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer each:list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(s, wordDict, each))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;br&gt;说明：&lt;br&gt;拆分时可以重复使用字典中的单词。&lt;br&gt;你可以假设字典中没有重复的单词。&lt;br&gt;示例 1：&lt;br&gt;输入: s = “leetcode”, wordDict = [“leet”, “code”]&lt;br&gt;输出: true&lt;br&gt;解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="http://yoursite.com/2018/06/09/Python%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2018/06/09/Python爬虫/</id>
    <published>2018-06-09T10:32:02.000Z</published>
    <updated>2018-06-11T05:05:02.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文本爬取"><a href="#文本爬取" class="headerlink" title="文本爬取"></a><strong>文本爬取</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests,urllib3.request,time,os</span><br><span class="line"><span class="keyword">import</span> random,csv,socket,http.client</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contend</span><span class="params">(url, data = None)</span>:</span>  <span class="comment">#获取网页中html代码</span></span><br><span class="line">    header=&#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">        &#125;</span><br><span class="line">    timeout = random.choice(range(<span class="number">80</span>,<span class="number">180</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rep = requests.get(url,headers = header,timeout=timeout)</span><br><span class="line">            rep.encoding = <span class="string">'utf-8'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'3'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">8</span>,<span class="number">15</span>))</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'4'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">20</span>,<span class="number">60</span>))</span><br><span class="line">        <span class="keyword">except</span> http.client.BadStatusLine <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'5'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">30</span>,<span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> http.client.IncompleteRead <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'6'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">5</span>,<span class="number">15</span>))</span><br><span class="line">    <span class="keyword">return</span> rep.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(html_text)</span>:</span></span><br><span class="line">    final = []</span><br><span class="line">    bs = BeautifulSoup(html_text,<span class="string">'html.parser'</span>) <span class="comment">#创建BeautifulSoup对象</span></span><br><span class="line">    body = bs.body  <span class="comment">#获取body部分</span></span><br><span class="line">    data = body.find(<span class="string">'div'</span>,&#123;<span class="string">'id'</span>:<span class="string">'7d'</span>&#125;) <span class="comment">#找到需要爬取部分的div</span></span><br><span class="line">    ul = data.find(<span class="string">'ul'</span>)   <span class="comment">#获取ul部分</span></span><br><span class="line">    li = ul.find_all(<span class="string">'li'</span>)  <span class="comment">#获取所有的li</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> li:  <span class="comment">#对li标签中内容进行遍历</span></span><br><span class="line">        temp = []</span><br><span class="line">        date =day.find(<span class="string">'h1'</span>).string <span class="comment">#找到日期</span></span><br><span class="line">        temp.append(date)   <span class="comment">#将日期添加到temp中</span></span><br><span class="line">        p = day.find_all(<span class="string">'p'</span>)   <span class="comment">#找到每个li中的所有p标签</span></span><br><span class="line">        temp.append(p[<span class="number">0</span>].string,)    <span class="comment">#第一个p标签中的天气状况添加到temp</span></span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>].find(<span class="string">'span'</span>) == <span class="keyword">None</span>:</span><br><span class="line">            t_highest = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t_highest = p[<span class="number">1</span>].find(<span class="string">'span'</span>).string    <span class="comment">#找到最高温</span></span><br><span class="line">            t_highest = t_highest.replace(<span class="string">'C'</span>,<span class="string">''</span>)</span><br><span class="line">        t_lowest = p[<span class="number">1</span>].find(<span class="string">'i'</span>).string  <span class="comment"># 找到最低温</span></span><br><span class="line">        t_lowest = t_lowest.replace(<span class="string">'C'</span>,<span class="string">''</span>)</span><br><span class="line">        temp.append(t_highest)</span><br><span class="line">        temp.append(t_lowest)</span><br><span class="line">        final.append(temp)</span><br><span class="line">    <span class="keyword">return</span> final</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(data,name)</span>:</span>  <span class="comment">#将数据写入文件</span></span><br><span class="line">    file_name = name</span><br><span class="line">    <span class="keyword">with</span> open(file_name, <span class="string">'a'</span>, errors=<span class="string">'ignore'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_csv = csv.writer(f)</span><br><span class="line">        f_csv.writerows(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://www.weather.com.cn/weather/101190401.shtml'</span></span><br><span class="line">    html = get_contend(url)</span><br><span class="line">    result = get_data(html)</span><br><span class="line">    print(result)</span><br><span class="line">    write_data(result,<span class="string">'weather.csv'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="图虫图片爬取"><a href="#图虫图片爬取" class="headerlink" title="图虫图片爬取"></a><strong>图虫图片爬取</strong></h2><h2 id="按标签爬取"><a href="#按标签爬取" class="headerlink" title="按标签爬取"></a><strong>按标签爬取</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">__author__ = <span class="string">'Result_Lv'</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_json</span><span class="params">(url)</span>:</span></span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">              <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">              <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">              <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">              &#125;</span><br><span class="line">    rep = requests.get(url, headers = header)   <span class="comment">#请求json地址</span></span><br><span class="line">    json_dict = json.loads(rep.text)            <span class="comment">#解析json</span></span><br><span class="line">    <span class="keyword">return</span> json_dict                            <span class="comment">#返回json字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_album_name</span><span class="params">(json_dict)</span>:</span></span><br><span class="line">    album_name = []</span><br><span class="line">    postlist = json_dict[<span class="string">'postList'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postlist)):</span><br><span class="line">        <span class="keyword">if</span> postlist[i][<span class="string">'title'</span>] == <span class="string">''</span>:                  <span class="comment">#图集标题为空时，命名为默认</span></span><br><span class="line">            album_name.append(<span class="string">'Default'</span> + str(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            album_name.append(postlist[i][<span class="string">'title'</span>])</span><br><span class="line">    <span class="keyword">return</span> album_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_photo_id</span><span class="params">(json_dict)</span>:</span>   <span class="comment">#获得所有照片的ID</span></span><br><span class="line">    author_id = []</span><br><span class="line">    album_id = []</span><br><span class="line">    post_list = json_dict[<span class="string">'postList'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(post_list)):                                     <span class="comment">#获取每个图集的照片ID</span></span><br><span class="line">        photo_id = []</span><br><span class="line">        author_id.append(post_list[i][<span class="string">'author_id'</span>])                     <span class="comment"># 获取每个图集作者ID</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(post_list[i][<span class="string">'images'</span>])):</span><br><span class="line">            photo_id.append(post_list[i][<span class="string">'images'</span>][j][<span class="string">'img_id'</span>])        <span class="comment">#将所有每个图集里的照片全部添加到list</span></span><br><span class="line">        album_id.append(photo_id)</span><br><span class="line">    <span class="keyword">return</span> author_id,album_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_album</span><span class="params">(path,album_name,author_id,album_id)</span>:</span>     <span class="comment">#下载图集</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(album_id)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path + album_name[i]):        <span class="comment">#若不存在对应图集的文件夹</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.makedirs(path + album_name[i])           <span class="comment">#以图集名创建文件夹</span></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">'正在下载第'</span> + str(i + <span class="number">1</span>) + <span class="string">'个图册:'</span> + album_name[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(album_id[i])):</span><br><span class="line">            fileurl = <span class="string">'https://photo.tuchong.com/'</span> + str(author_id[i]) +<span class="string">'/f/'</span> + str(album_id[i][j]) + <span class="string">'.jpg'</span>    <span class="comment">#生成每张照片Url</span></span><br><span class="line">            filename = path + album_name[i] + <span class="string">'/'</span> + str(j+<span class="number">1</span>) + <span class="string">'.jpg'</span>                                           <span class="comment">#命名照片</span></span><br><span class="line">            print(<span class="string">'    正在下载第'</span> + str(j+<span class="number">1</span>) + <span class="string">'张照片:'</span> + fileurl)</span><br><span class="line">            <span class="keyword">with</span> open(filename,<span class="string">'w'</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    request.urlretrieve(fileurl,filename)   <span class="comment">#下载照片</span></span><br><span class="line">                    time.sleep(np.random.rand())            <span class="comment">#下载间隔</span></span><br><span class="line">                <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">                    print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    page = <span class="number">3</span>              <span class="comment">#爬取页数</span></span><br><span class="line">    path = <span class="string">'F:/少女/'</span>     <span class="comment">#存放路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(page):</span><br><span class="line">        url = <span class="string">'https://tuchong.com/rest/tags/少女/posts?page='</span> + str(i+<span class="number">1</span>) + <span class="string">'&amp;count=20&amp;order=weekly'</span>  <span class="comment">#tag的json地址</span></span><br><span class="line">        json_dict = get_json(url)</span><br><span class="line">        album_name = get_album_name(json_dict)</span><br><span class="line">        para = get_photo_id(json_dict)</span><br><span class="line">        author_id = para[<span class="number">0</span>]</span><br><span class="line">        album_id = para[<span class="number">1</span>]</span><br><span class="line">        download_album(path,album_name,author_id,album_id)</span><br></pre></td></tr></table></figure><h3 id="按作者爬取"><a href="#按作者爬取" class="headerlink" title="按作者爬取"></a><strong>按作者爬取</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_json</span><span class="params">(url)</span>:</span>  <span class="comment">#解析json</span></span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">              <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">              <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">              <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">              &#125;</span><br><span class="line">    rep = requests.get(url, headers = header)   <span class="comment">#请求json地址</span></span><br><span class="line">    json_dict = json.loads(rep.text)            <span class="comment">#解析json</span></span><br><span class="line">    <span class="keyword">return</span> json_dict                            <span class="comment">#返回json字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_photo_id</span><span class="params">(json_dict)</span>:</span>   <span class="comment">#获得所有照片的ID</span></span><br><span class="line">    <span class="comment">#post_id = []</span></span><br><span class="line">    photo_id = []</span><br><span class="line">    post_list = json_dict[<span class="string">'post_list'</span>]</span><br><span class="line">    author_id = post_list[<span class="number">0</span>][<span class="string">'author_id'</span>]                               <span class="comment">#获取作者ID</span></span><br><span class="line">    author_name = post_list[<span class="number">0</span>][<span class="string">'site'</span>][<span class="string">'name'</span>]                          <span class="comment">#获取作者姓名</span></span><br><span class="line">    <span class="comment"># for i in range(len(post_list)):                                   #获取所有图集ID</span></span><br><span class="line">    <span class="comment">#     post_id.append(post_list[i]['post_id'])</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(post_list)):                                     <span class="comment">#获取每个图集的照片ID</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(post_list[i][<span class="string">'images'</span>])):</span><br><span class="line">            photo_id.append(post_list[i][<span class="string">'images'</span>][j][<span class="string">'img_id'</span>])        <span class="comment">#将所有每个图集里的照片全部添加到list</span></span><br><span class="line">    <span class="keyword">return</span> author_name,author_id,photo_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_photo</span><span class="params">(path,author_id,photo_id)</span>:</span>    <span class="comment">#下载全部照片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(photo_id)):</span><br><span class="line">        filename = path + <span class="string">'/'</span> + str(i+<span class="number">1</span>) + <span class="string">'.jpg'</span></span><br><span class="line">        fileurl = <span class="string">'https://photo.tuchong.com/'</span> + str(author_id) + <span class="string">'/f/'</span> + str(photo_id[i]) + <span class="string">'.jpg'</span></span><br><span class="line">        print(<span class="string">'    第'</span> + str(i + <span class="number">1</span>) + <span class="string">'张图片:'</span> + fileurl)</span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'w'</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                request.urlretrieve(fileurl,filename)   <span class="comment">#下载照片</span></span><br><span class="line">                time.sleep(np.random.rand())            <span class="comment">#下载间隔</span></span><br><span class="line">            <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    page = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(page):</span><br><span class="line">        url = <span class="string">'https://thomaskksj.tuchong.com/rest/2/sites/395013/posts?count=20&amp;page='</span> + str(i + <span class="number">1</span>)  <span class="comment">#作者主页的json地址</span></span><br><span class="line">        print(<span class="string">'正在下载第'</span> + str(i+<span class="number">1</span>) + <span class="string">'页:'</span> + url)</span><br><span class="line">        json_dict = get_json(url)</span><br><span class="line">        para = get_all_photo_id(json_dict)</span><br><span class="line">        author_name = para[<span class="number">0</span>]</span><br><span class="line">        author_id = para[<span class="number">1</span>]</span><br><span class="line">        photo_id = para[<span class="number">2</span>]</span><br><span class="line">        path = <span class="string">'F:/'</span> + author_name + <span class="string">'/page'</span> + str(i + <span class="number">1</span>)</span><br><span class="line">        download_photo(path,author_id,photo_id)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文本爬取&quot;&gt;&lt;a href=&quot;#文本爬取&quot; class=&quot;headerlink&quot; title=&quot;文本爬取&quot;&gt;&lt;/a&gt;&lt;strong&gt;文本爬取&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#encoding:utf-8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests,urllib3.request,time,os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; random,csv,socket,http.client&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_contend&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url, data = None)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#获取网页中html代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    header=&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Accept&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;Accept-Encoding&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;zh-CN,zh;q=0.9&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;Accept-Language&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;zh-CN,zh;q=0.8&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;Connection&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;keep-alive&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;User-Agent&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    timeout = random.choice(range(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rep = requests.get(url,headers = header,timeout=timeout)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rep.encoding = &lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; socket.timeout &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&#39;3&#39;&lt;/span&gt;,e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            time.sleep(random.choice.range(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; socket.error &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&#39;4&#39;&lt;/span&gt;,e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            time.sleep(random.choice.range(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; http.client.BadStatusLine &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&#39;5&#39;&lt;/span&gt;,e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            time.sleep(random.choice.range(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; http.client.IncompleteRead &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&#39;6&#39;&lt;/span&gt;,e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            time.sleep(random.choice.range(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; rep.text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_data&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(html_text)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    final = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bs = BeautifulSoup(html_text,&lt;span class=&quot;string&quot;&gt;&#39;html.parser&#39;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;#创建BeautifulSoup对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body = bs.body  &lt;span class=&quot;comment&quot;&gt;#获取body部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data = body.find(&lt;span class=&quot;string&quot;&gt;&#39;div&#39;&lt;/span&gt;,&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;7d&#39;&lt;/span&gt;&amp;#125;) &lt;span class=&quot;comment&quot;&gt;#找到需要爬取部分的div&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ul = data.find(&lt;span class=&quot;string&quot;&gt;&#39;ul&#39;&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;#获取ul部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    li = ul.find_all(&lt;span class=&quot;string&quot;&gt;&#39;li&#39;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;#获取所有的li&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; day &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; li:  &lt;span class=&quot;comment&quot;&gt;#对li标签中内容进行遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        date =day.find(&lt;span class=&quot;string&quot;&gt;&#39;h1&#39;&lt;/span&gt;).string &lt;span class=&quot;comment&quot;&gt;#找到日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp.append(date)   &lt;span class=&quot;comment&quot;&gt;#将日期添加到temp中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p = day.find_all(&lt;span class=&quot;string&quot;&gt;&#39;p&#39;&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;#找到每个li中的所有p标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp.append(p[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].string,)    &lt;span class=&quot;comment&quot;&gt;#第一个p标签中的天气状况添加到temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].find(&lt;span class=&quot;string&quot;&gt;&#39;span&#39;&lt;/span&gt;) == &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t_highest = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t_highest = p[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].find(&lt;span class=&quot;string&quot;&gt;&#39;span&#39;&lt;/span&gt;).string    &lt;span class=&quot;comment&quot;&gt;#找到最高温&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t_highest = t_highest.replace(&lt;span class=&quot;string&quot;&gt;&#39;C&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t_lowest = p[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].find(&lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;).string  &lt;span class=&quot;comment&quot;&gt;# 找到最低温&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t_lowest = t_lowest.replace(&lt;span class=&quot;string&quot;&gt;&#39;C&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp.append(t_highest)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp.append(t_lowest)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        final.append(temp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; final&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write_data&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data,name)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#将数据写入文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    file_name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(file_name, &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, errors=&lt;span class=&quot;string&quot;&gt;&#39;ignore&#39;&lt;/span&gt;, newline=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f_csv = csv.writer(f)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f_csv.writerows(data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url = &lt;span class=&quot;string&quot;&gt;&#39;http://www.weather.com.cn/weather/101190401.shtml&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    html = get_contend(url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = get_data(html)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    write_data(result,&lt;span class=&quot;string&quot;&gt;&#39;weather.csv&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>查准率precision和查全率recall、F1</title>
    <link href="http://yoursite.com/2018/06/09/%E6%9F%A5%E5%87%86%E7%8E%87precision%E5%92%8C%E6%9F%A5%E5%85%A8%E7%8E%87recall%E3%80%81F1/"/>
    <id>http://yoursite.com/2018/06/09/查准率precision和查全率recall、F1/</id>
    <published>2018-06-09T10:32:02.000Z</published>
    <updated>2018-06-11T05:04:59.951Z</updated>
    
    <content type="html"><![CDATA[<p>真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative），分别用TP、FP、TN、FN表示相应样例数，样例总数=TP+FP+TN+FN；分类结果混淆矩阵：</p><table><thead><tr><th>真实情况</th><th>预测结果</th><th></th></tr></thead><tbody><tr><td>正例</td><td>反例</td><td></td></tr><tr><td>正例</td><td>TP（真正例）</td><td>FN（假反例）</td></tr><tr><td>反例</td><td>FP（假正例）</td><td>TN（真反例）</td></tr></tbody></table><p><img src="http://img0.ph.126.net/KEZuAtQ5O-L1OQ3Z-Q07Fw==/6631529560586716227.png" alt=""></p><a id="more"></a><p>查准率（precision）：<strong>被认定为正例的里面，判断正确的比例</strong>。</p><p>查全率（recall）：<strong>真实正例里，被判断出为正例的比例</strong>。</p><p>查准率和查全率是一对矛盾的度量.一般来说，查准率高时，查全率往往偏低;而查全率高时，查准率往往偏低,可以通过P-R曲线来取两者的平衡值</p><p><img src="http://img0.ph.126.net/y0wS5Mk_91uJ6Byf-_1W5Q==/6608245202842946148.png" alt=""></p><p>若一个学习器P-R曲线被另一个学习器的曲线完全”<strong>包住</strong>“,则可断言<strong>后者的性能优于前者</strong>， 例如图中学习器A 的性能优于学习器C; 如果两个学习器的P-R 曲线发生了交叉7,例如图中的A 与B ，则难以一般性地断言两者孰优孰劣，只能在具体的查准率或查全率条件下进行比较然而，在很多情形下，人们往往仍希望把学习器A 与B 比出个高低. 这时一个比较合理的判据是比较<strong>P-R 曲线节面积</strong>的大小。</p><p>“<strong>平衡点</strong>“是”<strong>查准率=查全率</strong>“时的取值。</p><p>但更常用的使用<strong>F1</strong>来衡量查准率与查全率；</p><p>F1基于查准率与查全率的<strong>调和平均：</strong><img src="http://img0.ph.126.net/yg8YAE8RHL175oCy3vjc3g==/6632743421421514260.png" alt=""></p><p><img src="http://img0.ph.126.net/jpR5P7LKuB3AzZtvxzj_EA==/6631628516633222094.png" alt="">，sum为样例总数，</p><p>具体应用中可能对P和R有不同的倚重。比如<strong>商品推荐</strong>中，为了尽可能少打扰用户，更希望推荐内容确是用户感兴趣的，这时候<strong>查准率更重要</strong>。而在<strong>逃犯检索系统</strong>中，更希望尽可能少漏掉逃犯，此时<strong>查全率更重要</strong>。</p><p>F1度量的一般形式<strong>F**</strong>β<strong>（</strong>加权调和平均**）就可以表达这种偏好。 </p><p><img src="http://img2.ph.126.net/QSkXIzD2uBJSYNeqVKXbnA==/2291206310525129759.png" alt="">即  <img src="http://img2.ph.126.net/mlX2uGe9BlIO58oi64A-6w==/6632646664398271337.png" alt=""></p><p><strong>ß = 1时退化为标准的F1,当β&gt;1意味着P占比重更大</strong>，<strong>反之则是R</strong>。</p><h5 id="ROC、AUC"><a href="#ROC、AUC" class="headerlink" title="ROC、AUC"></a><strong>ROC、AUC</strong></h5><p><strong>ROC</strong>:全称“<strong>受试者工作特征</strong>”，<strong>表达了模型的泛化能力</strong>。其纵坐标为“<strong>TPR真正例率</strong>”；横坐标为“<strong>FPR假正例率</strong>”。</p><p><strong>ROC曲线根据模型的排序结果，一个个划分正负</strong>，每次得出两个值TPR,FPR。很多学习器是为测试样本产生一个<strong>实值</strong>或<strong>概率预测</strong>，然后将这个预测值与一个分类阈值进行比较，若大于阈值则分为正类，否则为反类。为啥在ROC曲线画一个y=x呢，那表示<strong>随机猜测的ROC</strong>。</p><p><strong>AUC:ROC曲线下的面积</strong>.AUC=1,是完美分类器(并不存在)；0.5。<strong>AUC 越大，意味着辨别能力越强</strong>。</p><p>与P-R图相似，如果一条ROC曲线<strong>包含另一条</strong>ROC曲线，则<strong>前者的学习器性能更优越</strong>。如果<strong>曲线有交叉</strong>，则可以通过<strong>计算AUC</strong>大小得到。</p><h5 id="代价敏感错误率、代价曲线"><a href="#代价敏感错误率、代价曲线" class="headerlink" title="代价敏感错误率、代价曲线"></a><strong>代价敏感错误率、代价曲线</strong></h5><p><strong>代价敏感错误率</strong>：<strong>为不同错误类型赋予不同的权重</strong>。<strong>不同类型的错误所造成的后果不同</strong>.例如在<strong>医疗诊断</strong>中，错误地把患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了”一次错误”但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机;再如，<strong>门禁系统</strong>错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可<strong>为错误赋予”非均等代价”</strong> 。</p><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”<strong>代价曲线</strong>“ 则可达到该目的.代价曲线图的<strong>横轴是取值为[0，1]的正例概率代价;纵轴是取值为[0，1] 的归一化代价。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative），分别用TP、FP、TN、FN表示相应样例数，样例总数=TP+FP+TN+FN；分类结果混淆矩阵：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;真实情况&lt;/th&gt;
&lt;th&gt;预测结果&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;正例&lt;/td&gt;
&lt;td&gt;反例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;正例&lt;/td&gt;
&lt;td&gt;TP（真正例）&lt;/td&gt;
&lt;td&gt;FN（假反例）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;反例&lt;/td&gt;
&lt;td&gt;FP（假正例）&lt;/td&gt;
&lt;td&gt;TN（真反例）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/KEZuAtQ5O-L1OQ3Z-Q07Fw==/6631529560586716227.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="性能评估" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>偏差、方差、噪声</title>
    <link href="http://yoursite.com/2018/06/09/%E5%81%8F%E5%B7%AE%E3%80%81%E6%96%B9%E5%B7%AE%E3%80%81%E5%99%AA%E5%A3%B0/"/>
    <id>http://yoursite.com/2018/06/09/偏差、方差、噪声/</id>
    <published>2018-06-09T10:32:02.000Z</published>
    <updated>2018-06-11T05:05:26.783Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代价敏感错误率</strong>：<strong>为不同错误类型赋予不同的权重</strong>。<strong>不同类型的错误所造成的后果不同</strong>.例如在<strong>医疗诊断</strong>中，错误地把患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了”一次错误”但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机;再如，<strong>门禁系统</strong>错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可<strong>为错误赋予”非均等代价”</strong> 。</p><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”<strong>代价曲线</strong>“ 则可达到该目的.代价曲线图的<strong>横轴是取值为[0，1]的正例概率代价;纵轴是取值为[0，1] 的归一化代价。</strong></p><h4 id="偏差（Bias）和方差（Variance）"><a href="#偏差（Bias）和方差（Variance）" class="headerlink" title="偏差（Bias）和方差（Variance）"></a><strong>偏差（Bias）和方差（Variance）</strong></h4><p><strong>偏差（Bias）</strong>：描述的是<strong>预测值（估计值）的期望与真实值之间的差距</strong>。<strong>偏差越大，越偏离真实数据</strong>。</p><p><strong>方差（Variance）</strong>：描述的是<strong>预测值的变化范围，离散程度</strong>，也就是离其期望值的距离。<strong>方差越大，数据的分布越分散</strong>。</p><p><img src="http://img2.ph.126.net/r1haOaQD_onwqs9zl_4gqw==/6632693943398259845.png" alt=""></p><a id="more"></a><p><strong>偏差：形容数据跟我们期望的中心差得有多远</strong>，算是“有监督的”，有人的知识参与指标；</p><p><strong>方差：形容数据分散程度</strong>的，算是“无监督的”，客观的指标。</p><p><strong>噪声</strong>：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即<strong>刻画了学习问题本身的难度</strong>.</p><p>偏差一方差分解说明，<strong>泛化性能</strong>是由<strong>学习算法的能力</strong>、<strong>数据的充分性</strong>以及<strong>学习任务本身的难度</strong>所共同决定的.</p><p>给定学习任务，为了取得好的泛化性能，则需使<strong>偏差较小</strong>，即<strong>能够充分拟合数据</strong>，并且使<strong>方差较小</strong>，即<strong>使得数据扰动产生的影响小</strong>.</p><p>一般来说偏差与方差是有冲突的，这称为<strong>偏差—方差窘境</strong>，给定学习任务，假定我们能控制学习算法的<strong>训练程度</strong>（例如<strong>决策树可控制层数</strong>，<strong>神经网络可控制训练轮数</strong>，<strong>集成学习方法可控制基学习器个数</strong>），则在<strong>训练不足时</strong>，<strong>学习器的拟合能力不够强</strong>，训练数据的扰动不足以便学习器产生显著变化，此时<strong>偏差主导了泛化错误率</strong>;<strong>随着训练程度的加深</strong>，<strong>学习器的拟合能力逐渐增强</strong>，训练数据发生的扰动渐渐能被学习器学到，<strong>方差逐渐主导了泛化错误率</strong>;<strong>在训练程度充足后，学习器的拟合能力已非常强，训练数据发生的轻微扰动都会导致学习器发生显著变化，若训练数据自身的、非全局的特性被学习器学到了，则将发生过拟合</strong>.</p><p><img src="http://img0.ph.126.net/Pf_BHxPZBFJ3I9qDD82fFA==/6597626119542477447.png" alt=""></p><p>为什么<strong>KNN</strong>（k最近邻k-Nearest Neighbor）算法在<strong>增大k时，偏差会变大</strong>；但<strong>RF</strong>（Random Forest随机森林）<strong>增大树的数目时偏差却保持不变</strong>；<strong>GBDT</strong>（Gradient Boosting）在<strong>增大树的数目时偏差却又能变小</strong>。</p><p>对于KNN算法，<strong>k值越大，表示模型的学习能力越弱</strong>，因为<strong>k越大，它越倾向于从“面”上考虑做出判断，而不是具体地考虑一个样本近身的情况来做出判断</strong>，所以，它的<strong>偏差会越来越大</strong>。</p><p>对于<strong>RF</strong>，我们实际上是<strong>部分实现了多次训练取均值的效果</strong>，<strong>每次训练得到的树都是一个很强的学习者</strong>，<strong>每一个的方差都比较大，但综合起来就会比较小</strong>。好比一个很强的学习者学习时，刮着西风，它会据此调整自己的瞄准方法，另一个很强的学习者学习时刮着东风，（西风、东风可以理解为不同训练集中的<strong>噪声</strong>）它也会据此调整自己的瞄准方法，在测试样本时，<strong>一个误差向西，一个误差向东，刚好起到互相抵消的作用，所以方差会比较小。但是由于每棵树的偏差都差不多，所以，我们取平均时，偏差不会怎么变化</strong>。</p><p>为什么说是<strong>部分</strong>实现了多次训练取均值的效果而不是全部呢？因为我们在训练各棵树时，是通过<strong>抽样样本集来实现多次训练</strong>的，<strong>不同的训练集中不可避免地会有重合的情况</strong>，此时，就<strong>不能认为是独立的多次训练了，各个训练得到的树之间的方差会产生一定的相关性</strong>，训练集中重合的样本越多，则两棵树之间的方差的相关性越强，就越难达成方差互相抵消的效果。</p><p>对于<strong>GBDT</strong>，<strong>N棵树之间根本就不是一种多次训练取均值的关系，而是N棵树组成了相关关联，层层递进的超级学习者</strong>，可想而知，它的<strong>方差一定是比较大</strong>的。但由于它的<strong>学习能力比较强</strong>，所以，它的<strong>偏差是很小</strong>的，而且树的<strong>棵树越多，学习能力就越强，偏差就越小</strong>。也就是说，只要学习次数够多，预测的均值会无限接近于目标。简单讲就是<strong>GBDT的N棵树实际上是一个有机关联的模型，不能认为是N个模型</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;代价敏感错误率&lt;/strong&gt;：&lt;strong&gt;为不同错误类型赋予不同的权重&lt;/strong&gt;。&lt;strong&gt;不同类型的错误所造成的后果不同&lt;/strong&gt;.例如在&lt;strong&gt;医疗诊断&lt;/strong&gt;中，错误地把患者诊断为健康人与错误地把健康人诊断为患者，看起来都是犯了”一次错误”但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机;再如，&lt;strong&gt;门禁系统&lt;/strong&gt;错误地把可通行人员拦在门外，将使得用户体验不佳，但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可&lt;strong&gt;为错误赋予”非均等代价”&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”&lt;strong&gt;代价曲线&lt;/strong&gt;“ 则可达到该目的.代价曲线图的&lt;strong&gt;横轴是取值为[0，1]的正例概率代价;纵轴是取值为[0，1] 的归一化代价。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;偏差（Bias）和方差（Variance）&quot;&gt;&lt;a href=&quot;#偏差（Bias）和方差（Variance）&quot; class=&quot;headerlink&quot; title=&quot;偏差（Bias）和方差（Variance）&quot;&gt;&lt;/a&gt;&lt;strong&gt;偏差（Bias）和方差（Variance）&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;偏差（Bias）&lt;/strong&gt;：描述的是&lt;strong&gt;预测值（估计值）的期望与真实值之间的差距&lt;/strong&gt;。&lt;strong&gt;偏差越大，越偏离真实数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方差（Variance）&lt;/strong&gt;：描述的是&lt;strong&gt;预测值的变化范围，离散程度&lt;/strong&gt;，也就是离其期望值的距离。&lt;strong&gt;方差越大，数据的分布越分散&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/r1haOaQD_onwqs9zl_4gqw==/6632693943398259845.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="性能评估" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>DP+回溯-单词拆分 II</title>
    <link href="http://yoursite.com/2018/06/09/DP+%E5%9B%9E%E6%BA%AF-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/"/>
    <id>http://yoursite.com/2018/06/09/DP+回溯-单词拆分 II/</id>
    <published>2018-06-09T10:32:02.000Z</published>
    <updated>2018-06-11T05:04:25.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。<br>说明：<br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>“cats and dog”,<br>“cat sand dog”<br>]</p><a id="more"></a><p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>“pine apple pen apple”,<br>“pineapple pen apple”,<br>“pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a><strong>算法思路</strong></h3><p>这道题类似 Word Break I 判断是否能把字符串拆分为字典里的单词 @LeetCode 只不过要求计算的并不仅仅是是否能拆分，而是要求出所有的拆分方案。因此用递归。<br>但是直接递归做会超时，原因是LeetCode里有几个很长但是无法拆分的情况，所以就先跑一遍Word Break I，先判断能否拆分，然后再进行拆分。</p><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span>[] canBreak = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];  </span><br><span class="line">        canBreak[<span class="number">0</span>] = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=s.length(); i++) &#123;  </span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(canBreak[j] &amp;&amp; wordDict.contains(s.substring(j,i))) &#123;  </span><br><span class="line">                    flag = <span class="keyword">true</span>;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            canBreak[i] = flag;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> canBreak[s.length()];  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; wordDict, String str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        String result = str;            <span class="comment">//记录字符串状态</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        String tmp = s.substring(index, len);</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(tmp))&#123;     <span class="comment">//最后一段存在于字典中，则保存结果</span></span><br><span class="line">            str += tmp;</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; listIndex = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;String&gt; listStr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; len; i++)&#123;</span><br><span class="line">            String temp = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                listIndex.add(i+<span class="number">1</span>);</span><br><span class="line">                listStr.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = result;   <span class="comment">//保存递归前的字符串状态，以便回溯</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listIndex.size(); i++)&#123;</span><br><span class="line">            result += listStr.get(i) + <span class="string">" "</span>;</span><br><span class="line">            dfs(s, wordDict, result, listIndex.get(i));</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isBreak(s, wordDict)) <span class="keyword">return</span> res;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        dfs(s, wordDict, str, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。&lt;br&gt;说明：&lt;br&gt;分隔时可以重复使用字典中的单词。&lt;br&gt;你可以假设字典中没有重复的单词。&lt;br&gt;示例 1：&lt;br&gt;输入:&lt;br&gt;s = “catsanddog”&lt;br&gt;wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt;“cats and dog”,&lt;br&gt;“cat sand dog”&lt;br&gt;]&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子串-最长公共子序列</title>
    <link href="http://yoursite.com/2018/06/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/06/09/最长公共子串-最长公共子序列/</id>
    <published>2018-06-09T10:32:02.000Z</published>
    <updated>2018-06-11T05:05:32.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a><strong>最长公共子串</strong></h3><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubStr</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.length();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.length();</span><br><span class="line"><span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [len1][len2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;<span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">if</span>(dp[i][j] &gt; result) &#123;</span><br><span class="line">result = dp[i][j];</span><br><span class="line">index = i;<span class="comment">// 记录最大子串的最后一个下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result = result &gt; dp[i][j] ? result : dp[i][j];</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">result = result &gt; dp[i][j] ? result : dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index - result + <span class="number">1</span>; i &lt;= index; i++) &#123;</span><br><span class="line">System.out.print(str1.charAt(i) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><strong>最长公共子序列</strong></h3><p>####动态规划<br>假设Z=&lt;z1,z2,⋯,zk&gt;是X与Y的LCS， 我们观察到<br>如果Xm=Yn，则Zk=Xm=Yn，有Zk−1是Xm−1与Yn−1的LCS；<br>如果Xm≠Yn，则Zk是Xm与Yn−1的LCS，或者是Xm−1与Yn的LCS。<br>因此，求解LCS的问题则变成递归求解的两个子问题。但是，上述的递归求解的办法中，重复的子问题多，效率低下。改进的办法——用空间换时间，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了。<br>DP求解LCS<br>用二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度，则可得到状态转移方程</p><h3 id="DP实现-1"><a href="#DP实现-1" class="headerlink" title="DP实现"></a><strong>DP实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.length();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.length();</span><br><span class="line"><span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] &gt; dp[i][j-<span class="number">1</span>] ? dp[i-<span class="number">1</span>][j] : dp[i][j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> dp[len1-<span class="number">1</span>][len2-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最长公共子串&quot;&gt;&lt;a href=&quot;#最长公共子串&quot; class=&quot;headerlink&quot; title=&quot;最长公共子串&quot;&gt;&lt;/a&gt;&lt;strong&gt;最长公共子串&lt;/strong&gt;&lt;/h3&gt;&lt;h3 id=&quot;DP实现&quot;&gt;&lt;a href=&quot;#DP实现&quot; class=&quot;headerlink&quot; title=&quot;DP实现&quot;&gt;&lt;/a&gt;&lt;strong&gt;DP实现&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxSubStr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String str1, String str2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len1 = str1.length();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len2 = str2.length();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; [][] dp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; [len1][len2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len1; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; len2; ++j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str1.charAt(i) == str2.charAt(j)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; j &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					dp[i][j] = dp[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;// 状态转移&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[i][j] &amp;gt; result) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;						result = dp[i][j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;						index = i;	&lt;span class=&quot;comment&quot;&gt;// 记录最大子串的最后一个下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;//	result = result &amp;gt; dp[i][j] ? result : dp[i][j];	&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					dp[i][j] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					result = result &amp;gt; dp[i][j] ? result : dp[i][j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	System.out.println(result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = index - result + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= index; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.print(str1.charAt(i) + &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分糖果</title>
    <link href="http://yoursite.com/2018/06/09/%E5%88%86%E7%B3%96%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/06/09/分糖果/</id>
    <published>2018-06-09T10:32:01.000Z</published>
    <updated>2018-06-11T05:05:07.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>o 分糖果：科大讯飞第二道编程题</p><p>o 小明和小红是好朋友，但最近遇到一个棘手的问题，有一盒糖果要分成两份但是每颗糖果质量都不尽相同，</p><p>o 但为了分配的公平每份糖的糖果数量相差不得超过1，在此条件下两份糖果的质量差距尽可能小。</p><p>o 输入一行数，包含一个数n，代表糖果数量，后面一次是n个整数一次表示每个糖果的质量，每个糖果的质量都是1到450</p><p>o 之间的一个整数，每盒最多有20个糖果。</p><p>o 输出：每个样例输出两个数字分别为两堆糖果的质量，如不相同，先小后大。</p><p>o 样例：输入：5 9 6 5 8 7</p><p>o 输出：17 18</p><a id="more"></a><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h3><p>o 回溯，在数量差值为1的结果中找出最小的质量差</p><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a><strong>Python实现</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(candies, num, select, sum, total, index)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> min</span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    <span class="keyword">if</span>(abs(total-sum*<span class="number">2</span>) &lt; min):</span><br><span class="line">        res = sum</span><br><span class="line">        min = abs(total-sum*<span class="number">2</span>)</span><br><span class="line">        result.append(select)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candies)):</span><br><span class="line">        <span class="keyword">if</span>(index == num<span class="number">-1</span>): return3</span><br><span class="line">        select.append(candies[index])</span><br><span class="line">        sum += candies[index]</span><br><span class="line">        temp = select.copy()</span><br><span class="line">        <span class="keyword">if</span>(len(select) &lt;= int(num/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            divide(candies, num, temp, sum, total, index)</span><br><span class="line">        sum -= select[len(select) - <span class="number">1</span>]</span><br><span class="line">        select.remove(select[len(select)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;o 分糖果：科大讯飞第二道编程题&lt;/p&gt;
&lt;p&gt;o 小明和小红是好朋友，但最近遇到一个棘手的问题，有一盒糖果要分成两份但是每颗糖果质量都不尽相同，&lt;/p&gt;
&lt;p&gt;o 但为了分配的公平每份糖的糖果数量相差不得超过1，在此条件下两份糖果的质量差距尽可能小。&lt;/p&gt;
&lt;p&gt;o 输入一行数，包含一个数n，代表糖果数量，后面一次是n个整数一次表示每个糖果的质量，每个糖果的质量都是1到450&lt;/p&gt;
&lt;p&gt;o 之间的一个整数，每盒最多有20个糖果。&lt;/p&gt;
&lt;p&gt;o 输出：每个样例输出两个数字分别为两堆糖果的质量，如不相同，先小后大。&lt;/p&gt;
&lt;p&gt;o 样例：输入：5 9 6 5 8 7&lt;/p&gt;
&lt;p&gt;o 输出：17 18&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客</title>
    <link href="http://yoursite.com/2018/06/09/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/06/09/Hexo+GitHub搭建个人博客/</id>
    <published>2018-06-09T10:32:01.000Z</published>
    <updated>2018-07-06T03:25:50.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-GitHub搭建个人博客"><a href="#Hexo-GitHub搭建个人博客" class="headerlink" title="Hexo+GitHub搭建个人博客"></a>Hexo+GitHub搭建个人博客</h1><p>目录：</p><p><strong>前言</strong>：</p><ul><li>​    准备工作</li></ul><p>搭建github博客</p><ul><li>​    创建仓库<br>   ​    绑定域名</li></ul><p><strong>配置SSH key</strong></p><ul><li>​    测试是否成功</li></ul><p><strong>使用hexo写博客</strong></p><ul><li>​    hexo简介<br>   ​    原理<pre><code>    注意事项    安装    初始化​    修改主题​    上传到github    保留CNAME、README.md等文件    常用hexo命令​    _config.yml    写博客        </code></pre></li></ul><p><strong>最终效果</strong></p><a id="more"></a><p><a href="https://dadavision.cn/" target="_blank" rel="noopener">https://dadavision.cn/</a></p><p><strong>技巧</strong></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol><h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1. 准备工作"></a>1.1. 准备工作</h2><p>在开始一切之前，你必须已经：</p><ul><li>有一个github账号，没有的话去注册一个；</li><li>安装了node.js、npm，并了解相关基础知识；</li><li>安装了git for windows（或者其它git客户端）</li></ul><p>本文所使用的环境：</p><ul><li>Windows10企业版</li><li><a href="mailto:node.js@8.11.2" target="_blank" rel="noopener">node.js@8.11.2</a></li><li><a href="mailto:git@2.17.1" target="_blank" rel="noopener">git@2.17.1</a></li><li><a href="mailto:hexo@3.7.1" target="_blank" rel="noopener">hexo@3.7.1</a></li></ul><h1 id="2-搭建github博客"><a href="#2-搭建github博客" class="headerlink" title="2.搭建github博客"></a>2.搭建github博客</h1><h2 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1. 创建仓库"></a>2.1. 创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li></ol><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2. 绑定域名"></a>2.2. 绑定域名</h2><p>当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p><p>首先你要注册一个域名，域名注册以前总是推荐去<code>godaddy</code>，现在觉得其实国内的阿里云、腾讯云也挺不错的，价格也不贵，毕竟是大公司，放心！或者说万网，本质上都是在万网上。</p><p>绑定域名分2种情况：带www和不带www的。</p><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-88e308cf654d0fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p><ul><li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a></li><li>如果你填写的是带www的，比如 <a href="http://www.mygit.me" target="_blank" rel="noopener">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a></li><li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a></li></ul><p>另外说一句，在你绑定了新域名之后，原来的<code>你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p><h1 id="3-配置SSH-key"><a href="#3-配置SSH-key" class="headerlink" title="3.配置SSH key"></a>3.配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0b20424399a4d60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>将刚复制的内容粘贴到key那里，title随便填，保存。 </p><h2 id="3-1-测试是否成功"><a href="#3-1-测试是否成功" class="headerlink" title="3.1. 测试是否成功"></a>3.1. 测试是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！</p><p>此时你还需要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;dadavision&quot;// 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;dadavision@qq.com&quot;// 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>具体这个配置是干嘛的我没仔细深究。</p><h1 id="4-使用hexo写博客"><a href="#4-使用hexo写博客" class="headerlink" title="4.使用hexo写博客"></a>4.使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1. hexo简介"></a>4.1. hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p><h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2. 原理"></a>4.2. 原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h2><p>安装之前先来说几个注意事项：</p><ol><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li><li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li></ol><h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4. 安装"></a>4.4. 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5. 初始化"></a>4.5. 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\Workspaces\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /f/GitBlog/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-ff306eee584e3fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里有个’更新博客’，这里涉及一个技巧，后面讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动服务</span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-0e2b9101fa5c2bcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，可以用<code>hexo clean</code>。</p><p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。</p><h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6. 修改主题"></a>4.6. 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。</p><p>个人比较喜欢的2个主题：<a href="https://github.com/pinggod/hexo-theme-jekyll" target="_blank" rel="noopener">hexo-theme-jekyll</a> 和 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>。</p><p>首先下载这个主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /f/Workspaces/hexo/</span><br><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载后的主题都在这里：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-11b9df349f6a787c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><p>另外一种更方便的方式是：</p><p>我用的next主题。</p><p>直接从官网github上，clone down下来，解压后直接放进文件夹更快。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-b1f01b0333d6ae3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: next</code>，然后重新执行<code>hexo g</code>来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7. 上传之前"></a>4.7. 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="4-8-上传到github"><a href="#4-8-上传到github" class="headerlink" title="4.8. 上传到github"></a>4.8. 上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:DaDaVision/DaDaVision.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com:DaDaVision/DaDaVision.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure><p>原因是还需要安装一个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p><p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会.</p><h2 id="4-9-保留CNAME、README-md等文件"><a href="#4-9-保留CNAME、README-md等文件" class="headerlink" title="4.9. 保留CNAME、README.md等文件"></a>4.9. 保留CNAME、README.md等文件</h2><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-1f808e15286a9be8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p><hr><p>这里需要注意：</p><p>在添加绑定域名后需要注意以下问题（未绑定可以不用）</p><p>需要将github上CNAME里面内容在文件工程中GitBlog\source\CNAME</p><p>这里注意新建的CNAME不要有后缀名。</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-3eb1866b15f4f46d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-2c825d1db371b855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10. 常用hexo命令"></a>4.10. 常用hexo命令</h2><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h2 id="4-11-config-yml"><a href="#4-11-config-yml" class="headerlink" title="4.11. _config.yml"></a>4.11. _config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p><p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><h2 id="4-12-写博客"><a href="#4-12-写博客" class="headerlink" title="4.12. 写博客"></a>4.12. 写博客</h2><p>定位到我们的hexo根目录，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;哈喽&apos;</span><br></pre></td></tr></table></figure><p>hexo会帮我们在<code>_posts</code>下生成相关md文件，我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： </p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-1ce797798b38d5be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2018-7-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;my-second-blog&quot;</span><br></pre></td></tr></table></figure><p>生成如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-6c7fed837d3f5ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最终部署时生成：<code>GitBlog\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。 </p><h3 id="4-12-1-写博客工具"><a href="#4-12-1-写博客工具" class="headerlink" title="4.12.1. 写博客工具"></a>4.12.1. 写博客工具</h3><p>那么用什么工具写博客呢？</p><p>推荐用Typora和Hbuilder X。</p><h3 id="4-12-2-如何让博文列表不显示全部内容"><a href="#4-12-2-如何让博文列表不显示全部内容" class="headerlink" title="4.12.2. 如何让博文列表不显示全部内容"></a>4.12.2. 如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可。</p><h1 id="5-最终效果"><a href="#5-最终效果" class="headerlink" title="5.最终效果"></a>5.最终效果</h1><p>可以访问我的git博客来查看效果：<a href="https://dadavision.cn" target="_blank" rel="noopener">https://dadavision.cn</a></p><h1 id="6-技巧"><a href="#6-技巧" class="headerlink" title="6.技巧"></a>6.技巧</h1><p>其中生成，上传github有很多命令，以下方法可以减少繁琐，就是创建.bat批处理文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">cd GitBlog</span><br><span class="line">hexo clean &amp; hexo g &amp;&amp; gulp &amp; hexo d &amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/12654931-9a1c787ea7b7e0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>还可以设置全局快捷键：</p><p><img src="https://upload-images.jianshu.io/upload_images/12654931-45711fa97293b226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo-GitHub搭建个人博客&quot;&gt;&lt;a href=&quot;#Hexo-GitHub搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;Hexo+GitHub搭建个人博客&quot;&gt;&lt;/a&gt;Hexo+GitHub搭建个人博客&lt;/h1&gt;&lt;p&gt;目录：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​    准备工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;搭建github博客&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​    创建仓库&lt;br&gt;   ​    绑定域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;配置SSH key&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​    测试是否成功&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用hexo写博客&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​    hexo简介&lt;br&gt;   ​    原理&lt;pre&gt;&lt;code&gt;    注意事项
    安装
    初始化
​    修改主题
​    上传到github
    保留CNAME、README.md等文件
    常用hexo命令
​    _config.yml
    写博客        
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;最终效果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人博客" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>回溯法思想</title>
    <link href="http://yoursite.com/2018/06/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/06/09/回溯法思想/</id>
    <published>2018-06-09T10:32:00.000Z</published>
    <updated>2018-06-11T05:05:12.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="子集树与排列树"><a href="#子集树与排列树" class="headerlink" title="子集树与排列树"></a><strong>子集树与排列树</strong></h3><p>当所给问题是从n个元素的集合S中找出满足某种性质的子集时，解空间为子集树。<br>例如：0-1背包问题 (选或不选问题)<br>当所给问题是从n个元素的集合S中找出满足某种性质的排列时，解空间为排列树。<br>例如：旅行售货员问题（选择顺序问题）</p><h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a><strong>算法结构</strong></h3><p><img src="http://img0.ph.126.net/gCNuXL5Bfja8EblAZBh3rA==/2607021234314375610.png" alt=""></p><a id="more"></a><h3 id="深度优先搜索与广度优先搜索算法有何区别"><a href="#深度优先搜索与广度优先搜索算法有何区别" class="headerlink" title="深度优先搜索与广度优先搜索算法有何区别"></a><strong>深度优先搜索与广度优先搜索算法有何区别</strong></h3><p>深度优先搜索法不全部保留结点，扩展完的结点从数据存储结构栈中弹出删去，在栈中存储的结点数就是解空间树的深度，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。<br>广度优先搜索算法，一般需存储产生所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作（即入栈和出栈的操作），所以运行速度比深度优先搜索要快些。</p><h3 id="回溯与分支限界区别"><a href="#回溯与分支限界区别" class="headerlink" title="回溯与分支限界区别"></a><strong>回溯与分支限界区别</strong></h3><p>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。它们在问题的解空间树T上搜索的方法不同，适合解决的问题也就不同。一般情况下，回溯法的求解目标是找出T中满足约束条件的所有解的方案，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。相对而言，分支限界算法的解空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。</p><h3 id="最优化处理问题"><a href="#最优化处理问题" class="headerlink" title="最优化处理问题"></a><strong>最优化处理问题</strong></h3><p>在处理最优问题时，采用穷举法、回溯法或分支限界法都可以通过利用当前最优解和上界函数加速。仅就对限界剪支的效率而言，优先队列的分支限界法显然要更充分一些。在穷举法中通过上界函数与当前情况下函数值的比较可以直接略过不合要求的情况而省去了更进一步的枚举和判断；回溯法则因为层次的划分，可以在上界函数值小于当前最优解时，剪去以该结点为根的子树，也就是节省了搜索范围；分支限界法在这方面除了可以做到回溯法能做到的之外，同时若采用优先队列的分支限界法，用上界函数作为活结点的优先级，一旦有叶结点成为当前扩展结点，就意味着该叶结点所对应的解即为最优解，可以立即终止其余的过程。在前面的例题中曾说明，优先队列的分支限界法更象是有选择、有目的地进行搜索，时间效率、空间效率都是比较高的。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a><strong>算法总结</strong></h3><p>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！<br>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h4><p>1.求最优解问题<br>2.整体问题的最优解依赖于各个子问题的最优解<br>3.把大问题分解成小问题，小问题之间还有相互重叠的更小的子问题<br>4.从上往下分析，从下往上求解，避免重复求解小问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;子集树与排列树&quot;&gt;&lt;a href=&quot;#子集树与排列树&quot; class=&quot;headerlink&quot; title=&quot;子集树与排列树&quot;&gt;&lt;/a&gt;&lt;strong&gt;子集树与排列树&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;当所给问题是从n个元素的集合S中找出满足某种性质的子集时，解空间为子集树。&lt;br&gt;例如：0-1背包问题 (选或不选问题)&lt;br&gt;当所给问题是从n个元素的集合S中找出满足某种性质的排列时，解空间为排列树。&lt;br&gt;例如：旅行售货员问题（选择顺序问题）&lt;/p&gt;
&lt;h3 id=&quot;算法结构&quot;&gt;&lt;a href=&quot;#算法结构&quot; class=&quot;headerlink&quot; title=&quot;算法结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法结构&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/gCNuXL5Bfja8EblAZBh3rA==/2607021234314375610.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
</feed>
